The contracts are deployed to avalance, Help me ensure that ccip with 

Node Operator Rewards

CCIP rewards the oracle node and Risk Management node operators in LINK.

caution
Transferring tokens

This tutorial uses the term "transferring tokens" even though the tokens are not technically transferred. Instead, they are locked or burned on the source chain and then unlocked or minted on the destination chain. Read the Token Pools section to understand the various mechanisms that are used to transfer value across chains.

Before you begin
You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.

Your account must have some AVAX and LINK tokens on Avalanche Fuji. Learn how to Acquire testnet LINK.

Check the CCIP Directory to confirm that the tokens you will transfer are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.

Learn how to acquire CCIP test tokens. Following this guide, you should have CCIP-BnM tokens, and CCIP-BnM should appear in the list of your tokens in MetaMask.

Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide to fund your contract with any ERC20 tokens as long as they appear in the list of tokens in MetaMask.

Tutorial
note
Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local simulator, an installable package designed to simulate Chainlink CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite, enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your development process and validate your CCIP implementations effectively.

In this tutorial, you will transfer CCIP-BnM tokens from a contract on Avalanche Fuji to an account on Ethereum Sepolia. First, you will pay CCIP fees in LINK, then you will pay CCIP fees in native gas. The destination account can be an EOA (Externally Owned Account) or a smart contract. Moreover, the example shows how to transfer CCIP-BnM tokens, but you can re-use the same example to transfer other tokens as long as they are supported for your lane.

copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple contract for transferring tokens across chains.
contract TokenTransferor is OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance to cover the fees.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.
    error DestinationChainNotAllowlisted(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.
    // Event emitted when the tokens are transferred to an account on another chain.
    event TokensTransferred(
        bytes32 indexed messageId, // The unique ID of the message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedChains;

    IRouterClient private s_router;

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) {
        s_router = IRouterClient(_router);
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedChain(uint64 _destinationChainSelector) {
        if (!allowlistedChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain to be updated.
    /// @param allowed The allowlist status to be set for the destination chain.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedChains[_destinationChainSelector] = allowed;
    }

    /// @notice Transfer tokens to receiver on the destination chain.
    /// @notice pay in LINK.
    /// @notice the token must be in the list of supported tokens.
    /// @notice This function can only be called by the owner.
    /// @dev Assumes your contract has sufficient LINK tokens to pay for the fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the message that was sent.
    function transferTokensPayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        //  address(linkToken) means fees are paid in LINK
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _token,
            _amount,
            address(s_linkToken)
        );

        // Get the fee required to send the message
        uint256 fees = s_router.getFee(
            _destinationChainSelector,
            evm2AnyMessage
        );

        if (fees > s_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        s_linkToken.approve(address(s_router), fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(s_router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = s_router.ccipSend(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit TokensTransferred(
            messageId,
            _destinationChainSelector,
            _receiver,
            _token,
            _amount,
            address(s_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Transfer tokens to receiver on the destination chain.
    /// @notice Pay in native gas such as ETH on Ethereum or POL on Polygon.
    /// @notice the token must be in the list of supported tokens.
    /// @notice This function can only be called by the owner.
    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or POL on Polygon.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the message that was sent.
    function transferTokensPayNative(
        uint64 _destinationChainSelector,
        address _receiver,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(0) means fees are paid in native gas
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _token,
            _amount,
            address(0)
        );

        // Get the fee required to send the message
        uint256 fees = s_router.getFee(
            _destinationChainSelector,
            evm2AnyMessage
        );

        if (fees > address(this).balance)
            revert NotEnoughBalance(address(this).balance, fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(s_router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = s_router.ccipSend{value: fees}(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit TokensTransferred(
            messageId,
            _destinationChainSelector,
            _receiver,
            _token,
            _amount,
            address(0),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for tokens transfer.
    /// @param _receiver The address of the receiver.
    /// @param _token The token to be transferred.
    /// @param _amount The amount of the token to be transferred.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        address _token,
        uint256 _amount,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Set the token amounts
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: _token,
            amount: _amount
        });

        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        return
            Client.EVM2AnyMessage({
                receiver: abi.encode(_receiver), // ABI-encoded receiver address
                data: "", // No data
                tokenAmounts: tokenAmounts, // The amount and type of token being transferred
                extraArgs: Client._argsToBytes(
                    // Additional arguments, setting gas limit and allowing out-of-order execution.
                    // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                    // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                    // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                    Client.GenericExtraArgsV2({
                        gasLimit: 0, // Gas limit for the callback on the destination chain
                        allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                    })
                ),
                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
                feeToken: _feeTokenAddress
            });
    }

    /// @notice Fallback function to allow the contract to receive Ether.
    /// @dev This function has no function body, making it a default function for receiving Ether.
    /// It is automatically called when Ether is transferred to the contract without any data.
    receive() external payable {}

    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.
    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.
    /// It should only be callable by the owner of the contract.
    /// @param _beneficiary The address to which the Ether should be transferred.
    function withdraw(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = address(this).balance;

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        // Attempt to send the funds, capturing the success status and discarding any return data
        (bool sent, ) = _beneficiary.call{value: amount}("");

        // Revert if the send failed, with information about the attempted transfer
        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
Open in Remix
What is Remix?
Deploy your contracts
To use this contract:

Open the contract in Remix.

Compile your contract.

Deploy and fund your sender contract on Avalanche Fuji:

Open MetaMask and select the Avalanche Fuji network.

In Remix IDE, click Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.

Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji:

The router address is 
0xF694E193200268f9a4868e4Aa017A0118C9a8177
Copy to clipboard
,
The LINK contract address is 
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Copy to clipboard
.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.

Open MetaMask and fund your contract with CCIP-BnM tokens. You can transfer 
0.002
Copy to clipboard
 CCIP-BnM to your contract.

Enable your contract to transfer tokens to Ethereum Sepolia:

In Remix IDE, under Deploy & Run Transactions, open the list of functions for your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain function with 
16015286601757825753
Copy to clipboard
 as the destination chain selector, and 
true
Copy to clipboard
 as allowed. Each chain selector is found on the CCIP Directory.
Transfer tokens and pay in LINK
You will transfer 0.001 CCIP-BnM. The CCIP fees for using CCIP will be paid in LINK. Read this explanation for a detailed description of the code example.

Open MetaMask and connect to Avalanche Fuji. Fund your contract with LINK tokens. You can transfer 
70
Copy to clipboard
 LINK to your contract. Note: The LINK tokens are used to pay for CCIP fees.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK from faucets.chain.link or use a supported testnet other than Sepolia.

Transfer CCIP-BnM from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of functions for your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the transferTokensPayLINK function:


Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory.
_receiver	Your account address on Ethereum Sepolia.
The destination account address. It could be a smart contract or an EOA.
_token	
0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4
Copy to clipboard

The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory.
_amount	
1000000000000000
Copy to clipboard

The token amount (0.001 CCIP-BnM).
Click the transact button and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash.


Chainlink CCIP Explorer transaction details
The CCIP transaction is completed once the status is marked as "Success". The data field is empty because you are only transferring tokens.


Chainlink CCIP Explorer transaction details success
Check the receiver account on the destination chain:

Note the destination transaction hash from the CCIP explorer. 0x083fc1a79ffcfd617426fd71dff87ca16db2e4333e62a28cdd13d4bec0926bcb in this example.

Open the block explorer for your destination chain. For Ethereum Sepolia, open etherscan.

Search the transaction hash.


Chainlink CCIP Sepolia tokens received
Notice in the Tokens Transferred section that CCIP-BnM tokens have been transferred to your account (0.001 CCIP-BnM).

Transfer tokens and pay in native
You will transfer 0.001 CCIP-BnM. The CCIP fees for using CCIP will be paid in Avalanche Fuji's native AVAX. Read this explanation for a detailed description of the code example.

Open MetaMask and connect to Avalanche Fuji. Fund your contract with native gas tokens. You can transfer 
0.2
Copy to clipboard
 AVAX to your contract. Note: The native gas tokens are used to pay for CCIP fees.

Transfer CCIP-BnM from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the transferTokensPayNative function:


Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory.
_receiver	Your account address on Ethereum Sepolia.
The destination account address. It could be a smart contract or an EOA.
_token	
0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4
Copy to clipboard

The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory..
_amount	
1000000000000000
Copy to clipboard

The token amount (0.001 CCIP-BnM).
Click the transact button and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash.


Chainlink CCIP Explorer transaction details
The CCIP transaction is completed once the status is marked as "Success". The data field is empty because you only transfer tokens. Note that CCIP fees are denominated in LINK. Even if CCIP fees are paid using native gas tokens, node operators will be paid in LINK.


Chainlink CCIP Explorer transaction details success
Check the receiver account on the destination chain:

Note the destination transaction hash from the CCIP explorer. 0xf403d828fa377d657af67f12e99ff435974299c27ba2d57c53494d29bbbfc938 in this example.

Open the block explorer for your destination chain. For Ethereum Sepolia, open etherscan.

Search the transaction hash.


Chainlink CCIP Sepolia tokens received
Notice in the Tokens Transferred section that CCIP-BnM tokens have been transferred to your account (0.001 CCIP-BnM).

Explanation
note
Integrate Chainlink CCIP v1.6.0 into your project

npmyarnfoundry
If you use NPM, install the @chainlink/contracts-ccip NPM package:

copy to clipboard
npm install @chainlink/contracts-ccip@1.6.0
The smart contract featured in this tutorial is designed to interact with CCIP to transfer a supported token to an account on a destination chain. The contract code contains supporting comments clarifying the functions, events, and underlying logic. This section further explains initializing the contract and transferring tokens.

Initializing of the contract
When you deploy the contract, you define the router address and LINK contract address of the blockchain where you deploy the contract. The contract uses the router address to interact with the router to estimate the CCIP fees and the transmission of CCIP messages.

Transferring tokens and pay in LINK
The transferTokensPayLINK function undertakes six primary operations:

Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is empty because you only transfer tokens.

The tokenAmounts is an array, with each element comprising a EVMTokenAmount struct that contains the token address and amount. The array contains one element where the _token (token address) and _amount (token amount) are passed by the user when calling the transferTokensPayLINK function.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to 0 because the contract only transfers tokens and does not expect function calls on the destination blockchain.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(linkToken) signifies payment in LINK.

caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

Computes the fees by invoking the router's getFee function.

Ensures your contract balance in LINK is enough to cover the fees.

Grants the router contract permission to deduct the fees from the contract's LINK balance.

Grants the router contract permission to deduct the amount from the contract's CCIP-BnM balance.

Dispatches the CCIP message to the destination chain by executing the router's ccipSend function.

Note: As a security measure, the transferTokensPayLINK function is protected by the onlyAllowlistedChain to ensure the contract owner has allowlisted a destination chain.

Transferring tokens and pay in native
The transferTokensPayNative function undertakes five primary operations:

Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is empty because you only transfer tokens.

The tokenAmounts is an array, with each element comprising an EVMTokenAmount struct containing the token address and amount. The array contains one element where the _token (token address) and _amount (token amount) are passed by the user when calling the transferTokensPayNative function.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to 0 because the contract only transfers tokens and does not expect function calls on the destination blockchain.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(0) signifies payment in native gas tokens (ETH).

caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

Computes the fees by invoking the router's getFee function.

Ensures your contract balance in native gas is enough to cover the fees.

Grants the router contract permission to deduct the amount from the contract's CCIP-BnM balance.

Dispatches the CCIP message to the destination chain by executing the router's ccipSend function. Note: msg.value is set because you pay in native gas.

Note: As a security measure, the transferTokensPayNative function is protected by the onlyAllowlistedChain, ensuring the contract owner has allowlisted a destination chain.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.


In this tutorial, you will use Chainlink CCIP to transfer tokens and arbitrary data between smart contracts on different blockchains. First, you will pay for the CCIP fees on the source blockchain using LINK. Then, you will use the same contract to pay CCIP fees in native gas tokens. For example, you would use ETH on Ethereum or AVAX on Avalanche.

note
Node Operator Rewards

CCIP rewards the oracle node and Risk Management node operators in LINK.

caution
Transferring tokens

This tutorial uses the term "transferring tokens" even though the tokens are not technically transferred. Instead, they are locked or burned on the source chain and then unlocked or minted on the destination chain. Read the Token Pools section to understand the various mechanisms that are used to transfer value across chains.

Before you begin
You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
Your account must have some AVAX and LINK tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia. Learn how to Acquire testnet LINK.
Check the CCIP Directory to confirm that the tokens you will transfer are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.
Learn how to acquire CCIP test tokens. Following this guide, you should have CCIP-BnM tokens, and CCIP-BnM should appear in the list of your tokens in MetaMask.
Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide for funding your contract with any ERC20 tokens as long as they appear in the list of tokens in MetaMask.
Follow the previous tutorial: Transfer tokens.
Tutorial
note
Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local simulator, an installable package designed to simulate Chainlink CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite, enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your development process and validate your CCIP implementations effectively.

In this tutorial, you will send a string text and CCIP-BnM tokens between smart contracts on Avalanche Fuji and Ethereum Sepolia using CCIP. First, you will pay CCIP fees in LINK, then you will pay CCIP fees in native gas.

copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple messenger contract for transferring/receiving tokens and data across chains.
contract ProgrammableTokenTransfers is CCIPReceiver, OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance to cover the fees.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.
    error DestinationChainNotAllowed(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error SourceChainNotAllowed(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowed(address sender); // Used when the sender has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        string text, // The text being sent.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address sender, // The address of the sender from the source chain.
        string text, // The text that was received.
        address token, // The token address that was transferred.
        uint256 tokenAmount // The token amount that was transferred.
    );

    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.
    address private s_lastReceivedTokenAddress; // Store the last received token address.
    uint256 private s_lastReceivedTokenAmount; // Store the last received amount.
    string private s_lastReceivedText; // Store the last received text.

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowed(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowed(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowed(_sender);
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain to be updated.
    /// @param allowed The allowlist status to be set for the destination chain.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain to be updated.
    /// @param allowed The allowlist status to be set for the source chain.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _sender The address of the sender to be updated.
    /// @param allowed The allowlist status to be set for the sender.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK to pay for CCIP fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(linkToken) means fees are paid in LINK
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > s_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        s_linkToken.approve(address(router), fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in native gas.
    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or POL on Polygon.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayNative(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(0) means fees are paid in native gas
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            _token,
            _amount,
            address(0)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > address(this).balance)
            revert NotEnoughBalance(address(this).balance, fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend{value: fees}(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(0),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /**
     * @notice Returns the details of the last CCIP received message.
     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.
     * @return messageId The ID of the last received CCIP message.
     * @return text The text of the last received CCIP message.
     * @return tokenAddress The address of the token in the last CCIP received message.
     * @return tokenAmount The amount of the token in the last CCIP received message.
     */
    function getLastReceivedMessageDetails()
        public
        view
        returns (
            bytes32 messageId,
            string memory text,
            address tokenAddress,
            uint256 tokenAmount
        )
    {
        return (
            s_lastReceivedMessageId,
            s_lastReceivedText,
            s_lastReceivedTokenAddress,
            s_lastReceivedTokenAmount
        );
    }

    /// handle a received message
    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    )
        internal
        override
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure source chain and sender are allowlisted
    {
        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId
        s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text
        // Expect one token to be transferred at once, but you can transfer several tokens.
        s_lastReceivedTokenAddress = any2EvmMessage.destTokenAmounts[0].token;
        s_lastReceivedTokenAmount = any2EvmMessage.destTokenAmounts[0].amount;

        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            abi.decode(any2EvmMessage.data, (string)),
            any2EvmMessage.destTokenAmounts[0].token,
            any2EvmMessage.destTokenAmounts[0].amount
        );
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for programmable tokens transfer.
    /// @param _receiver The address of the receiver.
    /// @param _text The string data to be sent.
    /// @param _token The token to be transferred.
    /// @param _amount The amount of the token to be transferred.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Set the token amounts
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: _token,
            amount: _amount
        });
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        return
            Client.EVM2AnyMessage({
                receiver: abi.encode(_receiver), // ABI-encoded receiver address
                data: abi.encode(_text), // ABI-encoded string
                tokenAmounts: tokenAmounts, // The amount and type of token being transferred
                extraArgs: Client._argsToBytes(
                    // Additional arguments, setting gas limit and allowing out-of-order execution.
                    // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                    // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                    // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                    Client.GenericExtraArgsV2({
                        gasLimit: 200_000, // Gas limit for the callback on the destination chain
                        allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                    })
                ),
                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
                feeToken: _feeTokenAddress
            });
    }

    /// @notice Fallback function to allow the contract to receive Ether.
    /// @dev This function has no function body, making it a default function for receiving Ether.
    /// It is automatically called when Ether is sent to the contract without any data.
    receive() external payable {}

    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.
    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.
    /// It should only be callable by the owner of the contract.
    /// @param _beneficiary The address to which the Ether should be sent.
    function withdraw(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = address(this).balance;

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        // Attempt to send the funds, capturing the success status and discarding any return data
        (bool sent, ) = _beneficiary.call{value: amount}("");

        // Revert if the send failed, with information about the attempted transfer
        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
Open in Remix
What is Remix?
Deploy your contracts
To use this contract:

Open the contract in Remix.

Compile your contract.

Deploy, fund your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.
In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji:
The router address is 
0xF694E193200268f9a4868e4Aa017A0118C9a8177
Copy to clipboard
,
The LINK contract address is 
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Copy to clipboard
.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.
Open MetaMask and fund your contract with CCIP-BnM tokens. You can transfer 
0.002
Copy to clipboard
 CCIP-BnM to your contract.
Enable your contract to send CCIP messages to Ethereum Sepolia:
In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain, setting the destination chain selector to 
16015286601757825753
Copy to clipboard
 and setting allowed to 
true
Copy to clipboard
. Each chain selector is found on the CCIP Directory.
Deploy your receiver contract on Ethereum Sepolia and enable receiving messages from your sender contract:

Open MetaMask and select the network Ethereum Sepolia.
In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Ethereum Sepolia, the router address is 
0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
Copy to clipboard
 and the LINK contract address is 
0x779877A7B0D9E8603169DdbD7836e478b4624789
Copy to clipboard
.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.
Enable your contract to receive CCIP messages from Avalanche Fuji:
In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSourceChain with 
14767482510784806043
Copy to clipboard
 as the source chain selector, and 
true
Copy to clipboard
 as allowed. Each chain selector is found on the CCIP Directory.
Enable your contract to receive CCIP messages from the contract that you deployed on Avalanche Fuji:
In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSender with the contract address of the contract that you deployed on Avalanche Fuji, and 
true
Copy to clipboard
 as allowed.
At this point, you have one sender contract on Avalanche Fuji and one receiver contract on Ethereum Sepolia. As security measures, you enabled the sender contract to send CCIP messages to Ethereum Sepolia and the receiver contract to receive CCIP messages from the sender on Avalanche Fuji.

Note: Another security measure enforces that only the router can call the _ccipReceive function. Read the explanation section for more details.

Transfer and Receive tokens and data and pay in LINK
You will transfer 0.001 CCIP-BnM and a text. The CCIP fees for using CCIP will be paid in LINK. Read this explanation for a detailed description of the code example.

Open MetaMask and connect to Avalanche Fuji. Fund your contract with LINK tokens. You can transfer 
70
Copy to clipboard
 LINK to your contract. In this example, LINK is used to pay the CCIP fees.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK from faucets.chain.link or use a supported testnet other than Sepolia.

Send a string data with tokens from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:


Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory.
_receiver	Your receiver contract address on Ethereum Sepolia.
The destination contract address.
_text	
Hello World!
Copy to clipboard

Any string
_token	
0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4
Copy to clipboard

The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory.
_amount	
1000000000000000
Copy to clipboard

The token amount (0.001 CCIP-BnM).
Click on transact and confirm the transaction on MetaMask.

After the transaction is successful, record the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash.


Chainlink CCIP Explorer transaction details
The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0x99a15381125e740c43a60f03c6b011ae05a3541998ca482fb5a4814417627df8.


Chainlink CCIP Explorer transaction details success
Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails function.


Chainlink CCIP Sepolia message details
Notice the received messageId is 0x99a15381125e740c43a60f03c6b011ae05a3541998ca482fb5a4814417627df8, the received text is Hello World!, the token address is 0xFd57b4ddBf88a4e07fF4e34C487b99af2Fe82a05 (CCIP-BnM token address on Ethereum Sepolia) and the token amount is 1000000000000000 (0.001 CCIP-BnM).

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to transfer tokens with data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

Transfer and Receive tokens and data and pay in native
You will transfer 0.001 CCIP-BnM and a text. The CCIP fees for using CCIP will be paid in Avalanche's native AVAX. Read this explanation for a detailed description of the code example.

Open MetaMask and connect to Avalanche Fuji. Fund your contract with AVAX tokens. You can transfer 
0.2
Copy to clipboard
 AVAX to your contract. The native gas tokens are used to pay the CCIP fees.

Send a string data with tokens from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayNative function:


Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory.
_receiver	Your receiver contract address at Ethereum Sepolia.
The destination contract address.
_text	
Hello World!
Copy to clipboard

Any string
_token	
0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4
Copy to clipboard

The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory.
_amount	
1000000000000000
Copy to clipboard

The token amount (0.001 CCIP-BnM).
Click on transact and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash.


Chainlink CCIP Explorer transaction details
The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0x32bf96ac8b01fe3f04ffa548a3403b3105b4ed479eff407ff763b7539a1d43bd. Note that CCIP fees are denominated in LINK. Even if CCIP fees are paid using native gas tokens, node operators will be paid in LINK.


Chainlink CCIP Explorer transaction details success
Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails function.


Chainlink CCIP Sepolia message details
Notice the received messageId is 0x32bf96ac8b01fe3f04ffa548a3403b3105b4ed479eff407ff763b7539a1d43bd, the received text is Hello World!, the token address is 0xFd57b4ddBf88a4e07fF4e34C487b99af2Fe82a05 (CCIP-BnM token address on Ethereum Sepolia) and the token amount is 1000000000000000 (0.001 CCIP-BnM).

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to transfer tokens with data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

Explanation
note
Integrate Chainlink CCIP v1.6.0 into your project

npmyarnfoundry
If you use NPM, install the @chainlink/contracts-ccip NPM package:

copy to clipboard
npm install @chainlink/contracts-ccip@1.6.0
The smart contract featured in this tutorial is designed to interact with CCIP to transfer and receive tokens and data. The contract code contains supporting comments clarifying the functions, events, and underlying logic. Here we will further explain initializing the contract and sending data with tokens.

Initializing the contract
When deploying the contract, we define the router address and LINK contract address of the blockchain we deploy the contract on. Defining the router address is useful for the following:

Sender part:

Calls the router's getFee function to estimate the CCIP fees.
Calls the router's ccipSend function to send CCIP messages.
Receiver part:

The contract inherits from CCIPReceiver, which serves as a base contract for receiver contracts. This contract requires that child contracts implement the _ccipReceive function. _ccipReceive is called by the ccipReceive function, which ensures that only the router can deliver CCIP messages to the receiver contract.
Transferring tokens and data and pay in LINK
The sendMessagePayLINK function undertakes six primary operations:

Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is encoded from a string to bytes using abi.encode.

The tokenAmounts is an array, with each element comprising an EVMTokenAmount struct containing the token address and amount. The array contains one element where the _token (token address) and _amount (token amount) are passed by the user when calling the sendMessagePayLINK function.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to `200000.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(linkToken) signifies payment in LINK.

caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

Computes the fees by invoking the router's getFee function.

Ensures your contract balance in LINK is enough to cover the fees.

Grants the router contract permission to deduct the fees from the contract's LINK balance.

Grants the router contract permission to deduct the amount from the contract's CCIP-BnM balance.

Dispatches the CCIP message to the destination chain by executing the router's ccipSend function.

Note: As a security measure, the sendMessagePayLINK function is protected by the onlyAllowlistedDestinationChain, ensuring the contract owner has allowlisted a destination chain.

Transferring tokens and data and pay in native
The sendMessagePayNative function undertakes five primary operations:

Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is encoded from a string to bytes using abi.encode.

The tokenAmounts is an array, with each element comprising an EVMTokenAmount struct containing the token address and amount. The array contains one element where the _token (token address) and _amount (token amount) are passed by the user when calling the sendMessagePayNative function.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to `200000.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(0) signifies payment in native gas tokens (ETH).

caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

Computes the fees by invoking the router's getFee function.

Ensures your contract balance in native gas is enough to cover the fees.

Grants the router contract permission to deduct the amount from the contract's CCIP-BnM balance.

Dispatches the CCIP message to the destination chain by executing the router's ccipSend function. Note: msg.value is set because you pay in native gas.

Note: As a security measure, the sendMessagePayNative function is protected by the onlyAllowlistedDestinationChain, ensuring the contract owner has allowlisted a destination chain.

Receiving messages
On the destination blockchain, the router invokes the _ccipReceive function which expects a Any2EVMMessage struct that contains:

The CCIP messageId.
The sourceChainSelector.
The sender address in bytes format. Given that the sender is known to be a contract deployed on an EVM-compatible blockchain, the address is decoded from bytes to an Ethereum address using the ABI specifications.
The tokenAmounts is an array containing received tokens and their respective amounts. Given that only one token transfer is expected, the first element of the array is extracted.
The data, which is also in bytes format. Given a string is expected, the data is decoded from bytes to a string using the ABI specifications.
Note: Three important security measures are applied:

_ccipReceive is called by the ccipReceive function, which ensures that only the router can deliver CCIP messages to the receiver contract. See the onlyRouter modifier for more information.
The modifier onlyAllowlisted ensures that only a call from an allowlisted source chain and sender is accepted.
caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



This tutorial extends the programmable token transfers example. It uses Chainlink CCIP to transfer tokens and arbitrary data between smart contracts on different blockchains, and focuses on defensive coding in the receiver contract. In the event of a specified error during the CCIP message reception, the contract locks the tokens. Locking the tokens allows the owner to recover and redirect them as needed. Defensive coding is crucial as it enables the recovery of locked tokens and ensures the protection of your users' assets.

caution
Transferring tokens

This tutorial uses the term "transferring tokens" even though the tokens are not technically transferred. Instead, they are locked or burned on the source chain and then unlocked or minted on the destination chain. Read the Token Pools section to understand the various mechanisms that are used to transfer value across chains.

Before you begin
You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
Your account must have some AVAX and LINK tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia. Learn how to Acquire testnet LINK.
Check the CCIP Directory to confirm that the tokens you will transfer are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.
Learn how to acquire CCIP test tokens. Following this guide, you should have CCIP-BnM tokens, and CCIP-BnM should appear in the list of your tokens in MetaMask.
Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide for funding your contract with any ERC20 tokens as long as they appear in the list of tokens in MetaMask.
Follow the previous tutorial: Transfer Tokens with Data to learn how to make programmable token transfers using CCIP.
Tutorial
note
Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local simulator, an installable package designed to simulate Chainlink CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite, enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your development process and validate your CCIP implementations effectively.

In this guide, you'll initiate a transaction from a smart contract on Avalanche Fuji, sending a string text and CCIP-BnM tokens to another smart contract on Ethereum Sepolia using CCIP. However, a deliberate failure in the processing logic will occur upon reaching the receiver contract. This tutorial will demonstrate a graceful error-handling approach, allowing the contract owner to recover the locked tokens.

note
Correctly estimate your gas limit

It is crucial to thoroughly test all scenarios to accurately estimate the required gas limit, including for failure scenarios. Be aware that the gas used to execute the error-handling logic for failure scenarios may be higher than that for successful scenarios.

copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";
import {EnumerableMap} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableMap.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple messenger contract for transferring/receiving tokens and data across chains.
/// @dev - This example shows how to recover tokens in case of revert
contract ProgrammableDefensiveTokenTransfers is CCIPReceiver, OwnerIsCreator {
    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance to cover the fees.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.
    error DestinationChainNotAllowlisted(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error SourceChainNotAllowed(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowed(address sender); // Used when the sender has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.
    error OnlySelf(); // Used when a function is called outside of the contract itself.
    error ErrorCase(); // Used when simulating a revert during message processing.
    error MessageNotFailed(bytes32 messageId);

    // Example error code, could have many different error codes.
    enum ErrorCode {
        // RESOLVED is first so that the default value is resolved.
        RESOLVED,
        // Could have any number of error codes here.
        FAILED
    }

    struct FailedMessage {
        bytes32 messageId;
        ErrorCode errorCode;
    }

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        string text, // The text being sent.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address sender, // The address of the sender from the source chain.
        string text, // The text that was received.
        address token, // The token address that was transferred.
        uint256 tokenAmount // The token amount that was transferred.
    );

    event MessageFailed(bytes32 indexed messageId, bytes reason);
    event MessageRecovered(bytes32 indexed messageId);

    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.
    address private s_lastReceivedTokenAddress; // Store the last received token address.
    uint256 private s_lastReceivedTokenAmount; // Store the last received amount.
    string private s_lastReceivedText; // Store the last received text.

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    IERC20 private s_linkToken;

    // The message contents of failed messages are stored here.
    mapping(bytes32 messageId => Client.Any2EVMMessage contents)
        public s_messageContents;

    // Contains failed messages and their state.
    EnumerableMap.Bytes32ToUintMap internal s_failedMessages;

    // This is used to simulate a revert in the processMessage function.
    bool internal s_simRevert = false;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowed(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowed(_sender);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Modifier to allow only the contract itself to execute a function.
    /// Throws an exception if called by any account other than the contract itself.
    modifier onlySelf() {
        if (msg.sender != address(this)) revert OnlySelf();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain to be updated.
    /// @param allowed The allowlist status to be set for the destination chain.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain to be updated.
    /// @param allowed The allowlist status to be set for the source chain.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _sender The address of the sender to be updated.
    /// @param allowed The allowlist status to be set for the sender.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK to pay for CCIP fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(linkToken) means fees are paid in LINK
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > s_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        s_linkToken.approve(address(router), fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in native gas.
    /// @dev Assumes your contract has sufficient native gas like ETH on Ethereum or POL on Polygon.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayNative(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(0) means fees are paid in native gas
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            _token,
            _amount,
            address(0)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > address(this).balance)
            revert NotEnoughBalance(address(this).balance, fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend{value: fees}(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(0),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /**
     * @notice Returns the details of the last CCIP received message.
     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.
     * @return messageId The ID of the last received CCIP message.
     * @return text The text of the last received CCIP message.
     * @return tokenAddress The address of the token in the last CCIP received message.
     * @return tokenAmount The amount of the token in the last CCIP received message.
     */
    function getLastReceivedMessageDetails()
        public
        view
        returns (
            bytes32 messageId,
            string memory text,
            address tokenAddress,
            uint256 tokenAmount
        )
    {
        return (
            s_lastReceivedMessageId,
            s_lastReceivedText,
            s_lastReceivedTokenAddress,
            s_lastReceivedTokenAmount
        );
    }

    /**
     * @notice Retrieves a paginated list of failed messages.
     * @dev This function returns a subset of failed messages defined by `offset` and `limit` parameters. It ensures that the pagination parameters are within the bounds of the available data set.
     * @param offset The index of the first failed message to return, enabling pagination by skipping a specified number of messages from the start of the dataset.
     * @param limit The maximum number of failed messages to return, restricting the size of the returned array.
     * @return failedMessages An array of `FailedMessage` struct, each containing a `messageId` and an `errorCode` (RESOLVED or FAILED), representing the requested subset of failed messages. The length of the returned array is determined by the `limit` and the total number of failed messages.
     */
    function getFailedMessages(
        uint256 offset,
        uint256 limit
    ) external view returns (FailedMessage[] memory) {
        uint256 length = s_failedMessages.length();

        // Calculate the actual number of items to return (can't exceed total length or requested limit)
        uint256 returnLength = (offset + limit > length)
            ? length - offset
            : limit;
        FailedMessage[] memory failedMessages = new FailedMessage[](
            returnLength
        );

        // Adjust loop to respect pagination (start at offset, end at offset + limit or total length)
        for (uint256 i = 0; i < returnLength; i++) {
            (bytes32 messageId, uint256 errorCode) = s_failedMessages.at(
                offset + i
            );
            failedMessages[i] = FailedMessage(messageId, ErrorCode(errorCode));
        }
        return failedMessages;
    }

    /// @notice The entrypoint for the CCIP router to call. This function should
    /// never revert, all errors should be handled internally in this contract.
    /// @param any2EvmMessage The message to process.
    /// @dev Extremely important to ensure only router calls this.
    function ccipReceive(
        Client.Any2EVMMessage calldata any2EvmMessage
    )
        external
        override
        onlyRouter
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure the source chain and sender are allowlisted
    {
        /* solhint-disable no-empty-blocks */
        try this.processMessage(any2EvmMessage) {
            // Intentionally empty in this example; no action needed if processMessage succeeds
        } catch (bytes memory err) {
            // Could set different error codes based on the caught error. Each could be
            // handled differently.
            s_failedMessages.set(
                any2EvmMessage.messageId,
                uint256(ErrorCode.FAILED)
            );
            s_messageContents[any2EvmMessage.messageId] = any2EvmMessage;
            // Don't revert so CCIP doesn't revert. Emit event instead.
            // The message can be retried later without having to do manual execution of CCIP.
            emit MessageFailed(any2EvmMessage.messageId, err);
            return;
        }
    }

    /// @notice Serves as the entry point for this contract to process incoming messages.
    /// @param any2EvmMessage Received CCIP message.
    /// @dev Transfers specified token amounts to the owner of this contract. This function
    /// must be external because of the  try/catch for error handling.
    /// It uses the `onlySelf`: can only be called from the contract.
    function processMessage(
        Client.Any2EVMMessage calldata any2EvmMessage
    )
        external
        onlySelf
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure the source chain and sender are allowlisted
    {
        // Simulate a revert for testing purposes
        if (s_simRevert) revert ErrorCase();

        _ccipReceive(any2EvmMessage); // process the message - may revert as well
    }

    /// @notice Allows the owner to retry a failed message in order to unblock the associated tokens.
    /// @param messageId The unique identifier of the failed message.
    /// @param tokenReceiver The address to which the tokens will be sent.
    /// @dev This function is only callable by the contract owner. It changes the status of the message
    /// from 'failed' to 'resolved' to prevent reentry and multiple retries of the same message.
    function retryFailedMessage(
        bytes32 messageId,
        address tokenReceiver
    ) external onlyOwner {
        // Check if the message has failed; if not, revert the transaction.
        if (s_failedMessages.get(messageId) != uint256(ErrorCode.FAILED))
            revert MessageNotFailed(messageId);

        // Set the error code to RESOLVED to disallow reentry and multiple retries of the same failed message.
        s_failedMessages.set(messageId, uint256(ErrorCode.RESOLVED));

        // Retrieve the content of the failed message.
        Client.Any2EVMMessage memory message = s_messageContents[messageId];

        // This example expects one token to have been sent, but you can handle multiple tokens.
        // Transfer the associated tokens to the specified receiver as an escape hatch.
        IERC20(message.destTokenAmounts[0].token).safeTransfer(
            tokenReceiver,
            message.destTokenAmounts[0].amount
        );

        // Emit an event indicating that the message has been recovered.
        emit MessageRecovered(messageId);
    }

    /// @notice Allows the owner to toggle simulation of reversion for testing purposes.
    /// @param simRevert If `true`, simulates a revert condition; if `false`, disables the simulation.
    /// @dev This function is only callable by the contract owner.
    function setSimRevert(bool simRevert) external onlyOwner {
        s_simRevert = simRevert;
    }

    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    ) internal override {
        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId
        s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text
        // Expect one token to be transferred at once, but you can transfer several tokens.
        s_lastReceivedTokenAddress = any2EvmMessage.destTokenAmounts[0].token;
        s_lastReceivedTokenAmount = any2EvmMessage.destTokenAmounts[0].amount;
        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            abi.decode(any2EvmMessage.data, (string)),
            any2EvmMessage.destTokenAmounts[0].token,
            any2EvmMessage.destTokenAmounts[0].amount
        );
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for programmable tokens transfer.
    /// @param _receiver The address of the receiver.
    /// @param _text The string data to be sent.
    /// @param _token The token to be transferred.
    /// @param _amount The amount of the token to be transferred.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Set the token amounts
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({
            token: _token,
            amount: _amount
        });
        tokenAmounts[0] = tokenAmount;
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({
            receiver: abi.encode(_receiver), // ABI-encoded receiver address
            data: abi.encode(_text), // ABI-encoded string
            tokenAmounts: tokenAmounts, // The amount and type of token being transferred
            extraArgs: Client._argsToBytes(
                // Additional arguments, setting gas limit and allowing out-of-order execution.
                // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                Client.GenericExtraArgsV2({
                    gasLimit: 400_000, // Gas limit for the callback on the destination chain
                    allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                })
            ),
            // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
            feeToken: _feeTokenAddress
        });
        return evm2AnyMessage;
    }

    /// @notice Fallback function to allow the contract to receive Ether.
    /// @dev This function has no function body, making it a default function for receiving Ether.
    /// It is automatically called when Ether is sent to the contract without any data.
    receive() external payable {}

    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.
    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.
    /// It should only be callable by the owner of the contract.
    /// @param _beneficiary The address to which the Ether should be sent.
    function withdraw(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = address(this).balance;

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        // Attempt to send the funds, capturing the success status and discarding any return data
        (bool sent, ) = _beneficiary.call{value: amount}("");

        // Revert if the send failed, with information about the attempted transfer
        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
Open in Remix
What is Remix?
Deploy your contracts
To use this contract:

Open the contract in Remix.

Compile your contract.

Deploy, fund your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.
In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji:
The router address is 
0xF694E193200268f9a4868e4Aa017A0118C9a8177
Copy to clipboard
,
The LINK contract address is 
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Copy to clipboard
.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.
Open MetaMask and fund your contract with CCIP-BnM tokens. You can transfer 
0.002
Copy to clipboard
 CCIP-BnM to your contract.
Enable your contract to send CCIP messages to Ethereum Sepolia:
In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain with 
16015286601757825753
Copy to clipboard
 as the destination chain selector, and 
true
Copy to clipboard
 as allowed. Each chain selector is found on the CCIP Directory.
Deploy your receiver contract on Ethereum Sepolia and enable receiving messages from your sender contract:

Open MetaMask and select the network Ethereum Sepolia.
In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Ethereum Sepolia:
The router address is 
0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
Copy to clipboard
,
The LINK contract address is 
0x779877A7B0D9E8603169DdbD7836e478b4624789
Copy to clipboard
.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.
Enable your contract to receive CCIP messages from Avalanche Fuji:
In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSourceChain with 
14767482510784806043
Copy to clipboard
 as the source chain selector, and 
true
Copy to clipboard
 as allowed. Each chain selector is found on the CCIP Directory.
Enable your contract to receive CCIP messages from the contract that you deployed on Avalanche Fuji:
In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSender with the contract address of the contract that you deployed on Avalanche Fuji, and 
true
Copy to clipboard
 as allowed.
Call the setSimRevert function, passing true as a parameter, then wait for the transaction to confirm. Setting s_simRevert to true simulates a failure when processing the received message. Read the explanation section for more details.
At this point, you have one sender contract on Avalanche Fuji and one receiver contract on Ethereum Sepolia. As security measures, you enabled the sender contract to send CCIP messages to Ethereum Sepolia and the receiver contract to receive CCIP messages from the sender on Avalanche Fuji. The receiver contract cannot process the message, and therefore, instead of throwing an exception, it will lock the received tokens, enabling the owner to recover them.

Note: Another security measure enforces that only the router can call the _ccipReceive function. Read the explanation section for more details.

Recover the locked tokens
You will transfer 0.001 CCIP-BnM and a text. The CCIP fees for using CCIP will be paid in LINK.

Open MetaMask and connect to Avalanche Fuji. Fund your contract with LINK tokens. You can transfer 
70
Copy to clipboard
 LINK to your contract. In this example, LINK is used to pay the CCIP fees.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK from faucets.chain.link or use a supported testnet other than Sepolia.

Send a string data with tokens from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:


Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory.
_receiver	Your receiver contract address at Ethereum Sepolia.
The destination contract address.
_text	
Hello World!
Copy to clipboard

Any string
_token	
0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4
Copy to clipboard

The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory.
_amount	
1000000000000000
Copy to clipboard

The token amount (0.001 CCIP-BnM).
Click on transact and confirm the transaction on MetaMask.

After the transaction is successful, record the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash.


Chainlink CCIP Explorer transaction details
The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0x120367995ef71f83d64a05bd7793862afda9d04049da4cb32851934490d03ae4.


Chainlink CCIP Explorer transaction details success
Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of functions of your smart contract deployed on Ethereum Sepolia.

Call the getFailedMessages function with an offset of 
0
Copy to clipboard
 and a limit of 
1
Copy to clipboard
 to retrieve the first failed message.


Chainlink CCIP Fuji last failed message ids
Notice the returned values are: 0x120367995ef71f83d64a05bd7793862afda9d04049da4cb32851934490d03ae4 (the message ID) and 1 (the error code indicating failure).

To recover the locked tokens, call the retryFailedMessage function:

Argument	Description
messageId	The unique identifier of the failed message.
tokenReceiver	The address to which the tokens will be sent.

Chainlink CCIP Sepolia retry failed message id
After confirming the transaction, you can open it in a block explorer. Notice that the locked funds were transferred to the tokenReceiver address.


Chainlink CCIP retry failed message - tokens transferred
Call again the getFailedMessages function with an offset of 
0
Copy to clipboard
 and a limit of 
1
Copy to clipboard
 to retrieve the first failed message. Notice that the error code is now 0, indicating that the message was resolved.


Chainlink CCIP retry failed message - tokens transferred - recovered
Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to transfer tokens with data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

Explanation
note
Integrate Chainlink CCIP v1.6.0 into your project

npmyarnfoundry
If you use NPM, install the @chainlink/contracts-ccip NPM package:

copy to clipboard
npm install @chainlink/contracts-ccip@1.6.0
The smart contract featured in this tutorial is designed to interact with CCIP to transfer and receive tokens and data. The contract code is similar to the Transfer Tokens with Data tutorial. Hence, you can refer to its code explanation. We will only explain the main differences.

Sending messages
caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

The sendMessagePayLINK function is similar to the sendMessagePayLINK function in the Transfer Tokens with Data tutorial. The main difference is the increased gas limit to account for the additional gas required to process the error-handling logic.

Receiving and processing messages
Upon receiving a message on the destination blockchain, the ccipReceive function is called by the CCIP router. This function serves as the entry point to the contract for processing incoming CCIP messages, enforcing crucial security checks through the onlyRouter, and onlyAllowlisted modifiers.

Here's the step-by-step breakdown of the process:

Entrance through ccipReceive:

The ccipReceive function is invoked with an Any2EVMMessage struct containing the message to be processed.
Security checks ensure the call is from the authorized router, an allowlisted source chain, and an allowlisted sender.
Processing Message:

ccipReceive calls the processMessage function, which is external to leverage Solidity's try/catch error handling mechanism. Note: The onlySelf modifier ensures that only the contract can call this function.
Inside processMessage, a check is performed for a simulated revert condition using the s_simRevert state variable. This simulation is toggled by the setSimRevert function, callable only by the contract owner.
If s_simRevert is false, processMessage calls the _ccipReceive function for further message processing.
Message Processing in _ccipReceive:

_ccipReceive extracts and stores various information from the message, such as the messageId, decoded sender address, token amounts, and data.
It then emits a MessageReceived event, signaling the successful processing of the message.
Error Handling:

If an error occurs during the processing (or a simulated revert is triggered), the catch block within ccipReceive is executed.
The messageId of the failed message is added to s_failedMessages, and the message content is stored in s_messageContents.
A MessageFailed event is emitted, which allows for later identification and reprocessing of failed messages.
Reprocessing of failed messages
The retryFailedMessage function provides a mechanism to recover assets if a CCIP message processing fails. It's specifically designed to handle scenarios where message data issues prevent entire processing yet allow for token recovery:

Initiation:

Only the contract owner can call this function, providing the messageId of the failed message and the tokenReceiver address for token recovery.
Validation:

It checks if the message has failed using s_failedMessages.get(messageId). If not, it reverts the transaction.
Status Update:

The error code for the message is updated to RESOLVED to prevent reentry and multiple retries.
Token Recovery:

Retrieves the failed message content using s_messageContents[messageId].
Transfers the locked tokens associated with the failed message to the specified tokenReceiver as an escape hatch without processing the entire message again.
Event Emission:

An event MessageRecovered is emitted to signal the successful recovery of the tokens.
This function showcases a graceful asset recovery solution, protecting user values even when message processing encounters issues.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



The Token Manager allows token developers to deploy, configure, and manage Cross-Chain Tokens (CCTs) in a simplified web interface. The process involves deploying tokens and token pools, registering administrative roles, and configuring token pools to enable secure token transfers using CCIP.

The Token Manager guides you through two workflows:

Deploy a new token from scratch: This is the more beginner-friendly workflow that guides you through the entire process step-by-step, starting by creating a token from scratch.
Enable an existing token to go cross-chain: This is a more advanced workflow for token developers who have already deployed their token and want to add cross-chain capabilities.
If you prefer to manage your deployments and configurations programmatically, refer to the Cross-Chain Tokens guides available for Remix, Hardhat and Foundry.

You can also use the CCIP JavaScript SDK to add a fully featured CCIP bridge to your app that can be styled to match your app design.

After enabling your tokens, you can also use Transporter to perform transfers and import tokens with the contract address. Use test.transporter.io for testnet or transporter.io for mainnet.

Limitations
Currently, the following advanced features are not yet supported in Token Manager:

Token pool replacements and upgrades for existing tokens. This capability will be added in a subsequent update. To learn more about the process of replacing and upgrading existing token pools, review the CCIP token pool upgradability section.
Deployment of token pools that use the Lock and Unlock mechanism. The Token Manager Wizard automatically configures all tokens with the Burn & Mint mechanism. (Refer to the Burn & Mint token contract and Burn & Mint token pool contract for the Burn & Mint mechanism.)
Deployment or enablement of custom token pools is not yet supported.
Getting started
The Token Manager includes both testnet and mainnet functionality. It is highly recommended to test and perform any operations on testnet before mainnet.

Before you can deploy a new token or add an existing token, you need to connect and authorize your wallet.

Open the Token Manager using the appropriate link for your use case:

For testnet, use https://test.tokenmanager.chain.link.
For mainnet, use https://tokenmanager.chain.link/
Connect your wallet using the Connect wallet button in the upper right corner. The following wallets are supported:

Metamask (EOA)
Coinbase wallet (EOA)
WalletConnect (EOA & Safe)
Rabby wallet (EOA & Safe)
After your wallet is connected, authorize the use of your wallet by clicking Authorize and complete the subsequent authorization flow for your wallet type. If you are connecting a Safe wallet, authorization is key to enabling permissioned actions on a per user basis; such as initiating transactions, updating off-chain data, and inviting collaborators.

Deploy a new token
caution
Token status

CCIP allows users to register and manage tokens in a permissionless manner. A "Verified" status of a token indicates only that the Token Creator has signed transactions evidencing their ownership. Users should conduct their own research before engaging with any tokens.

Once wallet connection and authorization is complete, click Add new token under the My tokens section of the Token Manager Dashboard.

In the Token Manager Wizard, select Deploy a new token and click Continue in the lower right corner.

Select deploy a new token
On the Details page, enter the details for the first network you're configuring for your token deployment:

Select the network in the Network dropdown field.
Fill in the Name and Symbol fields to give your token its name and ticker symbol. For example, "Your Token" and "YOURS" respectively.
Click Continue.
Naming your new token
On the Settings page, configure your token's supply:

Setting a supply cap is optional  toggle the button to enable it and specify an amount. The supply cap sets a maximum limit for the total number of tokens that can ever be minted for the token you're creating.
Specify an amount of tokens to mint during this initial deployment step.
Click Continue.
Setting token supply cap and amount to mint
On the Networks page, select the additional blockchain network(s) where you'd like to deploy your new token and click Continue.

Selecting blockchain networks
On the Owners page, confirm the accounts that will be taking actions on each network. Click Continue.

Confirming network accounts
The default account is the currently connected wallet. However, you can have different accounts for each network depending on who you want to be the owner.

On the Summary page, you can review your upcoming deployments and transactions. Each network you've selected appears along with an expandable list of the transactions the Token Manager will guide you through to deploy your token for each network:

Summary of upcoming deployments
Make sure that your wallet contains gas tokens for each network where you're deploying your token, in order to pay for the deployment transactions.

If you selected more than two networks during the previous step, the Remove links are active, allowing you to remove a network before proceeding. If you only have two networks selected, the Remove links are intentionally not active. If you need to add more networks, navigate back to the Networks page.

The Deploy page displays the steps that you need to complete for each network:

Deploy token and pool
Accept admin role
Accept token ownership
Accept pool ownership
Deployment steps
After the Deploy token and pool step is completed, you can initiate the other steps all at the same time by clicking Accept under each step. While these steps run concurrently, each step separately prompts you to confirm the corresponding transactions in your wallet.

Once all of the steps for one network have been initiated, you can switch to the other network and repeat the same process. You do not have to wait for the first network deploy process to be complete before initiating the second network deploy process.

When the deploy process is complete for all the networks you selected, the Token Manager marks them all as Done:

Steps complete for all networks
Click Continue. The Token Manager displays a message showing that your configuration was successful:

Success message
When everything is successfully set up for your token, you can view your new Token Page from the Token Manager Dashboard. It displays information about your CCT, enables configuration changes, and allows expansion to additional networks where you can deploy the token.

Add an existing token
If you have existing token(s) that you've already deployed, you can use the Token Manager to create and configure a token pool for the token, and optionally deploy your token on additional networks. Note that tokens deployed to additional networks are automatically configured to use the Burn and Mint mechanism.

On the Details page, enter the details for your token on each network where it has already been deployed. As you add each token contract address, the Token Manager displays validation checks for the token and the required admin registration functions in the contract.

Use the + Add New Address link to add additional token deployments. When you've added all the token deployments that you want to add at this time, select the checkbox to confirm These are all of the tokens I currently want to enable on CCIP.

On the Pools page, you're prompted to select the token pool mechanism that's used to transfer value between networks  Burn / Mint or Lock / Release. Depending on your token contract, you may have more than one option for Burn / Mint:

Selecting token pool types
Before selecting a token pool type, be sure to review CCIP token handling mechanisms.

On the Networks page, select the additional blockchain networks where you'd like to deploy your new token. For additional networks, Token Manager Wizard workflow automatically configures all tokens with the Burn & Mint mechanism. (Refer to the token contract and token pool contract for the Burn & Mint mechanism.)

On the Summary page, each network you've selected appears along with an expandable list of the transactions the Token Manager will guide you through to deploy your token for each network.

If you selected more than two networks during the previous step, the Remove links are active, allowing you to remove a network before proceeding. If you only have two networks selected, the Remove links are intentionally not active. If you need to add more networks, navigate back to the Networks page.

The Deploy page displays the steps that you need to complete.

For the tokens you're adding, the Token Manager guides you through each of these steps per network:

Deploy token pool for existing token
Grant Burn / Mint privileges (manual step)
Register admin
Accept admin role of your token pool
Set the token pool address
Accept ownership of the new token pool
caution
Manually granting Burn/Mint privileges

Unlike the other steps where you're simply prompted to confirm transactions in your wallet, the Token Manager prompts you to grant Burn/Mint privileges manually, and then confirm that you've done so before proceeding with further steps. It's crucial to complete this manual step to ensure your CCIP transactions will work properly. Review the CCT requirements to understand the requirements your token must fulfill.

For the other tokens in your network, the Token Manager also guides you through updating existing token pools to incorporate the tokens you're adding.

At each step, you are prompted to confirm the corresponding transactions in your wallet. When each step is complete for all the networks you selected, the Token Manager displays a message showing that your configuration was successful.

When everything is successfully set up for your token, you can view your new Token Page from the Token Manager Dashboard. It displays information about your CCT, enables configuration changes, and allows expansion to additional networks.

Token Manager Dashboard
After you connect your wallet, you can see the Token Manager Dashboard:

Token dashboard
If you click Add new token, you enter the Token Manager Wizard which prompts you to deploy a new token or to add an existing token.
If the wallet you connected to the dashboard is a Token Admin address, the Token Manager automatically populates your tokens in the dashboard.
If you have saved partial progress in the Token Manager Wizard, your token displays in a draft state so you can return and finish deploying it later.
After you have deployed a new token or added an existing one, each token has its own page:

Token page
The token page shows both the configured and unconfigured networks.

When you select any of the listed unconfigured networks, you can use the Token Manager Wizard to expand your token to those networks, either by deploying a new token or by adding an existing token and deploying a token pool.
For configured networks, you can view details for each network-specific token, and you can expand a Token Details side panel with more information and admin actions. To expand the Token Details panel, click the View link next to the configured network.
When expanded, the Token Details side panel provides more details about the inbound and outbound lanes for your token. If the connected wallet is a token admin or has permissions to update the token pool, the Token Details side panel also displays an Actions menu:

Token details actions menu
If you have the appropriate permissions, you can edit your token's inbound and outbound rate limits, edit the router contract address, and propose a new token administrator.

Managing token settings
Connect your wallet and select your token in the Token Manager home page. A detailed page for your token displays, showing both configured and unconfigured networks.

To access the Settings page, select the gear icon next to your token's name:

Token settings icon
Verifying your token
You can request token verification through the Token Manager; when verification is granted, it allows the token to be listed on the CCIP Directory and ensures information is consistent across other CCIP apps, like CCIP Explorer.

caution
caution

CCIP allows users to register and manage tokens in a permissionless manner. A 'Verified' status of a token indicates only that the Token Creator has signed transactions evidencing their ownership. Users should conduct their own research before engaging with any tokens.

If your token is unverified, an Unverified badge displays underneath the token's name at the top of the page. Be sure that all information is correct before your submission, as it requires a manual review process. If you need to make any further changes after submitting your request, you must use the CCIP Contact Form.

You can send a request for verification from the Settings page:

Token settings page
The Token Details tab allows you to modify your token's name and ticker symbol with an off-chain transaction. You can also specify an avatar for your token. If you have made any changes in this tab, click Save Changes.
The Project Details tab prompts you to fill in your project's name and URL, and a contact email address. This information is kept private. It's optional to fill out, but required if you're requesting token verification.
The Verification tab has a Verify my token button that submits a verification request with the information you provided in the previous two tabs.
When your verification request is granted, the Token Manager will display a Verified badge on the token page.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



The CCIP JavaScript SDK is a tool that helps you to simplify management of cross-chain token transfers, and to integrate CCIP with the frontend of your own app.

The CCIP JavaScript SDK includes two packages:

ccip-js: A TypeScript library that provides a client for managing cross-chain token transfers that use CCIP routers. This package allows you to manage the steps you need to prepare before sending a CCIP message, as well as checking the transfer status afterward.
ccip-react-components: A set of prebuilt ready-to-use UI components built on top of ccip-js. This package includes the following features:
Customize injected wallet providers (MetaMask and Coinbase Wallet)
Specify preselected chains and tokens that will display as defaults when the component loads
Customize the UI theme
Configure allowlists and deny lists for which chains can be used, and which chains can be used as a sources or destinations for cross-chain transfers
Using both packages together, you can add a fully featured CCIP bridge to your app that can be styled to match your app design.

You can also use the ccip-js package on its own  for example, to build a backend application. The features of the CCIP-JS package include:

Token approvals: Approve tokens for cross-chain transfers.
Allowance checks: Retrieve the allowance for token transfers.
Rate limits: Get rate refill limits for lanes.
Fee calculation: Calculate the fee required for transfers.
Token transfers: Transfer tokens across chains.
Transfer status: Retrieve the status of a transfer by transaction hash.
Install and run the SDK
caution
Security Warning: Handle Error Messages with Care

Important: Error messages generated by this SDK are not escaped. If your application uses user inputs that may end up in error messages, it is your responsibility to escape or sanitize these messages before displaying them to users.

Failure to escape or sanitize error messages could expose your application to Cross-Site Scripting (XSS) vulnerabilities, especially when user-generated content is included in error handling logic.

Install pnpm.

Clone the ccip-javascript-sdk repo and navigate to the root directory of the ccip-javascript-sdk project:

copy to clipboard
git clone https://github.com/smartcontractkit/ccip-javascript-sdk.git && cd ccip-javascript-sdk
From the project root, run one of the following commands to install the SDK:

Install SDK and run example appInstall SDK only
copy to clipboard
pnpm install
pnpm build
pnpm dev-example
pnpm dev-example runs an example NextJS app locally. Navigate to http://localhost:3000 in your browser.
Run an example app
The example Next.js app included with the CCIP JavaScript SDK demonstrates the SDK's functionalities within an interactive web application, allowing you to see its features in action.

To get started:

Launch the app by using the following commands:

copy to clipboard
pnpm build
pnpm dev-example
In your browser, navigate to http://localhost:3000/ to see the interactive app:

CCIP JavaScript SDK example app
Review a basic UI example
This basic UI example shows a basic token list configuration with CCIP-BnM and CCIP-LnM test tokens, and it lists the testnets you want to use with each one. This example also includes a basic frontend configuration.

Review the reference documentation:

Listing tokens in tokensList
Configuring the frontend components in Config
Configuring a theme for frontend styling
Review the basic UI example below:

copy to clipboard
import 'ccip-react-components/dist/style.css';
import { CCIPWidget, Config, Token } from 'ccip-react-components';
import { sepolia, optimismSepolia } from 'viem/chains';

const tokensList: Token[] = [
  {
    symbol: 'CCIP-BnM',
    address: {
        [arbitrumSepolia.id]:'0xA8C0c11bf64AF62CDCA6f93D3769B88BdD7cb93D',
        [avalancheFuji.id]: '0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4',
        [baseSepolia.id]: '0x88A2d74F47a237a62e7A51cdDa67270CE381555e',
        [bscTestnet.id]: '0xbFA2ACd33ED6EEc0ed3Cc06bF1ac38d22b36B9e9',
        [optimismSepolia.id]: '0x8aF4204e30565DF93352fE8E1De78925F6664dA7',
        [polygonAmoy.id]: '0xcab0EF91Bee323d1A617c0a027eE753aFd6997E4',
        [sepolia.id]: '0xFd57b4ddBf88a4e07fF4e34C487b99af2Fe82a05'
    },
    logoURL: 'https://smartcontract.imgix.net/tokens/ccip-bnm.webp?auto=compress%2Cformat',
    tags: ['chainlink', 'default']
  },
  {
    symbol: 'CCIP-LnM',
    address: {
      [optimismSepolia.id]: '0x044a6B4b561af69D2319A2f4be5Ec327a6975D0a',
      [sepolia.id]: '0x466D489b6d36E7E3b824ef491C225F5830E81cC1'
    },
    logoURL: 'https://smartcontract.imgix.net/tokens/ccip-lnm.webp?auto=compress%2Cformat',
    tags: ['chainlink', 'default']
  }
];

const config: Config = {
    theme: {
        pallette: {
            background: '#FFFFFF',
            border: '#B3B7C0',
            text: '#000000',
        }
        shape: {
            radius: 6
        },
    }
};

<CCIPWidget config={config} tokensList={tokensList} />;
Theme configuration
You can customize the component's theme to be in line with your app design. These are all the options available for theme configuration:

copy to clipboard
import { Config } from 'ccip-react-components';
const config: Config = { theme:
    {
    /** Define the app colors in HEX format */
    palette?: {
      /** Titles color and primary button background, default #000000 */
      primary?: string;
      /** Background color, default '#FFFFFF' */
      background?: string;
      /** Border color, default '#B3B7C0' */
      border?: string;
      /** Text color, default '#000000' */
      text?: string;
      /** Secondary text, inactive and placeholders color, default '#6D7480' */
      muted?: string;
      /** Input fields background color, default '#FFFFFF' */
      input?: string;
      /** Popovers, dropdowns and select fields background color, default '#F5F7FA' */
      popover?: string;
      /** Selected field from a dropdown background color, default '#D7DBE0' */
      selected?: string;
      /** Warning text color, default '#F7B955' */
      warning?: string;
      /** Warning text background color, default '#FFF5E0' */
      warningBackground?: string;
    };
    shape?: {
      /** Border radius size in px default 6 */
      radius?: number;
    };
  };}
Review a CCIP-JS example
This example uses the ccip-js package and covers the following steps:

Initialize CCIP-JS Client for mainnet
Approve tokens for transfer
Get fee for the transfer
Send the transfer through CCIP using one of the following options for fee payment:
Using the native token fee
Using the provided supported token for fee payment
Review the reference documentation for ccip-js.

Review the code
copy to clipboard
import * as CCIP from "@chainlink/ccip-js"
import { createWalletClient, custom } from "viem"
import { mainnet } from "viem/chains"

// Initialize CCIP-JS Client for mainnet
const ccipClient = CCIP.createClient()
const publicClient = createPublicClient({
  chain: mainnet,
  transport: http(),
})
const walletClient = createWalletClient({
  chain: mainnet,
  transport: custom(window.ethereum!),
})

// Approve Router to transfer tokens on user's behalf
const { txHash, txReceipt } = await ccipClient.approveRouter({
  client: walletClient,
  routerAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
  tokenAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
  amount: 1000000000000000000n,
  waitForReceipt: true,
})

console.log(`Transfer approved. Transaction hash: ${txHash}. Transaction receipt: ${txReceipt}`)

// Get fee for the transfer
const fee = await ccipClient.getFee({
  client: publicClient,
  routerAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
  tokenAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
  amount: 1000000000000000000n,
  destinationAccount: "0x1234567890abcdef1234567890abcdef12345678",
  destinationChainSelector: "1234",
})

console.log(`Fee: ${fee.toLocaleString()}`)

// Variant 1: Transfer via CCIP using native token fee
const { txHash, messageId } = await client.transferTokens({
  client: walletClient,
  routerAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
  tokenAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
  amount: 1000000000000000000n,
  destinationAccount: "0x1234567890abcdef1234567890abcdef12345678",
  destinationChainSelector: "1234",
})

console.log(`Transfer success. Transaction hash: ${txHash}. Message ID: ${messageId}`)

// Variant 2: Transfer via CCIP using the provided supported token for fee payment
const { txHash, messageId } = await client.transferTokens({
  client: walletClient,
  routerAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
  tokenAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
  amount: 1000000000000000000n,
  destinationAccount: "0x1234567890abcdef1234567890abcdef12345678",
  destinationChainSelector: "1234",
  feeTokenAddress: "0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef",
})
Build packages
Optionally, if you need to modify the packages and use your modified version, follow these instructions to build the packages:

You can use pnpm build to build both packages together. If you're building each package individually, make sure to build the build-ccip-js package before you build the ccip-react-components package. The React components depend on the JS package.

Build the build-ccip-js package:
copy to clipboard
pnpm i -w
pnpm build-ccip-js
Build the ccip-react-components package:
copy to clipboard
pnpm build-components
Update the ccip-react-components package to use the local ccip-js version by modifying the packages/ccip-react-components/package.json file. Replace the @chainlink/ccip-js dependency with the workspace reference:
copy to clipboard
"@chainlink/ccip-js": "workspace:*"
Update the examples/nextjs app to use both local ccip-js and ccip-react-components versions by modifying the examples/nextjs/package.json file. Replace the @chainlink/ccip-js and @chainlink/ccip-react-components dependencies with these relative paths:
copy to clipboard
"@chainlink/ccip-js": "link:../../packages/ccip-js",
"@chainlink/ccip-react-components": "link:../../packages/ccip-react-components",
caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.


These tutorials focus on direct interaction between Externally Owned Accounts (EOAs) and the CCIP Router.

Tutorials
Transfer Tokens between EOAs: Learn how to transfer tokens between Externally Owned Accounts (EOAs) across different blockchains, using Chainlink CCIP.
Checking CCIP Message Status Off-Chain: Learn how to verify the status of Chainlink CCIP messages offchain using JavaScript.


In this tutorial, you will use Chainlink CCIP to transfer tokens directly from your EOA (Externally Owned Account) to an account on a different blockchain. First, you will pay for CCIP fees on the source blockchain using LINK. Then, you will run the same example paying for CCIP fees in native gas, such as ETH on Ethereum or AVAX on Avalanche.

caution
Transferring tokens

This tutorial uses the term "transferring tokens" even though the tokens are not technically transferred. Instead, they are locked or burned on the source chain and then unlocked or minted on the destination chain. Read the Token Pools section to understand the various mechanisms that are used to transfer value across chains.

Before you begin
Install Node.js 18. Optionally, you can use the nvm package to switch between Node.js versions with nvm use 18.

copy to clipboard
node -v
copy to clipboard
$ node -v
v18.7.0
Your EOA (Externally Owned Account) must have both AVAX and LINK tokens on Avalanche Fuji to pay for the gas fees and CCIP fees.

Configure MetaMask to use LINK tokens
Acquire testnet AVAX and LINK from faucets.chain.link/fuji
Check the CCIP Directory to confirm that the tokens you will transfer are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.

Learn how to acquire CCIP test tokens. After following this guide, your EOA (Externally Owned Account) should have CCIP-BnM tokens, and CCIP-BnM should appear in the list of your tokens in MetaMask.

In a terminal, clone the smart-contract-examples repository and change to the smart-contract-examples/ccip/offchain/javascript directory.

copy to clipboard
git clone https://github.com/smartcontractkit/smart-contract-examples.git && \
cd smart-contract-examples/ccip/offchain/javascript
Run npm install to install the dependencies.

copy to clipboard
npm install
For higher security, the examples repository imports @chainlink/env-enc. Use this tool to encrypt your environment variables at rest.

Set an encryption password for your environment variables.

copy to clipboard
npx env-enc set-pw
Run npx env-enc set to configure a .env.enc file with the basic variables that you need to send your requests to Ethereum Sepolia.

AVALANCHE_FUJI_RPC_URL: Set a URL for the Avalanche Fuji testnet. You can sign up for a personal endpoint from Alchemy, Infura, or another node provider service.

ETHEREUM_SEPOLIA_RPC_URL: Set a URL for the Ethereum Sepolia testnet. You can sign up for a personal endpoint from Alchemy, Infura, or another node provider service.

PRIVATE_KEY: Find the private key for your testnet wallet. If you use MetaMask, follow the instructions to Export a Private Key.Note: The offchain script uses your private key to sign any transactions you make such as transferring tokens.

copy to clipboard
npx env-enc set
Tutorial
Transfer tokens and pay in LINK
In this example, you will transfer CCIP-BnM tokens from your EOA on Avalanche Fuji to an account on Ethereum Sepolia. The destination account could be an EOA (Externally Owned Account) or a smart contract. The example shows how to transfer CCIP-BnM tokens, but you can reuse the same example to transfer other tokens as long as they are supported for your lane.

For this example, CCIP fees are paid in LINK tokens. To learn how to pay CCIP fees in native AVAX, read the Pay in native section. To see a detailed description of the example code, read the code explanation section.

To transfer tokens and pay in LINK, use the following command:

copy to clipboard
node src/transfer-tokens.js sourceChain destinationChain destinationAccount tokenAddress amount feeTokenAddress
The feeTokenAddress parameter specifies the token address for paying CCIP fees. The supported tokens for paying fees include LINK, the native gas token of the source blockchain (ETH for Ethereum), and the wrapped native gas token (WETH for Ethereum).

Complete the following steps in your terminal:

Send 1,000,000,000,000,000 (0.001 CCIP-BnM ) from your EOA on Avalanche Fuji to another account on Ethereum Sepolia:

copy to clipboard
node src/transfer-tokens.js avalancheFuji ethereumSepolia YOUR_ACCOUNT 0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 1000000000000000 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Command arguments:

Argument	Explanation
node src/transfer-tokens.js
Copy to clipboard
Node.js will execute the JavaScript code inside the transfer-tokens.js file.
avalancheFuji
Copy to clipboard
This specifies the source blockchain, in this case, Avalanche Fuji.
ethereumSepolia
Copy to clipboard
This specifies the destination blockchain, which is Ethereum Sepolia in this case.
YOUR_ACCOUNT	This is the account address on the destination blockchain. You can replace this with your account address.
0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4
Copy to clipboard
This is the CCIP-BnM token contract address on Avalanche Fuji. The contract addresses for each network can be found on the CCIP Directory.
1000000000000000
Copy to clipboard
This is the amount of CCIP-BnM tokens to be transferred. In this example, 0.001 CCIP-BnM are transferred.
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Copy to clipboard
Since you will pay for CCIP fees in LINK, this is the LINK token contract address on Avalanche Fuji. The LINK contract address can be found on the Link Token contracts page.
Once you execute the command, you should see the following logs:

copy to clipboard
$ node src/transfer-tokens.js avalancheFuji ethereumSepolia 0x83dC44a4C00DFf69d0A0c7c94B20b53a4933BE0A  0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 1000000000000000 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Estimated fees (LINK): 0.020020889739492

Approving router 0xF694E193200268f9a4868e4Aa017A0118C9a8177 to spend 1000000000000000 of token 0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4

Approval done. Transaction: 0x103c20b95183380aa7c04edd0cc8b5cd6137f0b36eda931bdd23e66fd0d21251

Approving router 0xF694E193200268f9a4868e4Aa017A0118C9a8177 to spend fees 20020889739492000 of feeToken 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846

Approval done. Transaction: 0x1b6737bbf12f1ba0391ae9ba38c46c72a1118f4d20767c4c67729cf3acc0ae8b

Calling the router to send 1000000000000000 of token 0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 to account 0x83dC44a4C00DFf69d0A0c7c94B20b53a4933BE0A on destination chain ethereumSepolia using CCIP


 1000000000000000 of Tokens(0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4) Sent to account 0x83dC44a4C00DFf69d0A0c7c94B20b53a4933BE0A on destination chain ethereumSepolia using CCIP. Transaction hash 0x96b5b645f4f442131fc9466ff459e2211d408058be4d9a72a8fb057ca0f4723f -  Message id is 0x64be9f0e67af707d6203184adf30e86b3f0edd024c868ee0f2c57992d69609fd

Wait for message 0x64be9f0e67af707d6203184adf30e86b3f0edd024c868ee0f2c57992d69609fd to be executed on the destination chain - Check the explorer https://ccip.chain.link/msg/0x64be9f0e67af707d6203184adf30e86b3f0edd024c868ee0f2c57992d69609fd
...
Analyze the logs:

The script communicates with the router to calculate the transaction fees required to transfer tokens, which amounts to 20,020,889,739,492,000 Juels (equivalent to 0.02 LINK).
The script engages with the Link token contract, authorizing the router contract to spend 20,020,889,739,492,000 Juels for the fees and 1000000000000000 (0.001 CCIP-BnM) from your Externally Owned Account (EOA) balance.
The script initiates a transaction through the router to transfer 1000000000000000 (0.001 CCIP-BnM) to your account on Ethereum Sepolia. It also returns the CCIP message ID.
The script continuously monitors the destination blockchain (Ethereum Sepolia) to track the progress and completion of the cross-chain transaction.
While the script is waiting for the cross-chain transaction to proceed, open the CCIP explorer and search your cross-chain transaction using the message ID. Notice that the status is not finalized yet.

After several minutes (the waiting time depends on the finality of the source blockchain), the script will complete the polling process, and the following logs will be displayed:

copy to clipboard
Message 0x64be9f0e67af707d6203184adf30e86b3f0edd024c868ee0f2c57992d69609fd has not been processed yet on the destination chain.Try again in 60sec - Check the explorer https://ccip.chain.link/msg/0x64be9f0e67af707d6203184adf30e86b3f0edd024c868ee0f2c57992d69609fd

Status of message 0x64be9f0e67af707d6203184adf30e86b3f0edd024c868ee0f2c57992d69609fd is SUCCESS - Check the explorer https://ccip.chain.link/msg/0x64be9f0e67af707d6203184adf30e86b3f0edd024c868ee0f2c57992d69609fd
Open the CCIP explorer and use the message ID to find your cross-chain transaction.

Chainlink CCIP Explorer transaction details
The data field is empty because only tokens are transferred. The gas limit is set to 0 because the transaction is directed to an Externally Owned Account (EOA). With an empty data field, no function calls on a smart contract are expected on the destination chain.

Transfer tokens and pay in native
In this example, you will transfer CCIP-BnM tokens from your EOA on Avalanche Fuji to an account on Ethereum Sepolia. The destination account could be an EOA (Externally Owned Account) or a smart contract. The example shows how to transfer LINK tokens, but you can reuse the same example to transfer other tokens as long as they are supported for your lane.

For this example, CCIP fees are paid in Sepolia's native ETH. To learn how to pay CCIP fees in LINK, read the Pay in LINK section. To see a detailed description of the example code, read the code explanation section.

To transfer tokens and pay in native, use the following command:

copy to clipboard
node src/transfer-tokens.js sourceChain destinationChain destinationAccount tokenAddress amount
Complete the following steps in your terminal:

Send 1,000,000,000,000,000 (0.001 CCIP-BnM ) from your EOA on Avalanche Fuji to another account on Ethereum Sepolia:

copy to clipboard
node src/transfer-tokens.js avalancheFuji ethereumSepolia YOUR_ACCOUNT 0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 1000000000000000
Command arguments:

Argument	Explanation
node src/transfer-tokens.js
Copy to clipboard
Node.js will execute the JavaScript code inside the transfer-tokens.js file.
avalancheFuji
Copy to clipboard
This specifies the source blockchain, in this case, Avalanche Fuji.
ethereumSepolia
Copy to clipboard
This specifies the destination blockchain, which is Ethereum Sepolia in this case.
YOUR_ACCOUNT	This is the account address on the destination blockchain. Replace this with your account address.
0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4
Copy to clipboard
This is the CCIP-BnM token contract address on Avalanche Fuji. The contract addresses for each network can be found on the CCIP Directory.
1000000000000000
Copy to clipboard
This is the amount of CCIP-BnM tokens to be transferred. In this example, 0.001 CCIP-BnM are transferred.
After you execute the command, you should see the following logs:

copy to clipboard
$ node src/transfer-tokens.js avalancheFuji ethereumSepolia 0x83dC44a4C00DFf69d0A0c7c94B20b53a4933BE0A  0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 1000000000000000
Estimated fees (native): 80139264929946666

Approving router 0xF694E193200268f9a4868e4Aa017A0118C9a8177 to spend 1000000000000000 of token 0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4

Approval done. Transaction: 0x23fd23e7df77ef6619ed108f507e85108e5e8592bc754a85b1264f8cf15e3221

Calling the router to send 1000000000000000 of token 0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4 to account 0x83dC44a4C00DFf69d0A0c7c94B20b53a4933BE0A on destination chain ethereumSepolia using CCIP


 1000000000000000 of Tokens(0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4) Sent to account 0x83dC44a4C00DFf69d0A0c7c94B20b53a4933BE0A on destination chain ethereumSepolia using CCIP. Transaction hash 0xe4b2226a55a6eb27f5e5ecf497af932578bbdc1009f412a8b7a855a5dbd00ffa -  Message id is 0x137481a149a892f9b555d9f0c934b67fd85354af0292b82eff2f0eafd8686b9d

Wait for message 0x137481a149a892f9b555d9f0c934b67fd85354af0292b82eff2f0eafd8686b9d to be executed on the destination chain - Check the explorer https://ccip.chain.link/msg/0x137481a149a892f9b555d9f0c934b67fd85354af0292b82eff2f0eafd8686b9d
...
Analyze the logs:

The script communicates with the router to calculate the transaction fees required to transfer tokens, which amounts to 80,139,264,929,946,666 wei (equivalent to 0.08 AVAX).
The script interacts with the CCIP-BnM token contract, authorizing the router contract to deduct 0.001 CCIP-BnM from your Externally Owned Account (EOA) balance.
The script initiates a transaction through the router to transfer 0.001 CCIP-BnM tokens to your destination account on Ethereum Sepolia. It also returns the CCIP message ID.
The script continuously monitors the destination blockchain (Ethereum Sepolia) to track the progress and completion of the cross-chain transaction.
The transaction time depends on the finality of the source blockchain. After several minutes, the script will complete the polling process and the following logs will be displayed:

copy to clipboard
    Message 0x137481a149a892f9b555d9f0c934b67fd85354af0292b82eff2f0eafd8686b9d is not processed yet on destination chain.Try again in 60sec - Check the explorer https://ccip.chain.link/msg/0x137481a149a892f9b555d9f0c934b67fd85354af0292b82eff2f0eafd8686b9d

    Status of message 0x137481a149a892f9b555d9f0c934b67fd85354af0292b82eff2f0eafd8686b9d is SUCCESS - Check the explorer https://ccip.chain.link/msg/0x137481a149a892f9b555d9f0c934b67fd85354af0292b82eff2f0eafd8686b9d
Open the CCIP explorer and use the message ID to find your cross-chain transaction.

Chainlink CCIP Explorer transaction details
The data field is empty because only tokens are transferred. The gas limit is set to 0 because the transaction is directed to an Externally Owned Account (EOA), so no function calls are expected on the destination chain.

Code explanation
The Javascript featured in this tutorial is designed to interact with CCIP to transfer tokens. The contract code includes several code comments to clarify each step, but this section explains the key elements.

Imports
The script starts by importing the necessary modules and data. It imports ethers.js and ABIs (Application Binary Interface) from a config file for different contracts and configurations.

Handling arguments
The handleArguments function validates and parses the command line arguments passed to the script.

Main function: transferTokens
This asynchronous function, transferTokens performs the token transfer.

Initialization
The script initializes ethers providers to communicate with the blockchains in this section. It parses source and destination router addresses and blockchain selectors. A signer is created to sign transactions.

Token validity check
The script fetches a list of supported tokens for the destination chain and checks if the token you want to transfer is supported.

Building the CCIP message
A Cross-Chain Interoperability Protocol (CCIP) message is built, which will be sent to the router contract. It includes the destination account, amount, token address, and additional parameters.

Fee calculation
The script calls the router to estimate the fees for transferring tokens.

Transferring tokens
This section handles the actual transferring of tokens. It covers three cases:

Fees paid using the native gas token: The contract makes one approval for the transfer amount. The fees are included in the value transaction field.
Fees paid using an asset different from the native gas token and the token being transferred: The contracts makes two approvals. The first approval is for the transfer amount and the second approval is for the fees.
Fees paid using the same asset that is being transferred, but not the native gas token: The contract makes a single approval for the sum of the transfer amount and fees.
The script waits for the transaction to be validated and stores the transaction receipt.

Fetching message ID
The router's ccipSend function returns a message ID. The script simulates a call to the blockchain to fetch the message ID that the router returned.

Checking the status on the destination chain
The script polls the off-ramp contracts on the destination chain to wait for the message to be executed. If the message is executed, it returns the status. Otherwise, the message times out after 40 minutes.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



In this tutorial, you will learn how to verify the status of a Chainlink CCIP transaction offchain using JavaScript. Starting with a CCIP message ID, you'll execute the script to query the current status of a cross-chain message.

Before you begin
Initiate a CCIP transaction and note the CCIP message ID. You can obtain the CCIP message ID by running any of the previous CCIP tutorials.
Complete the prerequisite steps of the Transfer Tokens between EOAs tutorial.
Tutorial
This tutorial shows you on how to check the status of a Chainlink CCIP transaction using the get-status.js script. By supplying the script with the source, destination chains, and your CCIP message ID, you can verify the current status of your cross-chain message.

Execute the script in your command line:

copy to clipboard
node src/get-status.js sourceChain destinationChain messageID
The script requires the following parameters:

sourceChain is the identifier for the source blockchain. For example, avalancheFuji.
destinationChain is the identifier for the destination blockchain. For example, ethereumSepolia.
messageID is the unique identifier for the CCIP transaction message that you need to check.
Example Usage:

If you initiated a transaction from the Avalanche Fuji testnet to the Ethereum Sepolia testnet and received a message ID, you can check the status of this message with the following command:

copy to clipboard
$ node src/get-status.js avalancheFuji ethereumSepolia 0x25d18c6adfc1f99514b40f9931a14ca08228cdbabfc5226c1e6a43ce7441595d

Status of message 0x25d18c6adfc1f99514b40f9931a14ca08228cdbabfc5226c1e6a43ce7441595d on offRamp 0x000b26f604eAadC3D874a4404bde6D64a97d95ca is SUCCESS
Code Explanation
The JavaScript get-status.js is designed to check the status of a user-provided CCIP message. The contract code includes several code comments to clarify each step, but this section explains the key elements.

Imports
The script imports the required modules and data:

Ethers.js: JavaScript library for interacting with the Ethereum Blockchain and its ecosystem.
Router and OffRamp Contract ABIs: These Application Binary Interfaces (ABIs) enable the script to interact with specific smart contracts on the blockchain.
Configuration Functions: Includes getProviderRpcUrl for retrieving the RPC URL of a blockchain, getRouterConfig for accessing the router smart contract's configuration, and getMessageStatus for translating numeric status codes into readable strings.
Understanding the getMessageStatus function
Before diving into the script execution, it's crucial to understand how the getMessageStatus function works. This function is designed to translate the numeric status codes returned by Solidity enums into human-readable statuses so they are clear to developers and users. The function uses a mapping defined in messageState.json, which correlates to the MessageExecutionState enum used by the Chainlink CCIP's OffRamp contract.

Handling Arguments
The handleArguments function ensures the script operates with the correct parameters. It validates the presence of three command-line arguments  the source chain identifier, the destination chain identifier, and the message ID.

Main Function: getStatus
The script's core is encapsulated in the getStatus asynchronous function. This function completes initialization, configuration retrieval, and contract instantiation.

Initialization
Firstly, it establishes connections to the source and destination blockchain networks using the JsonRpcProvider.

Configuration Retrieval
The script then retrieves the configuration for router contracts on both the source and destination chains. This includes the router addresses and chain selectors.

Contract Instantiation
The script instantiates the source and destination router contracts using ethers and the router contract addresses.

Status Query
To query the status of the provided CCIP message ID, the script completes the following steps:

Check if the source chain's router supports the destination chain
Fetch OffRamp contracts associated with the destination router
Filter these contracts to find those that match the source chain
Query each matching OffRamp contract for an event related to the message ID
If an event is found, the script reads the status from the arguments. It translates the numeric status into a human-readable status and logs this information.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



This tutorial guides you through the process of enabling two tokens for cross-chain transfers. Upon completion, the system will allow users to transfer tokens seamlessly between selected blockchains.

Expected Outcomes

Two Tokens: Deploy and configure one token on each blockchain
Registration: Register the tokens in CCIP on both blockchains
Two Token Pools: Deploy and set up the necessary token pools to enable cross-chain transfers
Tutorial Structure
This interactive tutorial provides a structured learning experience:

Progress Tracking
Visual Dashboard: A navigation panel tracks progress
Clear Checkpoints: Automatic marking of completed steps
Address Management: System tracking of deployed contracts
Guided Flow: Logically sequenced steps
Success Guidelines
 Complete steps sequentially - each step builds on previous work
 Maintain a record of contract addresses for reference
 Mark your progress using the provided checkboxes
 Input contract addresses as prompted

Tools Needed
note
Development Environment

No additional development environment or installations needed - everything runs directly in your browser!

Web Browser
Any modern web browser

Remix IDE
Remix IDE - Browser-based Ethereum IDE for smart contract development and deployment

MetaMask
MetaMask - Blockchain wallet for connecting to blockchains and signing transactions

Before You Begin
Prerequisites
Complete these steps before starting the tutorial
1. Web Browser Setup
Configure your browser with the required extensions and networks


Web Browser Setup

Using Chainlist (Recommended)
Visit Chainlist
Search for your desired blockchains
Click "Add to MetaMask" for each blockchain
Open Chainlist

Manual Configuration
Open MetaMask Settings
Select Networks
Add Network manually
View Guide

2. Native Gas Tokens
Acquire tokens for transaction fees


Native Gas Tokens Ready

Blockchain Setup
Choose the source and destination blockchains for your cross-chain token
Select Your Blockchains
Choose the source and destination blockchains for your cross-chain token



Testnet


Mainnet

Select Source


Select Destination

Contract Setup
Import and compile the required smart contracts
Import Required Contracts
Import and compile the token contracts in Remix IDE


Contracts Imported
Open the pre-configured token contract in Remix:
Open in Remix
What is Remix?
Wait a few seconds for Remix to automatically compile all contracts.
Tutorial
Source Blockchain Setup
Deploy Token Contract
Configure and deploy your token using Remix IDE
Ensure MetaMask is connected to loading...
note
Already Have a Token?
If you have an existing token that meets the CCT requirements:
Skip the "Deploy Token" section
Enter your existing token address in the address field below
Continue with "Claim and Accept Admin Role"
The tutorial will use your provided token address for subsequent steps.

Configure Remix
Open the "Deploy & Run Transactions" tab
Set Environment to "Injected Provider - MetaMask"
Select BurnMintERC20 contract
Set Parameters
Configure your token by setting these required parameters in Remix:

note
About the Parameters
The name and symbol help identify your token in wallets and applications.
Using 18 decimals is standard for most ERC20 tokens (1 token = 1000000000000000000 wei or 1018).
If maxSupply is set to 0, it allows unlimited minting. For a limited supply, you must scale the amount according to the number of decimals. For example, if you want a max supply of 1,000 tokens with 18 decimals, the maxSupply would be1000 * 1018 = 1000000000000000000000 (that's 1 followed by 21 zeros).
name
string
The full name of your token that users will see

"My Cross Chain Token"
Copy to clipboard
symbol
string
A short ticker symbol for your token (usually 3-4 letters)

"MCCT"
Copy to clipboard
decimals
uint8
Number of decimal places your token will support (18 is standard)

18
Copy to clipboard
maxSupply
uint256
The maximum amount of tokens that can ever exist (0 means unlimited)

0
Copy to clipboard
preMint
uint256
The amount of tokens to be minted to the owner at the time of deployment

0
Copy to clipboard
Deploy Contract
Click "Deploy" and confirm in MetaMask
Copy your token address from "Deployed Contracts"
Enter deployed token address
Verify Contract (Optional)
note
Why Verify Your Contract?
Contract verification makes your token contract's source code public on the blockchain explorer. This:
Builds trust by allowing anyone to audit your code
Enables direct interaction through the blockchain explorer
Helps other developers understand and integrate with your contract
Access the Blockchain Explorer
Blockchain explorer information will be available once you select a network.
Verify Using Remix IDE
Remix IDE Guide
Official guide for verifying contracts using the Remix IDE verification plugin

View Guide

Chainlink Tutorial
Step-by-step tutorial for contract verification on blockchain explorers

View Tutorial

Confirm Verification
Return to your contract on the blockchain explorer
Look for a green checkmark  or "Verified" status
You should now see your contract's source code in the "Code" tab
Contract verification link will be available once you select a network.
Claim and Accept Admin Role
Configure your EOA as CCIP administrator of your token
Ensure MetaMask is connected to loading...
Register as Admin

Admin Role Claimed
note
Admin Registration Options
The Cross-Chain Token (CCT) standard supports multiple methods for registering as a token administrator. We use registerAdminViaGetCCIPAdmin() in this tutorial because our deployed BurnMintERC20 token implements the getCCIPAdmin() function. For other token implementations, you might use different registration methods. See the self-service registration documentation for all available options.
In the "Deploy & Run Transactions" tab, select the RegistryModuleOwnerCustom contract
Click "At Address" with:
Contract:
RegistryModuleOwnerCustom
[Select source blockchain first]
The RegistryModuleOwnerCustom will be displayed in the "Deployed Contracts" section
Click on the RegistryModuleOwnerCustom contract address to open the contract details
Call registerAdminViaGetCCIPAdmin:
registerAdminViaGetCCIPAdmin
Register yourself as the CCIP administrator for your token
 You must be the CCIP token administrator (i.e., the default CCIP admin) to call this function
Parameters:
token
address
The token contract you want to administer

Your deployed token address
Copy to clipboard
Confirm the transaction in MetaMask
Accept Admin Role

Admin Role Accepted
In the "Deploy & Run Transactions" tab, select TokenAdminRegistry contract
Click "At Address" with:
Contract:
TokenAdminRegistry
[Select source blockchain first]
The TokenAdminRegistry will be displayed in the "Deployed Contracts" section
Click on the TokenAdminRegistry contract address to open the contract details
Call acceptAdminRole:
acceptAdminRole
Accept your role as CCIP administrator for your token
 Must be called after registerAdminViaGetCCIPAdmin is confirmed
Parameters:
token
address
The token contract to accept administrator role for

Your deployed token address
Copy to clipboard
Confirm the transaction in MetaMask
Deploy Token Pool
Choose your pool type and deploy using Remix IDE
Ensure MetaMask is connected to loading...
Choose Pool Type
note
Understanding Pool Types
Each pool type serves different use cases and has specific requirements. Learn more about pool types and their characteristics in the token pools documentation.
Select the appropriate pool type based on your token's characteristics and requirements

Burn & Mint Pool
BurnMintTokenPool
Standard mechanism for cross-chain transfers. Tokens are burned on one chain and minted on another, maintaining constant total supply.

 Use this for new tokens or tokens with burn/mint capability

Lock & Release Pool
LockReleaseTokenPool
Suitable for tokens that already exist on this blockchain and can't be burned. Tokens are locked here and "wrapped" versions are minted on other chains.

 Deploy this on the blockchain where your token originally exists
Configure Remix
Open the "Deploy & Run Transactions" tab
Set Environment to "Injected Provider - MetaMask"
Select BurnMintTokenPool contract
Set Parameters
Configure your pool by setting these required parameters in Remix:

token
address
Address of the token to be minted/burned

Copy to clipboard
localTokenDecimals
uint8
Number of decimals for your token

18
Copy to clipboard
allowlist
address[]
Addresses allowed to transfer tokens (empty array for no restrictions)

[]
Copy to clipboard
rmnProxy
address
Address of the RMN contract

[Select source blockchain first]
router
address
Address of the CCIP Router contract

[Select source blockchain first]
Deploy Contract
Click "Deploy" and confirm in MetaMask
Copy your pool address from "Deployed Contracts"
Enter deployed pool address
Verify Contract (Optional)
note
Why Verify Your Contract?
Contract verification makes your pool contract's source code public on the blockchain explorer. This:
Builds trust by allowing anyone to audit your code
Enables direct interaction through the blockchain explorer
Helps other developers understand and integrate with your contract
Access the Blockchain Explorer
Blockchain explorer information will be available once you select a network.
Verify Using Remix IDE
Remix IDE Guide
Official guide for verifying contracts using the Remix IDE verification plugin

View Guide

Chainlink Tutorial
Step-by-step tutorial for contract verification on blockchain explorers

View Tutorial

Confirm Verification
Return to your contract on the blockchain explorer
Look for a green checkmark  or "Verified" status
You should now see your contract's source code in the "Code" tab
Contract verification link will be available once you select a network.
Configure Token Registry
Register your token pool in the CCIP registry
Ensure MetaMask is connected to loading...
Configure Registry

Pool Registered
In the "Deploy & Run Transactions" tab, select the TokenAdminRegistry contract in the Contracts drop-down list.
Next to the At Address button, fill in the following contract address, and then click the At Address button.
Contract:
TokenAdminRegistry
[Select source blockchain first]
Select the TokenAdminRegistry contract to expand its details
Call setPool:
setPool
Enable your token for CCIP by registering its token pool
 You must be the token admin to call this function
Parameters:
localToken
address
The token to enable for CCIP

Copy to clipboard
pool
address
The token pool that will handle cross-chain transfers

Copy to clipboard
Confirm the transaction in MetaMask
Destination Blockchain Setup
Deploy Token Contract
Configure and deploy your token using Remix IDE
Ensure MetaMask is connected to loading...
note
Already Have a Token?
If you have an existing token that meets the CCT requirements:
Skip the "Deploy Token" section
Enter your existing token address in the address field below
Continue with "Claim and Accept Admin Role"
The tutorial will use your provided token address for subsequent steps.

Configure Remix
Open the "Deploy & Run Transactions" tab
Set Environment to "Injected Provider - MetaMask"
Select BurnMintERC20 contract
Set Parameters
Configure your token by setting these required parameters in Remix:

note
About the Parameters
The name and symbol help identify your token in wallets and applications.
Using 18 decimals is standard for most ERC20 tokens (1 token = 1000000000000000000 wei or 1018).
If maxSupply is set to 0, it allows unlimited minting. For a limited supply, you must scale the amount according to the number of decimals. For example, if you want a max supply of 1,000 tokens with 18 decimals, the maxSupply would be1000 * 1018 = 1000000000000000000000 (that's 1 followed by 21 zeros).
name
string
The full name of your token that users will see

"My Cross Chain Token"
Copy to clipboard
symbol
string
A short ticker symbol for your token (usually 3-4 letters)

"MCCT"
Copy to clipboard
decimals
uint8
Number of decimal places your token will support (18 is standard)

18
Copy to clipboard
maxSupply
uint256
The maximum amount of tokens that can ever exist (0 means unlimited)

0
Copy to clipboard
preMint
uint256
The amount of tokens to be minted to the owner at the time of deployment

0
Copy to clipboard
Deploy Contract
Click "Deploy" and confirm in MetaMask
Copy your token address from "Deployed Contracts"
Enter deployed token address
Verify Contract (Optional)
note
Why Verify Your Contract?
Contract verification makes your token contract's source code public on the blockchain explorer. This:
Builds trust by allowing anyone to audit your code
Enables direct interaction through the blockchain explorer
Helps other developers understand and integrate with your contract
Access the Blockchain Explorer
Blockchain explorer information will be available once you select a network.
Verify Using Remix IDE
Remix IDE Guide
Official guide for verifying contracts using the Remix IDE verification plugin

View Guide

Chainlink Tutorial
Step-by-step tutorial for contract verification on blockchain explorers

View Tutorial

Confirm Verification
Return to your contract on the blockchain explorer
Look for a green checkmark  or "Verified" status
You should now see your contract's source code in the "Code" tab
Contract verification link will be available once you select a network.
Claim and Accept Admin Role
Configure your EOA as CCIP administrator of your token
Ensure MetaMask is connected to loading...
Register as Admin

Admin Role Claimed
note
Admin Registration Options
The Cross-Chain Token (CCT) standard supports multiple methods for registering as a token administrator. We use registerAdminViaGetCCIPAdmin() in this tutorial because our deployed BurnMintERC20 token implements the getCCIPAdmin() function. For other token implementations, you might use different registration methods. See the self-service registration documentation for all available options.
In the "Deploy & Run Transactions" tab, select the RegistryModuleOwnerCustom contract
Click "At Address" with:
Contract:
RegistryModuleOwnerCustom
[Select destination blockchain first]
The RegistryModuleOwnerCustom will be displayed in the "Deployed Contracts" section
Click on the RegistryModuleOwnerCustom contract address to open the contract details
Call registerAdminViaGetCCIPAdmin:
registerAdminViaGetCCIPAdmin
Register yourself as the CCIP administrator for your token
 You must be the CCIP token administrator (i.e., the default CCIP admin) to call this function
Parameters:
token
address
The token contract you want to administer

Your deployed token address
Copy to clipboard
Confirm the transaction in MetaMask
Accept Admin Role

Admin Role Accepted
In the "Deploy & Run Transactions" tab, select TokenAdminRegistry contract
Click "At Address" with:
Contract:
TokenAdminRegistry
[Select destination blockchain first]
The TokenAdminRegistry will be displayed in the "Deployed Contracts" section
Click on the TokenAdminRegistry contract address to open the contract details
Call acceptAdminRole:
acceptAdminRole
Accept your role as CCIP administrator for your token
 Must be called after registerAdminViaGetCCIPAdmin is confirmed
Parameters:
token
address
The token contract to accept administrator role for

Your deployed token address
Copy to clipboard
Confirm the transaction in MetaMask
Deploy Token Pool
Choose your pool type and deploy using Remix IDE
Ensure MetaMask is connected to loading...
Choose Pool Type
note
Understanding Pool Types
Each pool type serves different use cases and has specific requirements. Learn more about pool types and their characteristics in the token pools documentation.
Select the appropriate pool type based on your token's characteristics and requirements

Burn & Mint Pool
BurnMintTokenPool
Standard mechanism for cross-chain transfers. Tokens are burned on one chain and minted on another, maintaining constant total supply.

 Use this for new tokens or tokens with burn/mint capability

Lock & Release Pool
LockReleaseTokenPool
Suitable for tokens that already exist on this blockchain and can't be burned. Tokens are locked here and "wrapped" versions are minted on other chains.

 Deploy this on the blockchain where your token originally exists
Configure Remix
Open the "Deploy & Run Transactions" tab
Set Environment to "Injected Provider - MetaMask"
Select BurnMintTokenPool contract
Set Parameters
Configure your pool by setting these required parameters in Remix:

token
address
Address of the token to be minted/burned

Copy to clipboard
localTokenDecimals
uint8
Number of decimals for your token

18
Copy to clipboard
allowlist
address[]
Addresses allowed to transfer tokens (empty array for no restrictions)

[]
Copy to clipboard
rmnProxy
address
Address of the RMN contract

[Select destination blockchain first]
router
address
Address of the CCIP Router contract

[Select destination blockchain first]
Deploy Contract
Click "Deploy" and confirm in MetaMask
Copy your pool address from "Deployed Contracts"
Enter deployed pool address
Verify Contract (Optional)
note
Why Verify Your Contract?
Contract verification makes your pool contract's source code public on the blockchain explorer. This:
Builds trust by allowing anyone to audit your code
Enables direct interaction through the blockchain explorer
Helps other developers understand and integrate with your contract
Access the Blockchain Explorer
Blockchain explorer information will be available once you select a network.
Verify Using Remix IDE
Remix IDE Guide
Official guide for verifying contracts using the Remix IDE verification plugin

View Guide

Chainlink Tutorial
Step-by-step tutorial for contract verification on blockchain explorers

View Tutorial

Confirm Verification
Return to your contract on the blockchain explorer
Look for a green checkmark  or "Verified" status
You should now see your contract's source code in the "Code" tab
Contract verification link will be available once you select a network.
Configure Token Registry
Register your token pool in the CCIP registry
Ensure MetaMask is connected to loading...
Configure Registry

Pool Registered
In the "Deploy & Run Transactions" tab, select the TokenAdminRegistry contract in the Contracts drop-down list.
Next to the At Address button, fill in the following contract address, and then click the At Address button.
Contract:
TokenAdminRegistry
[Select destination blockchain first]
Select the TokenAdminRegistry contract to expand its details
Call setPool:
setPool
Enable your token for CCIP by registering its token pool
 You must be the token admin to call this function
Parameters:
localToken
address
The token to enable for CCIP

Copy to clipboard
pool
address
The token pool that will handle cross-chain transfers

Copy to clipboard
Confirm the transaction in MetaMask
Configure Cross-Chain Communication
Source Chain Configuration
Grant Burn and Mint Privileges
Grant required privileges to your token pool
Ensure MetaMask is connected to loading...
Grant Burn and Mint Privileges

Grant Burn and Mint Privileges
note
Optional Step
Skip this section if you deployed a LockReleaseTokenPool
In the list of deployed contracts, select the BurnMintERC20 at 
Copy to clipboard
Click to open the contract details
Call grantMintAndBurnRoles:
grantMintAndBurnRoles
Grant mint and burn privileges to your token pool for cross-chain transfers
 You must be the token contract owner to call this function
Parameters:
burnAndMinter
address
Address to grant mint and burn roles to (your token pool)

Copy to clipboard
Confirm the transaction in MetaMask
Configure Pool
Set up cross-chain communication parameters
Ensure MetaMask is connected to loading...
Configure Pool

Configure Pool
 Please select valid blockchains first
 Please deploy your token pool before proceeding

Current Chain Prerequisites
Select valid blockchains for the transfer
Deploy your token pool on the current chain
Verify Configuration
Confirm your cross-chain setup is correct
Ensure MetaMask is connected to loading...
Verify Configuration

Verify Configuration
Open the "Deploy & Run Transactions" tab in Remix
Select your token pool contract:
LockReleaseTokenPool at 
Copy to clipboard
Click the contract to view its functions
Verify Remote Token
Call getRemoteToken:
getRemoteToken
Retrieves the ABI-encoded address of your token on the remote chain
Parameters:
remoteChainSelector
uint64
Chain selector for undefined

Returns:
bytes
ABI-encoded address of the token on the remote chain
Expected Result:
Waiting for remote token address...
Verify Remote Pools
Call getRemotePools:
getRemotePools
Returns all registered token pools on the remote chain
Parameters:
remoteChainSelector
uint64
Chain selector for undefined

Returns:
bytes[]
Array of ABI-encoded addresses of all registered pools on the remote chain
Expected Result:
Waiting for remote pool address...
Verify Rate Limiters
Call getCurrentInboundRateLimiterState:
getCurrentInboundRateLimiterState
Verifies your inbound transfer rate limits
Parameters:
remoteChainSelector
uint64
Chain selector for undefined

Returns:
TokenBucket
Current state of the inbound rate limiter
Expected Result:
Tokens
0
Last Updated
Current block timestamp
Status
false
Capacity
0
Rate
0
note
NOTE
The tokens field starts at 0 and the lastUpdated field will show the current block timestamp.
Call getCurrentOutboundRateLimiterState:
getCurrentOutboundRateLimiterState
Verifies your outbound transfer rate limits
Parameters:
remoteChainSelector
uint64
Chain selector for undefined

Returns:
TokenBucket
Current state of the outbound rate limiter
Expected Result:
Tokens
0
Last Updated
Current block timestamp
Status
false
Capacity
0
Rate
0
note
NOTE
The tokens field starts at 0 and the lastUpdated field will show the current block timestamp.
Destination Chain Configuration
Grant Burn and Mint Privileges
Grant required privileges to your token pool
Ensure MetaMask is connected to loading...
Grant Burn and Mint Privileges

Grant Burn and Mint Privileges
note
Optional Step
Skip this section if you deployed a LockReleaseTokenPool
In the list of deployed contracts, select the BurnMintERC20 at 
Copy to clipboard
Click to open the contract details
Call grantMintAndBurnRoles:
grantMintAndBurnRoles
Grant mint and burn privileges to your token pool for cross-chain transfers
 You must be the token contract owner to call this function
Parameters:
burnAndMinter
address
Address to grant mint and burn roles to (your token pool)

Copy to clipboard
Confirm the transaction in MetaMask
Configure Pool
Set up cross-chain communication parameters
Ensure MetaMask is connected to loading...
Configure Pool

Configure Pool
 Please select valid blockchains first
 Please deploy your token pool before proceeding

Current Chain Prerequisites
Select valid blockchains for the transfer
Deploy your token pool on the current chain
Verify Configuration
Confirm your cross-chain setup is correct
Ensure MetaMask is connected to loading...
Verify Configuration

Verify Configuration
Open the "Deploy & Run Transactions" tab in Remix
Select your token pool contract:
LockReleaseTokenPool at 
Copy to clipboard
Click the contract to view its functions
Verify Remote Token
Call getRemoteToken:
getRemoteToken
Retrieves the ABI-encoded address of your token on the remote chain
Parameters:
remoteChainSelector
uint64
Chain selector for undefined

Returns:
bytes
ABI-encoded address of the token on the remote chain
Expected Result:
Waiting for remote token address...
Verify Remote Pools
Call getRemotePools:
getRemotePools
Returns all registered token pools on the remote chain
Parameters:
remoteChainSelector
uint64
Chain selector for undefined

Returns:
bytes[]
Array of ABI-encoded addresses of all registered pools on the remote chain
Expected Result:
Waiting for remote pool address...
Verify Rate Limiters
Call getCurrentInboundRateLimiterState:
getCurrentInboundRateLimiterState
Verifies your inbound transfer rate limits
Parameters:
remoteChainSelector
uint64
Chain selector for undefined

Returns:
TokenBucket
Current state of the inbound rate limiter
Expected Result:
Tokens
0
Last Updated
Current block timestamp
Status
false
Capacity
0
Rate
0
note
NOTE
The tokens field starts at 0 and the lastUpdated field will show the current block timestamp.
Call getCurrentOutboundRateLimiterState:
getCurrentOutboundRateLimiterState
Verifies your outbound transfer rate limits
Parameters:
remoteChainSelector
uint64
Chain selector for undefined

Returns:
TokenBucket
Current state of the outbound rate limiter
Expected Result:
Tokens
0
Last Updated
Current block timestamp
Status
false
Capacity
0
Rate
0
note
NOTE
The tokens field starts at 0 and the lastUpdated field will show the current block timestamp.
caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



Guide Versions
This guide is available in multiple versions. Choose the one that matches your needs.



Hardhat (Burn & Mint)
This tutorial will guide you through the process of enabling your own tokens in CCIP using Hardhat. You will learn how to deploy tokens and set up Burn & Mint token pools. After that, you will register them in CCIP and configure them without needing manual intervention. Finally, you will test the Burn & Mint token handling mechanism, where tokens are burned on the source blockchain and an equivalent amount is minted on the destination blockchain.

We will cover the following key steps:

Deploying Tokens: You will deploy your BurnMintERC20 tokens on the Avalanche Fuji and Arbitrum Sepolia testnets.

Deploying Token Pools: Once your tokens are deployed, you will deploy BurnMintTokenPool token pools on Avalanche Fuji and Arbitrum Sepolia. These pools are essential for minting and burning tokens during cross-chain transfers. Each token will be linked to a pool, which will manage token transfers and ensure proper handling of assets across chains.

Claiming Mint and Burn Roles: You will claim the mint and burn roles for the token pools, allowing your token pools to control how tokens are minted and burned during cross-chain transfers.

Claiming and Accepting the Admin Role: This is a two-step process:

You will call the RegistryModuleOwnerCustom contract's registerAdminViaOwner function to register your EOA as the token admin. This role is required to enable your token in CCIP.

Once claimed, you will call the TokenAdminRegistry contract's acceptAdminRole function to complete the registration process.

Linking Tokens to Pools: You will call the TokenAdminRegistry contract's setPool function to associate each token with its respective token pool.

Configuring Token Pools: You will call the applyChainUpdates function on your token pools to configure each pool by setting cross-chain transfer parameters, such as token pool rate limits and enabled destination chains.

Minting Tokens: You will call the mint function to mint tokens on Avalanche Fuji for your EOA. These tokens will later be used to test cross-chain transfers to Arbitrum Sepolia.

Transferring Tokens: Finally, you will transfer tokens from Avalanche Fuji to Arbitrum Sepolia using CCIP. You will have the option to pay CCIP fees in either LINK tokens or native gas tokens.

By the end of this tutorial, you will have successfully deployed, registered, configured, and enabled your tokens and token pools for use in CCIP.

Before You Begin
Make sure you have Node.js v18 or above installed. If not, install Node.js v18:
Download Node.js 18 if you don't have it installed. Optionally, you can use the nvm package to switch between Node.js versions:

copy to clipboard
nvm use 18
Verify that the correct version of Node.js is installed:

copy to clipboard
node -v
Example output:

copy to clipboard
$ node -v
v18.7.0
Clone the repository and navigate to the project directory:

copy to clipboard
git clone https://github.com/smartcontractkit/smart-contract-examples.git
cd smart-contract-examples/ccip/cct/hardhat
Install dependencies for the project:

copy to clipboard
npm install
Compile the project:

copy to clipboard
npm run compile
Encrypt your environment variables for higher security:
The project uses @chainlink/env-enc to encrypt your environment variables at rest. Follow the steps below to configure your environment securely:

Set an encryption password for your environment variables:

copy to clipboard
npx env-enc set-pw
Set up a .env.enc file with the necessary variables for Avalanche Fuji and Arbitrum Sepolia. Use the following command to add the variables:

copy to clipboard
npx env-enc set
Variables to configure:

AVALANCHE_FUJI_RPC_URL: A URL for the Avalanche Fuji testnet. You can get a personal endpoint from services like Alchemy or Infura.
ARBITRUM_SEPOLIA_RPC_URL: A URL for the Arbitrum Sepolia testnet. You can sign up for a personal endpoint from Alchemy or Infura.
PRIVATE_KEY: The private key for your testnet wallet. If you use MetaMask, you can follow this guide to export your private key. Note: This key is required for signing transactions like token transfers.
ETHERSCAN_API_KEY: An API key from Etherscan to verify your contracts. You can obtain one from Etherscan.
ARBISCAN_API_KEY: An Arbitrum explorer API key, used to verify your contract. Follow this guide to get one from Arbiscan.
Fund your EOA with LINK and native gas tokens:
Make sure your EOA has enough LINK and native gas tokens on Avalanche Fuji to cover transaction fees. You can use the Chainlink faucets to get testnet tokens.

Tutorial
note
Explore the Code

All Hardhat tasks used in this tutorial are located in the tasks/ directory of the repository. Each task is thoroughly commented and directly linked to a key step in the tutorial, making the code self-explanatory. Read the code and comments to gain a deeper understanding of the process or explore the implementation details.

Deploy Tokens
In this step, you will use the deployToken.ts task to deploy tokens on two testnets, Avalanche Fuji and Arbitrum Sepolia. Below is an explanation of the parameters used during deployment:

Parameter	Description	Default	Required
name	The name of the token. This is the full name by which the token will be identified.	N/A	Yes
symbol	The symbol of the token. This is the shorthand (usually 3-5 letters) representing the token.	N/A	Yes
decimals	The number of decimals the token will use. For instance, 18 decimals means 1 token is represented as 1e18 smallest units.	18	No
maxsupply	The maximum supply of tokens. Use 0 for unlimited supply.	0	No
premint	The amount of tokens to be minted to the owner at the time of deployment. If set to 0, no tokens will be minted to the owner during deployment.	0	No
verifycontract	Whether to verify the contract on Etherscan or a similar blockchain explorer.	false	No
network	The blockchain on which the token will be deployed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Deploy tokens, use the following commands, substituting the token name and symbol as needed:

Deploy the token on Avalanche Fuji:

copy to clipboard
npx hardhat deployToken --name "BnM aem" --symbol BnMaem --decimals 18 --maxsupply 0 --premint 100000000000000000000 --verifycontract true --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T00:36:53.652Z info: Deploying BurnMintERC20 contract to avalancheFuji
2025-05-15T00:36:53.653Z info: Waiting 2 blocks for transaction 0xe1db85d7f7a1d0afb3da14cb0b426316b9944d2e594200bde6f4bdc8574789a5 to be confirmed...
2025-05-15T00:36:54.657Z info: Token deployed to: 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef
2025-05-15T00:36:54.817Z info: Granting mint and burn roles to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T00:37:00.993Z info: Verifying contract...
The contract 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://testnet.snowtrace.io/address/0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef#code

2025-05-15T00:37:02.350Z info: Token contract deployed and verified
Deploy the token on Arbitrum Sepolia:

copy to clipboard
npx hardhat deployToken --name "BnM aem" --symbol BnMaem --decimals 18 --maxsupply 0 --premint 100000000000000000000 --verifycontract true --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T00:40:39.000Z info: Deploying BurnMintERC20 contract to arbitrumSepolia
2025-05-15T00:40:39.001Z info: Waiting 2 blocks for transaction 0xae7b73371e0c0054587c6e50c0a835a4b5ce2cab173e0803f8ac9c56f986fc3b to be confirmed...
2025-05-15T00:40:39.575Z info: Token deployed to: 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213
2025-05-15T00:40:39.790Z info: Granting mint and burn roles to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T00:40:43.010Z info: Verifying contract...
The contract 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://sepolia.arbiscan.io/address/0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213#code

2025-05-15T00:40:44.163Z info: Token contract deployed and verified
Deploy Token Pools
caution
Understand Token Pool Requirements

Before deploying your token pools, make sure you understand the mandatory requirements for token pools and the gas limit restrictions. The releaseOrMint function and other operations (e.g., balance checks) must not exceed the 90,000 gas limit on the destination blockchain. Failure to meet these requirements can lead to manual execution. For more details, refer to the Common Requirements.

In this step, you will use the deployTokenPool task to deploy token pools for the tokens on both testnets, Avalanche Fuji and Arbitrum Sepolia. Below is an explanation of the parameters used during deployment:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which the pool is being created.	N/A	Yes
pooltype	The type of pool to deploy. For this tutorial, we use "burnMint" for a pool that supports burning and minting of tokens.	"burnMint"	No
localtokendecimals	The number of decimals for the token on this chain.	18	No
network	The blockchain on which the token pool will be deployed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
verifycontract	Whether to verify the contract on Etherscan or a similar blockchain explorer.	false	No
note
Token Decimal Handling

If you need to handle tokens with different decimals across blockchains, refer to the Token Decimal Handling section.

Deploy token pools using the following commands, replacing the token address with the one you deployed in the previous step:

Deploy the burn and mint token pool on Avalanche Fuji:

copy to clipboard
npx hardhat deployTokenPool \
  --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef \
  --pooltype burnMint \
  --localtokendecimals 18 \
  --verifycontract true \
  --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T00:44:46.294Z info: Waiting 2 blocks for transaction 0x339c04b48a4870f49efe593e149fb954df8fd05dddb56463dcf08f99ccab166e to be confirmed...
2025-05-15T00:44:46.979Z info: Token pool deployed to: 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047
2025-05-15T00:44:46.980Z info: Granting mint and burn roles to 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 on token 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef
2025-05-15T00:44:56.086Z info: Verifying contract...
The contract 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://testnet.snowtrace.io/address/0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047#code

2025-05-15T00:44:57.878Z info: Token pool contract deployed and verified
Deploy the burn and mint token pool on Arbitrum Sepolia:

copy to clipboard
npx hardhat deployTokenPool \
  --tokenaddress 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 \
  --pooltype burnMint \
  --localtokendecimals 18 \
  --verifycontract true \
  --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T00:47:04.761Z info: Waiting 2 blocks for transaction 0x6ec7377c986464a2993d0bdb94bb236ee9da90582a403eeaec02805ead8fecf9 to be confirmed...
2025-05-15T00:47:05.082Z info: Token pool deployed to: 0x74F0842a9A55575e8e36692c356292a812640F67
2025-05-15T00:47:05.082Z info: Granting mint and burn roles to 0x74F0842a9A55575e8e36692c356292a812640F67 on token 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213
2025-05-15T00:47:08.849Z info: Verifying contract...
The contract 0x74F0842a9A55575e8e36692c356292a812640F67 has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://sepolia.arbiscan.io/address/0x74F0842a9A55575e8e36692c356292a812640F67#code

2025-05-15T00:47:10.082Z info: Token pool contract deployed and verified
Claim Admin
In this step, you will use the claimAdmin.ts task to register your EOA as the administrator for the deployed tokens on both testnets, Avalanche Fuji and Arbitrum Sepolia. This process involves calling the RegistryModuleOwnerCustom contract, which will fetch the CCIP admin of the token and set it up as the admin in the registry.

Below is an explanation of the parameters used during the admin claim process:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which the admin role is being claimed.	N/A	Yes
network	The blockchain on which the claim admin process will be executed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Claim the admin role by using the following commands, replacing the token address with the one you deployed in the previous steps:

Claim the admin role on Avalanche Fuji:

copy to clipboard
npx hardhat claimAdmin --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T00:50:43.739Z info: Current token admin: 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T00:50:43.741Z info: Claiming admin of 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef via getCCIPAdmin() for CCIP admin 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T00:50:50.443Z info: Claimed admin of 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef tx: 0x6ee656f97a2dbef9da398076d5b618ab89820735460b9c371c506e74ae5bd1a9
Claim the admin role on Arbitrum Sepolia:

copy to clipboard
npx hardhat claimAdmin --tokenaddress 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T00:53:32.278Z info: Current token admin: 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T00:53:32.279Z info: Claiming admin of 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 via getCCIPAdmin() for CCIP admin 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T00:53:35.791Z info: Claimed admin of 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 tx: 0x8e2f76e833f4d77095a75af0ad99b0872a76acd7397f5e11f9af4785d494a83a
Accept Admin Role
In this step, you will use the acceptAdminRole.ts task to accept the admin role for the deployed tokens on both testnets, Avalanche Fuji and Arbitrum Sepolia. Once you have claimed the role, accepting the role finalizes your control over the token administration.

Below is an explanation of the parameters used during the admin role acceptance process:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which the admin role is being accepted.	N/A	Yes
network	The blockchain on which the accept admin process will be executed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Accept the admin role by using the following commands, replacing the token address with the one deployed in the previous steps:

Accept the admin role on Avalanche Fuji:

copy to clipboard
npx hardhat acceptAdminRole --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T00:57:49.215Z info: Accepted admin role for token 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef tx: 0x8d52265634a13a818524c8d0ada37e1b6e97df72475e8035398ff5b62d770a5e
Accept the admin role on Arbitrum Sepolia:

copy to clipboard
npx hardhat acceptAdminRole --tokenaddress 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T00:58:53.951Z info: Accepted admin role for token 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 tx: 0x214a3012e6158c896516e553f1c72e0394e6b02e2de38be18ac98d322b7ad4b5
Set Pool
In this step, you will use the setPool.ts task to link each token with its respective token pool on both testnets.

Below is an explanation of the parameters used during the pool setting process:

Parameter	Description	Default	Required
tokenaddress	The address of the token to be linked to a pool.	N/A	Yes
pooladdress	The address of the pool associated with the token.	N/A	Yes
network	The blockchain on which the pool setting will be executed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Link each token with its respective token pool by using the following commands, replacing the token and pool addresses with the ones you deployed in the previous steps:

Set the pool for Avalanche Fuji:

copy to clipboard
npx hardhat setPool --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --pooladdress 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T01:01:22.500Z info: Setting pool for token 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 by 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T01:01:28.430Z info: Pool set for token 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047
Set the pool for Arbitrum Sepolia:

copy to clipboard
npx hardhat setPool --tokenaddress 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 --pooladdress 0x74F0842a9A55575e8e36692c356292a812640F67 --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T01:02:26.011Z info: Setting pool for token 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 to 0x74F0842a9A55575e8e36692c356292a812640F67 by 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T01:02:31.878Z info: Pool set for token 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 to 0x74F0842a9A55575e8e36692c356292a812640F67
Configure Token Pools
In this step, you will use the applyChainUpdates task to initialize the token pool configuration on each blockchain to enable cross-chain transfers between Avalanche Fuji and Arbitrum Sepolia. Below is an explanation of the parameters used:

Parameter	Description	Default	Required
pooladdress	The address of the pool to be configured.	N/A	Yes
remotechain	The remote blockchain network (e.g., arbitrumSepolia for Fuji pool, avalancheFuji for Sepolia pool).	N/A	Yes
remotepooladdresses	Comma-separated list of remote pool addresses.	N/A	Yes
remotetokenaddress	The address of the token on the remote chain.	N/A	Yes
outboundratelimitenabled	Enables or disables the outbound rate limiter.	false	No
outboundratelimitcapacity	Maximum capacity for the outbound rate limiter (in wei).	0	No
outboundratelimitrate	Refill rate for the outbound rate limiter bucket (tokens per second, in wei).	0	No
inboundratelimitenabled	Enables or disables the inbound rate limiter.	false	No
inboundratelimitcapacity	Maximum capacity for the inbound rate limiter (in wei).	0	No
inboundratelimitrate	Refill rate for the inbound rate limiter bucket (tokens per second, in wei).	0	No
Configure the pools using the following commands, replacing the pool, token, and remote pool addresses with those you deployed in the previous steps:

Configure the pool on Avalanche Fuji:

copy to clipboard
npx hardhat applyChainUpdates \
  --pooladdress 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 \
  --remotechain arbitrumSepolia \
  --remotepooladdresses 0x74F0842a9A55575e8e36692c356292a812640F67 \
  --remotetokenaddress 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213 \
  --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T01:09:34.681Z info: Applying chain update to pool at address: 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047
2025-05-15T01:09:34.681Z info: Remote chain: arbitrumSepolia (3478487238524512106)
2025-05-15T01:09:34.681Z info: Remote pool addresses: 0x74F0842a9A55575e8e36692c356292a812640F67
2025-05-15T01:09:34.681Z info: Remote token address: 0x6093e82e2E7b3f3ea4f83dA8Be8b755c4839A213
2025-05-15T01:09:46.490Z info: Chain update applied successfully
Configure the pool on Arbitrum Sepolia:

copy to clipboard
npx hardhat applyChainUpdates \
  --pooladdress 0x74F0842a9A55575e8e36692c356292a812640F67 \
  --remotechain avalancheFuji \
  --remotetokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef \
  --remotepooladdresses 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 \
  --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T01:10:29.863Z info: Applying chain update to pool at address: 0x74F0842a9A55575e8e36692c356292a812640F67
2025-05-15T01:10:29.863Z info: Remote chain: avalancheFuji (14767482510784806043)
2025-05-15T01:10:29.864Z info: Remote pool addresses: 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047
2025-05-15T01:10:29.864Z info: Remote token address: 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef
2025-05-15T01:10:33.787Z info: Chain update applied successfully
Mint Tokens
In this step, you will use the mintTokens.ts task to mint tokens on Avalanche Fuji for your Externally Owned Account (EOA). Since you assigned mint and burn privileges to your EOA when deploying the tokens in the first step, you can now mint tokens for testing purposes. This is to ensure that you have enough tokens in your EOA to perform cross-chain transfers in the next step.

You will interact with the BurnMintERC20 token contract, specifically calling the mint() function to mint tokens to your EOA.

Below is an explanation of the parameters used during the minting process:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which tokens are being minted.	N/A	Yes
amount	The amount of tokens to mint (in wei).	N/A	Yes
receiveraddress	The address of the receiver of the minted tokens. If not provided, defaults to your EOA.	N/A	No
network	The blockchain on which the minting process will be executed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Mint tokens to your EOA using the following command, replacing the token address with the one you deployed in the previous steps:

Mint tokens on Avalanche Fuji:

copy to clipboard
npx hardhat mintTokens --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --amount 1000000000000000000000 --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T01:12:37.680Z info: Minting 1000000000000000000000 of BnMaem tokens to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T01:12:45.071Z info: Minted 1000000000000000000000 of BnMaem tokens to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA - transaction hash: 0x4ce9df23352405141dae8bffdb986b218c96dcdc2041a74bb716f7999ac957d3
2025-05-15T01:12:45.763Z info: Current balance of 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA is 1100000000000000000000 BnMaem
Transfer Tokens
In this step, you will use the transferTokens task to transfer tokens from Avalanche Fuji to Arbitrum Sepolia using CCIP. You have two options for paying CCIP fees: using LINK tokens or native gas tokens.

You will interact with the IRouterClient contract, specifically calling the ccipSend() function to initiate the token transfer.

Below is an explanation of the parameters used during the token transfer process:

Parameter	Description	Default	Required
tokenaddress	The address of the token being transferred.	N/A	Yes
amount	The amount of tokens to transfer.	N/A	Yes
destinationchain	The blockchain to which the tokens will be transferred. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
receiveraddress	The address of the receiver on the destination blockchain.	N/A	Yes
fee	The type of fee used for the transfer, either LINK or native.	LINK	No
network	The blockchain on which the token transfer will be initiated. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Pay fees in LINK
Call the CCIP Router to transfer tokens from Avalanche Fuji to Arbitrum Sepolia, paying the CCIP fees in LINK tokens. Replace the token address, amount, receiver address, and blockchain with the appropriate values:

copy to clipboard
npx hardhat transferTokens --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --amount 100000000000000000000 --destinationchain arbitrumSepolia --receiveraddress 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T01:21:48.987Z info: Estimated fees: 22153771891999418
2025-05-15T01:21:48.990Z info: Approving 100000000000000000000 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T01:21:58.161Z info: Approving 22153771891999418 LINK to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T01:22:06.709Z info: Transferring 100000000000000000000 of 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf on chain arbitrumSepolia with 22153771891999418 of LINK as fees
2025-05-15T01:22:15.308Z info: Transaction hash: 0xf424379cf52b5e6927b5ae2aa2688afa2986c1cc102cf7c2354227da5cc95b18
2025-05-15T01:22:15.322Z warn: Unable to parse the event logs corresponding to the transaction 0xf424379cf52b5e6927b5ae2aa2688afa2986c1cc102cf7c2354227da5cc95b18
2025-05-15T01:22:15.322Z info: Check status of message on https://ccip.chain.link/tx/0xf424379cf52b5e6927b5ae2aa2688afa2986c1cc102cf7c2354227da5cc95b18
Pay fees in native gas tokens
Call the CCIP Router to transfer tokens from Avalanche Fuji to Arbitrum Sepolia, paying the CCIP fees in native gas tokens. Replace the token address, amount, receiver address, and blockchain with the appropriate values:

copy to clipboard
npx hardhat transferTokens --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --amount 100000000000000000000 --destinationchain arbitrumSepolia --receiveraddress 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --fee native --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T01:24:46.043Z info: Estimated fees: 15594594987586380
2025-05-15T01:24:46.047Z info: Approving 100000000000000000000 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T01:24:55.052Z info: Transferring 100000000000000000000 of 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf on chain arbitrumSepolia with 15594594987586380 of native token as fees
2025-05-15T01:25:03.348Z info: Transaction hash: 0x2f78731a6f41a55c0a2d2f03c6545812f91235c775bec82c21646131dcdcac34
2025-05-15T01:25:03.364Z warn: Unable to parse the event logs corresponding to the transaction 0x2f78731a6f41a55c0a2d2f03c6545812f91235c775bec82c21646131dcdcac34
2025-05-15T01:25:03.364Z info: Check status of message on https://ccip.chain.link/tx/0x2f78731a6f41a55c0a2d2f03c6545812f91235c775bec82c21646131dcdcac34
caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



Guide Versions
This guide is available in multiple versions. Choose the one that matches your needs.



Hardhat (Lock & Mint)
This tutorial will guide you through the process of enabling your own tokens in CCIP using Hardhat. You will learn how to deploy tokens, set up a Lock & Release token pool on the source blockchain, and a Burn & Mint token pool on the destination blockchain. After that, you will register them in CCIP and configure them without needing manual intervention. Finally, you will test the Lock & Mint token handling mechanism, where tokens are locked on the source blockchain and an equivalent amount is minted on the destination blockchain.

We will cover the following key steps:

Deploying Tokens: You will deploy your BurnMintERC20 tokens on the Avalanche Fuji and Arbitrum Sepolia testnets.

Deploying Token Pools: Once your tokens are deployed, you will deploy LockReleaseTokenPool on Avalanche Fuji and BurnMintTokenPool token pools on Arbitrum Sepolia. These pools are essential for testing the Lock & Mint token transfer mechanism: Locking the tokens on the source blockchain and then minting an equivalent amount of tokens on the destination blockchain. Each token will be linked to a pool, which will manage token transfers and ensure proper handling of assets across chains.

Claiming Mint and Burn Roles: You will claim the mint and burn roles for the destination token pool, allowing it to mint and burn tokens during cross-chain transfers.

Claiming and Accepting the Admin Role: This is a two-step process:

You will call the RegistryModuleOwnerCustom contract's registerAdminViaOwner function to register your EOA as the token admin. This role is required to enable your token in CCIP.

Once claimed, you will call the TokenAdminRegistry contract's acceptAdminRole function to complete the registration process.

Linking Tokens to Pools: You will call the TokenAdminRegistry contract's setPool function to associate each token with its respective token pool.

Configuring Token Pools: You will call the applyChainUpdates function on your token pools to configure each pool by setting cross-chain transfer parameters, such as token pool rate limits and enabled destination chains.

Minting Tokens: You will call the mint function to mint tokens on Avalanche Fuji for your EOA. These tokens will later be used to test cross-chain transfers to Arbitrum Sepolia.

Transferring Tokens: Finally, you will transfer tokens from Avalanche Fuji to Arbitrum Sepolia using CCIP. You will have the option to pay CCIP fees in either LINK tokens or native gas tokens.

By the end of this tutorial, you will have successfully deployed, registered, configured, and enabled your tokens and token pools for use in CCIP.

Before You Begin
Make sure you have Node.js v18 or above installed. If not, install Node.js v18:
Download Node.js 18 if you don't have it installed. Optionally, you can use the nvm package to switch between Node.js versions:

copy to clipboard
nvm use 18
Verify that the correct version of Node.js is installed:

copy to clipboard
node -v
Example output:

copy to clipboard
$ node -v
v18.7.0
Clone the repository and navigate to the project directory:

copy to clipboard
git clone https://github.com/smartcontractkit/smart-contract-examples.git
cd smart-contract-examples/ccip/cct/hardhat
Install dependencies for the project:

copy to clipboard
npm install
Compile the project:

copy to clipboard
npm run compile
Encrypt your environment variables for higher security:
The project uses @chainlink/env-enc to encrypt your environment variables at rest. Follow the steps below to configure your environment securely:

Set an encryption password for your environment variables:

copy to clipboard
npx env-enc set-pw
Set up a .env.enc file with the necessary variables for Avalanche Fuji and Arbitrum Sepolia. Use the following command to add the variables:

copy to clipboard
npx env-enc set
Variables to configure:

AVALANCHE_FUJI_RPC_URL: A URL for the Avalanche Fuji testnet. You can get a personal endpoint from services like Alchemy or Infura.
ARBITRUM_SEPOLIA_RPC_URL: A URL for the Arbitrum Sepolia testnet. You can sign up for a personal endpoint from Alchemy or Infura.
PRIVATE_KEY: The private key for your testnet wallet. If you use MetaMask, you can follow this guide to export your private key. Note: This key is required for signing transactions like token transfers.
ETHERSCAN_API_KEY: An API key from Etherscan to verify your contracts. You can obtain one from Etherscan.
ARBISCAN_API_KEY: An API key from Arbiscan to verify your contracts on Arbitrum. See this guide to get one from Arbiscan.
Fund your EOA with LINK and native gas tokens:
Make sure your EOA has enough LINK and native gas tokens on Avalanche Fuji and Arbitrum Sepolia to cover transaction fees. You can use the Chainlink faucets to get testnet tokens.

Tutorial
note
Explore the Code

All Hardhat tasks used in this tutorial are located in the tasks/ directory of the repository. Each task is thoroughly commented and directly linked to a key step in the tutorial, making the code self-explanatory. Read the code and comments to gain a deeper understanding of the process or explore the implementation details.

Deploy Tokens
In this step, you will use the deployToken.ts task to deploy tokens on two testnets, Avalanche Fuji and Arbitrum Sepolia. Below is an explanation of the parameters used during deployment:

Parameter	Description	Default	Required
name	The name of the token. This is the full name by which the token will be identified.	N/A	Yes
symbol	The symbol of the token. This is the shorthand (usually 3-5 letters) representing the token.	N/A	Yes
decimals	The number of decimals the token will use. For instance, 18 decimals means 1 token is represented as 1e18 smallest units.	18	No
maxsupply	The maximum supply of tokens. Use 0 for unlimited supply.	0	No
verifycontract	Whether to verify the contract on Etherscan or a similar blockchain explorer.	false	No
network	The blockchain on which the token will be deployed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Deploy tokens, use the following commands, substituting the token name and symbol as needed:

Deploy the token on Avalanche Fuji:

copy to clipboard
npx hardhat deployToken --name "BnM aem" --symbol BnMaem --decimals 18 --maxsupply 0 --premint 100000000000000000000 --verifycontract true --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T02:37:00.663Z info: Deploying BurnMintERC20 contract to avalancheFuji
2025-05-15T02:37:00.664Z info: Waiting 2 blocks for transaction 0x11ea95f8f13f87b99b90e81b35da9268805816f0c945a0d987fe0c4c32a3042d to be confirmed...
2025-05-15T02:37:01.330Z info: Token deployed to: 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054
2025-05-15T02:37:01.881Z info: Granting mint and burn roles to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T02:37:09.923Z info: Verifying contract...
The contract 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://testnet.snowtrace.io/address/0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054#code

2025-05-15T02:37:11.266Z info: Token contract deployed and verified
Deploy the token on Arbitrum Sepolia:

copy to clipboard
npx hardhat deployToken --name "BnM aem" --symbol BnMaem --decimals 18 --maxsupply 0 --premint 100000000000000000000 --verifycontract true --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T02:38:38.539Z info: Deploying BurnMintERC20 contract to arbitrumSepolia
2025-05-15T02:38:38.540Z info: Waiting 2 blocks for transaction 0x993d5c5371fcc611a2cc4f246ebd3e58591bc49f549ff25a9880dd13e3c7848f to be confirmed...
2025-05-15T02:38:38.851Z info: Token deployed to: 0x528f08cF0b8541CdFeE5E897c861348AE601315e
2025-05-15T02:38:39.014Z info: Granting mint and burn roles to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T02:38:42.435Z info: Verifying contract...
The contract 0x528f08cF0b8541CdFeE5E897c861348AE601315e has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://sepolia.arbiscan.io/address/0x528f08cF0b8541CdFeE5E897c861348AE601315e#code

2025-05-15T02:38:43.668Z info: Token contract deployed and verified
Deploy Token Pools
caution
Understand Token Pool Requirements

Before deploying your token pools, make sure you understand the mandatory requirements for token pools and the gas limit restrictions. The releaseOrMint function and other operations (e.g., balance checks) must not exceed the 90,000 gas limit on the destination blockchain. Failure to meet these requirements can lead to manual execution. For more details, refer to the Common Requirements.

In this step, you will use the deployTokenPool task to deploy token pools for the tokens on both testnets, Avalanche Fuji and Arbitrum Sepolia. Below is an explanation of the parameters used during deployment:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which the pool is being created.	N/A	Yes
pooltype	The type of pool to deploy. For this tutorial, we use "lockRelease" on Fuji and "burnMint" on Arbitrum Sepolia.	"burnMint"	No
localtokendecimals	The number of decimals for the token on this chain.	18	No
acceptliquidity	Whether the pool should accept liquidity. Only applicable for lockRelease pools.	false	No
network	The blockchain on which the token pool will be deployed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
verifycontract	Whether to verify the contract on Etherscan or a similar blockchain explorer.	false	No
note
Token Decimal Handling

If you need to handle tokens with different decimals across blockchains, refer to the Token Decimal Handling section.

Deploy token pools using the following commands, replacing the token address with the one you deployed in the previous step:

Deploy the lock and release token pool on Avalanche Fuji:

copy to clipboard
npx hardhat deployTokenPool \
  --tokenaddress 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 \
  --pooltype lockRelease \
  --localtokendecimals 18 \
  --acceptliquidity false \
  --verifycontract true \
  --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T02:41:28.385Z info: Waiting 2 blocks for transaction 0x8d5a04279c14dbabf0b7ee4f1821b9c789ce87c53c75f436cd046cd019e200ed to be confirmed...
2025-05-15T02:41:29.449Z info: Token pool deployed to: 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F
2025-05-15T02:41:29.449Z info: Verifying contract...
Successfully submitted source code for contract
@chainlink/contracts-ccip/contracts/pools/LockReleaseTokenPool.sol:LockReleaseTokenPool at 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F
for verification on the block explorer. Waiting for verification result...

Successfully verified contract LockReleaseTokenPool on the block explorer.
https://testnet.snowtrace.io/address/0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F#code

2025-05-15T02:42:12.868Z info: Token pool contract deployed and verified
Deploy the burn and mint token pool on Arbitrum Sepolia:

copy to clipboard
npx hardhat deployTokenPool \
  --tokenaddress 0x528f08cF0b8541CdFeE5E897c861348AE601315e \
  --pooltype burnMint \
  --localtokendecimals 18 \
  --verifycontract true \
  --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T02:44:04.693Z info: Waiting 2 blocks for transaction 0xdcb0485b605e4cf3a95fab8aa5355c891bc6715d5dd37211e4f4145e89277d6b to be confirmed...
2025-05-15T02:44:05.018Z info: Token pool deployed to: 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10
2025-05-15T02:44:05.019Z info: Granting mint and burn roles to 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10 on token 0x528f08cF0b8541CdFeE5E897c861348AE601315e
2025-05-15T02:44:08.667Z info: Verifying contract...
The contract 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10 has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://sepolia.arbiscan.io/address/0x85EDf5dE3417c240f8E008D6B1377403eF17BE10#code

2025-05-15T02:44:09.814Z info: Token pool contract deployed and verified
Claim Admin
In this step, you will use the claimAdmin.ts task to register your EOA as the administrator for the deployed tokens on both testnets, Avalanche Fuji and Arbitrum Sepolia. This process involves calling the RegistryModuleOwnerCustom contract, which will fetch the CCIP admin of the token and set it up as the admin in the registry.

Below is an explanation of the parameters used during the admin claim process:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which the admin role is being claimed.	N/A	Yes
network	The blockchain on which the claim admin process will be executed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Claim the admin role by using the following commands, replacing the token address with the one you deployed in the previous steps:

Claim the admin role on Avalanche Fuji:

copy to clipboard
npx hardhat claimAdmin --tokenaddress 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T07:43:26.364Z info: Current token admin: 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T07:43:26.365Z info: Claiming admin of 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 via getCCIPAdmin() for CCIP admin 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T07:43:35.471Z info: Claimed admin of 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 tx: 0x2cc45f61521f4cce83dab2c8c452ad87cc4867195f6ad2da810b6ab85f45ac8d
Claim the admin role on Arbitrum Sepolia:

copy to clipboard
npx hardhat claimAdmin --tokenaddress 0x528f08cF0b8541CdFeE5E897c861348AE601315e --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T07:46:04.941Z info: Current token admin: 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T07:46:04.942Z info: Claiming admin of 0x528f08cF0b8541CdFeE5E897c861348AE601315e via getCCIPAdmin() for CCIP admin 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T07:46:08.656Z info: Claimed admin of 0x528f08cF0b8541CdFeE5E897c861348AE601315e tx: 0x6b0a1ba03885609d51d4d53159feb5d0a65993a3276fc1b875153d7c2e1208e0
Accept Admin Role
In this step, you will use the acceptAdminRole.ts task to accept the admin role for the deployed tokens on both testnets, Avalanche Fuji and Arbitrum Sepolia. Once you have claimed the role, accepting the role finalizes your control over the token administration.

Below is an explanation of the parameters used during the admin role acceptance process:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which the admin role is being accepted.	N/A	Yes
network	The blockchain on which the accept admin process will be executed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Accept the admin role by using the following commands, replacing the token address with the one deployed in the previous steps:

Accept the admin role on Avalanche Fuji:

copy to clipboard
npx hardhat acceptAdminRole --tokenaddress 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T07:48:10.397Z info: Accepted admin role for token 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 tx: 0x65e6ca78912e892aa12dfd89a2f81cd16bea190ed27c2387eeb25b8825ddc871
Accept the admin role on Arbitrum Sepolia:

copy to clipboard
npx hardhat acceptAdminRole --tokenaddress 0x528f08cF0b8541CdFeE5E897c861348AE601315e --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T07:49:32.507Z info: Accepted admin role for token 0x528f08cF0b8541CdFeE5E897c861348AE601315e tx: 0x37115cd24457bd40102bff9e9e6e7725c380dfbf1dd9cbcfa7dc767757cc64c2
Set Pool
In this step, you will use the setPool.ts task to link each token with its respective token pool on both testnets.

Below is an explanation of the parameters used during the pool setting process:

Parameter	Description	Default	Required
tokenaddress	The address of the token to be linked to a pool.	N/A	Yes
pooladdress	The address of the pool associated with the token.	N/A	Yes
network	The blockchain on which the pool setting will be executed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Link each token with its respective token pool by using the following commands, replacing the token and pool addresses with the ones you deployed in the previous steps:

Set the pool for Avalanche Fuji:

copy to clipboard
npx hardhat setPool \
  --tokenaddress 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 --pooladdress 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F \
  --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T07:51:53.865Z info: Setting pool for token 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 to 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F by 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T07:52:02.833Z info: Pool set for token 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 to 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F
Set the pool for Arbitrum Sepolia:

copy to clipboard
npx hardhat setPool \
  --tokenaddress 0x528f08cF0b8541CdFeE5E897c861348AE601315e --pooladdress 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10 \
  --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T07:53:01.750Z info: Setting pool for token 0x528f08cF0b8541CdFeE5E897c861348AE601315e to 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10 by 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T07:53:06.764Z info: Pool set for token 0x528f08cF0b8541CdFeE5E897c861348AE601315e to 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10
Configure Token Pools
In this step, you will use the applyChainUpdates task to initialize the token pool configuration on each blockchain to enable cross-chain transfers between Avalanche Fuji and Arbitrum Sepolia. Below is an explanation of the parameters used:

Parameter	Description	Default	Required
pooladdress	The address of the pool to be configured.	N/A	Yes
remotechain	The remote blockchain network (e.g., arbitrumSepolia for Fuji pool, avalancheFuji for Sepolia pool).	N/A	Yes
remotepooladdresses	Comma-separated list of remote pool addresses.	N/A	Yes
remotetokenaddress	The address of the token on the remote chain.	N/A	Yes
outboundratelimitenabled	Enables or disables the outbound rate limiter.	false	No
outboundratelimitcapacity	Maximum capacity for the outbound rate limiter (in wei).	0	No
outboundratelimitrate	Refill rate for the outbound rate limiter bucket (tokens per second, in wei).	0	No
inboundratelimitenabled	Enables or disables the inbound rate limiter.	false	No
inboundratelimitcapacity	Maximum capacity for the inbound rate limiter (in wei).	0	No
inboundratelimitrate	Refill rate for the inbound rate limiter bucket (tokens per second, in wei).	0	No
Configure the pools using the following commands, replacing the pool, token, and remote pool addresses with those you deployed in the previous steps:

Configure the pool on Avalanche Fuji:

copy to clipboard
npx hardhat applyChainUpdates \
  --pooladdress 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F \
  --remotechain arbitrumSepolia \
  --remotepooladdresses 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10 \
  --remotetokenaddress 0x528f08cF0b8541CdFeE5E897c861348AE601315e \
  --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T07:56:37.082Z info: Applying chain update to pool at address: 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F
2025-05-15T07:56:37.082Z info: Remote chain: arbitrumSepolia (3478487238524512106)
2025-05-15T07:56:37.082Z info: Remote pool addresses: 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10
2025-05-15T07:56:37.082Z info: Remote token address: 0x528f08cF0b8541CdFeE5E897c861348AE601315e
2025-05-15T07:56:43.745Z info: Chain update applied successfully
Configure the pool on Arbitrum Sepolia:

copy to clipboard
npx hardhat applyChainUpdates \
  --pooladdress 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10 \
  --remotechain avalancheFuji \
  --remotepooladdresses 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F \
  --remotetokenaddress 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 \
  --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T07:57:31.979Z info: Applying chain update to pool at address: 0x85EDf5dE3417c240f8E008D6B1377403eF17BE10
2025-05-15T07:57:31.980Z info: Remote chain: avalancheFuji (14767482510784806043)
2025-05-15T07:57:31.980Z info: Remote pool addresses: 0xdA99b1551F0E69aC11FD4C36731F079Ca3131a8F
2025-05-15T07:57:31.980Z info: Remote token address: 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054
2025-05-15T07:57:36.087Z info: Chain update applied successfully
Mint Tokens
In this step, you will use the mintTokens.ts task to mint tokens on Avalanche Fuji for your Externally Owned Account (EOA). Since you assigned mint and burn privileges to your EOA when deploying the tokens in the first step, you can now mint tokens for testing purposes. This is to ensure that you have enough tokens in your EOA to perform cross-chain transfers in the next step.

You will interact with the BurnMintERC20 token contract, specifically calling the mint() function to mint tokens to your EOA.

Below is an explanation of the parameters used during the minting process:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which tokens are being minted.	N/A	Yes
amount	The amount of tokens to mint (in wei).	N/A	Yes
receiveraddress	The address of the receiver of the minted tokens. If not provided, defaults to your EOA.	N/A	No
network	The blockchain on which the minting process will be executed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Mint tokens to your EOA using the following command, replacing the token address with the one you deployed in the previous steps:

Mint tokens on Avalanche Fuji:

copy to clipboard
npx hardhat mintTokens --tokenaddress 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 --amount 1000000000000000000000 --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T07:59:50.241Z info: Minting 1000000000000000000000 of BnMaem tokens to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T07:59:59.473Z info: Minted 1000000000000000000000 of BnMaem tokens to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA - transaction hash: 0xac6ff86fe7a8a948701c2473586f73b0311ada7452bfd82ff5938dccc4f2d9cc
2025-05-15T07:59:59.808Z info: Current balance of 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA is 1100000000000000000000 BnMaem
Transfer Tokens
In this step, you will use the transferTokens task to transfer tokens from Avalanche Fuji to Arbitrum Sepolia using CCIP. You have two options for paying CCIP fees: using LINK tokens or native gas tokens.

You will interact with the IRouterClient contract, specifically calling the ccipSend() function to initiate the token transfer.

Below is an explanation of the parameters used during the token transfer process:

Parameter	Description	Default	Required
tokenaddress	The address of the token being transferred.	N/A	Yes
amount	The amount of tokens to transfer.	N/A	Yes
destinationchain	The blockchain to which the tokens will be transferred. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
receiveraddress	The address of the receiver on the destination blockchain.	N/A	Yes
fee	The type of fee used for the transfer, either LINK or native.	LINK	No
network	The blockchain on which the token transfer will be initiated. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Pay fees in LINK
Call the CCIP Router to transfer tokens from Avalanche Fuji to Arbitrum Sepolia, paying the CCIP fees in LINK tokens. Replace the token address, amount, receiver address, and blockchain with the appropriate values:

copy to clipboard
npx hardhat transferTokens --tokenaddress 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 --amount 100000000000000000000 --destinationchain arbitrumSepolia --receiveraddress 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T08:03:22.279Z info: Estimated fees: 22167517387804854
2025-05-15T08:03:22.280Z info: Approving 100000000000000000000 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T08:03:27.907Z info: Approving 22167517387804854 LINK to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T08:03:36.529Z info: Transferring 100000000000000000000 of 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 to 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf on chain arbitrumSepolia with 22167517387804854 of LINK as fees
2025-05-15T08:03:40.665Z info: Transaction hash: 0xedad6bd09fbb9d99282f3875e6abebfff739aaf01d7490ba471b9f372ff70c5e
2025-05-15T08:03:40.681Z warn: Unable to parse the event logs corresponding to the transaction 0xedad6bd09fbb9d99282f3875e6abebfff739aaf01d7490ba471b9f372ff70c5e
2025-05-15T08:03:40.681Z info: Check status of message on https://ccip.chain.link/tx/0xedad6bd09fbb9d99282f3875e6abebfff739aaf01d7490ba471b9f372ff70c5e
Pay fees in native gas tokens
Call the CCIP Router to transfer tokens from Avalanche Fuji to Arbitrum Sepolia, paying the CCIP fees in native gas tokens. Replace the token address, amount, receiver address, and blockchain with the appropriate values:

copy to clipboard
npx hardhat transferTokens --tokenaddress 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 --amount 100000000000000000000 --destinationchain arbitrumSepolia --receiveraddress 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --fee native --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T08:05:15.654Z info: Estimated fees: 15603670276848872
2025-05-15T08:05:15.659Z info: Approving 100000000000000000000 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T08:05:25.788Z info: Transferring 100000000000000000000 of 0x6cdB459EaCB30947Db2a4374a78d37A8FCe11054 to 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf on chain arbitrumSepolia with 15603670276848872 of native token as fees
2025-05-15T08:05:30.584Z info: Transaction hash: 0x892be0e1c6617d0e7bfb08dd93f88833d699470869f8b05520e9624ce8c125d8
2025-05-15T08:05:30.602Z warn: Unable to parse the event logs corresponding to the transaction 0x892be0e1c6617d0e7bfb08dd93f88833d699470869f8b05520e9624ce8c125d8
2025-05-15T08:05:30.602Z info: Check status of message on https://ccip.chain.link/tx/0x892be0e1c6617d0e7bfb08dd93f88833d699470869f8b05520e9624ce8c125d8
Your tokens have been locked on the token pool on Avalanche Fuji, the corresponding tokens have been minted on Arbitrum Sepolia and sent to your receiver address.

Note: Since your Lock & Release token pool on Avalanche Fuji has locked some tokens, you can transfer tokens from Arbitrum Sepolia to Avalanche Fuji using CCIP as an exercise. Your tokens will be burned on Arbitrum Sepolia, and the corresponding tokens will be released on Avalanche Fuji. Make sure not to transfer more tokens than the amount of tokens locked in the token pool on Avalanche Fuji.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



Guide Versions
This guide is available in multiple versions. Choose the one that matches your needs.



Hardhat
This tutorial will guide you through the process of updating the rate limiter settings for outbound and inbound transfers in your deployed token pools using Hardhat. You will first review existing rate limiter settings and then update them.

Prerequisites
Tokens and pools deployed: Ensure that you have tokens and token pools already deployed on both networks you plan to use. If not, refer to one of the following tutorials:

Register from an EOA (Burn & Mint)
Register from an EOA (Lock & Mint)
Admin access: Ensure you have the necessary privileges to call the setChainRateLimiterConfig function for your token pools.

Before You Begin
Make sure you have Node.js v18 or above installed. If not, install Node.js v18:
Download Node.js 18 if you don't have it installed. Optionally, you can use the nvm package to switch between Node.js versions:

copy to clipboard
nvm use 18
Verify that the correct version of Node.js is installed:

copy to clipboard
node -v
Example output:

copy to clipboard
$ node -v
v18.7.0
Clone the repository and navigate to the project directory:

copy to clipboard
git clone https://github.com/smartcontractkit/smart-contract-examples.git
cd smart-contract-examples/ccip/cct/hardhat
Install dependencies for the project:

copy to clipboard
npm install
Compile the project:

copy to clipboard
npm run compile
Encrypt your environment variables for higher security:
The project uses @chainlink/env-enc to encrypt your environment variables at rest. Follow the steps below to configure your environment securely:

Set an encryption password for your environment variables:

copy to clipboard
npx env-enc set-pw
Set up a .env.enc file with the necessary variables for Avalanche Fuji and Arbitrum Sepolia testnets. Use the following command to add the variables:

copy to clipboard
npx env-enc set
Variables to configure:

AVALANCHE_FUJI_RPC_URL
Copy to clipboard
: A URL for the Avalanche Fuji testnet. You can get a personal endpoint from services like Alchemy or Infura.
ARBITRUM_SEPOLIA_RPC_URL
Copy to clipboard
: A URL for the Arbitrum Sepolia testnet. You can get a personal endpoint from services like Alchemy or Infura.
PRIVATE_KEY
Copy to clipboard
: The private key for your testnet wallet. If you use MetaMask, you can follow this guide to export your private key. Note: This key is required for signing transactions like token transfers.
Fund your EOA with native gas tokens:
Make sure your EOA has enough native gas tokens on Avalanche Fuji to cover transaction fees. You can use the Chainlink faucets to get testnet tokens.

Tutorial
note
Explore the Code

All Hardhat tasks used in this tutorial are located in the tasks/ directory of the repository. Each task is thoroughly commented and directly linked to a key step in the tutorial, making the code self-explanatory. Read the code and comments to gain a deeper understanding of the process or explore the implementation details.

Review current rate limiter settings
Use the getCurrentRateLimits task to fetch the current rate limiter states for a specific chain from a token pool. This task provides detailed information about both inbound and outbound rate limits, including:

Whether rate limiting is enabled
The maximum capacity (bucket size)
The refill rate (tokens per second)
Current token amount in the bucket
Last update timestamp
Below is an explanation of the parameters used:

Parameter	Description	Default	Required
pooladdress	The address of the token pool to query.	N/A	Yes
remotechain	The remote blockchain to check rate limits for (e.g., arbitrumSepolia for Fuji pool).	N/A	Yes
network	The blockchain on which to execute the query (e.g., avalancheFuji, arbitrumSepolia).	N/A	Yes
Get rate limiter settings for the token pool on Avalanche Fuji:

copy to clipboard
npx hardhat getCurrentRateLimits \
  --pooladdress 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 \
  --remotechain arbitrumSepolia \
  --network avalancheFuji
Example output:

copy to clipboard
2025-05-15T09:03:41.140Z info:
Rate Limiter States for Chain: arbitrumSepolia
2025-05-15T09:03:41.142Z info: Pool Address: 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047
2025-05-15T09:03:41.142Z info: Chain Selector: 3478487238524512106
2025-05-15T09:03:41.142Z info:
Outbound Rate Limiter:
2025-05-15T09:03:41.142Z info:   Enabled: false
2025-05-15T09:03:41.143Z info:   Capacity: 0
2025-05-15T09:03:41.143Z info:   Rate: 0
2025-05-15T09:03:41.143Z info:   Tokens: 0
2025-05-15T09:03:41.143Z info:   Last Updated: 1747299820
2025-05-15T09:03:41.144Z info:
Inbound Rate Limiter:
2025-05-15T09:03:41.144Z info:   Enabled: false
2025-05-15T09:03:41.144Z info:   Capacity: 0
2025-05-15T09:03:41.144Z info:   Rate: 0
2025-05-15T09:03:41.144Z info:   Tokens: 0
2025-05-15T09:03:41.144Z info:   Last Updated: 1747299820
Get rate limiter settings for the token pool on Arbitrum Sepolia:

copy to clipboard
npx hardhat getCurrentRateLimits \
  --pooladdress 0x74F0842a9A55575e8e36692c356292a812640F67 \
  --remotechain avalancheFuji \
  --network arbitrumSepolia
Example output:

copy to clipboard
2025-05-15T09:07:22.079Z info:
Rate Limiter States for Chain: avalancheFuji
2025-05-15T09:07:22.080Z info: Pool Address: 0x74F0842a9A55575e8e36692c356292a812640F67
2025-05-15T09:07:22.080Z info: Chain Selector: 14767482510784806043
2025-05-15T09:07:22.080Z info:
Outbound Rate Limiter:
2025-05-15T09:07:22.080Z info:   Enabled: false
2025-05-15T09:07:22.081Z info:   Capacity: 0
2025-05-15T09:07:22.081Z info:   Rate: 0
2025-05-15T09:07:22.081Z info:   Tokens: 0
2025-05-15T09:07:22.081Z info:   Last Updated: 1747300041
2025-05-15T09:07:22.081Z info:
Inbound Rate Limiter:
2025-05-15T09:07:22.081Z info:   Enabled: false
2025-05-15T09:07:22.081Z info:   Capacity: 0
2025-05-15T09:07:22.081Z info:   Rate: 0
2025-05-15T09:07:22.081Z info:   Tokens: 0
2025-05-15T09:07:22.081Z info:   Last Updated: 1747300041
note
Rate Limiters Disabled

As you can see from both outputs above, rate limiters are currently disabled (Enabled: false) for both pools, with capacity and rate set to 0. This means there are currently no restrictions on token transfers. In the next section, you will learn how to enable and configure these rate limiters to control token flow between chains.

Update rate limiter settings
Use the updateRateLimiters task to update the rate limiter configurations for an existing chain connection in your token pool. This task specifically interacts with the setChainRateLimiterConfig function of the TokenPool contract, allowing you to adjust the rate limits without altering other configurations like remote pool addresses.

The updateRateLimiters task allows you to:

Enable or disable rate limiting for outbound or inbound transfers or both.
Set the capacity and rate for the rate limiters, controlling the flow of tokens.
Target a specific remote chain, updating rate limits for that chain only.
Below is an explanation of the parameters used during the rate limiter update process:

Parameter	Description	Default	Required
pooladdress	The address of the token pool being configured.	N/A	Yes
remotechain	The remote blockchain to which this pool is linked. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
ratelimiter	Specifies which rate limiters to update: inbound, outbound, or both.	both	No
outboundratelimitenabled	A flag indicating whether to enable outbound rate limits for cross-chain transfers (true or false).	false	No
outboundratelimitcapacity	The maximum number of tokens allowed in the bucket for outbound transfers (in wei). Note: Applicable if outbound rate limits are enabled.	0	No
outboundratelimitrate	The number of tokens per second that the bucket is refilled for outbound transfers (in wei). Note: Applicable if outbound rate limits are enabled.	0	No
inboundratelimitenabled	A flag indicating whether to enable inbound rate limits for cross-chain transfers (true or false).	false	No
inboundratelimitcapacity	The maximum number of tokens allowed in the bucket for inbound transfers (in wei). Note: Applicable if inbound rate limits are enabled.	0	No
inboundratelimitrate	The number of tokens per second that the bucket is refilled for inbound transfers (in wei). Note: Applicable if inbound rate limits are enabled.	0	No
network	The blockchain network where the local token pool is deployed. Examples include avalancheFuji, arbitrumSepolia, baseSepolia, and sepolia.	N/A	Yes
Command syntax:

copy to clipboard
npx hardhat updateRateLimiters \
  --pooladdress <POOL_ADDRESS> \
  --remotechain <REMOTE_CHAIN> \
  --ratelimiter <inbound/outbound/both> \
  --outboundratelimitenabled <true/false> \
  --outboundratelimitcapacity <OUTBOUND_CAPACITY> \
  --outboundratelimitrate <OUTBOUND_RATE> \
  --inboundratelimitenabled <true/false> \
  --inboundratelimitcapacity <INBOUND_CAPACITY> \
  --inboundratelimitrate <INBOUND_RATE> \
  --network <NETWORK_NAME>
Example command:

Suppose you want to enable inbound and outbound rate limits for your token pool on Avalanche Fuji to control the number of tokens received or sent from/to Arbitrum Sepolia. We will use an existing token pool that interacts with an ERC20 token with 18 decimals:

Token Pool on Avalanche Fuji:

Outbound Rate Limiter:

Enabled: true
Capacity: 10000000000000000000 wei (equivalent to 10 tokens, based on 18 decimals)
Rate: 100000000000000000 wei (equivalent to 0.1 token per second, based on 18 decimals)
Note:
Capacity / Rate = 10 / 0.1 = 100 seconds
It takes 100 seconds to replenish the bucket from 0 to full capacity.
Inbound Rate Limiter:

Enabled: true
Capacity: 20000000000000000000 wei (equivalent to 20 tokens, based on 18 decimals)
Rate: 100000000000000000 wei (equivalent to 0.1 tokens per second, based on 18 decimals)
Note:
Capacity / Rate = 20 / 0.1 = 200 seconds
It takes 200 seconds to replenish the bucket from 0 to full capacity.
Token Pool on Arbitrum Sepolia: Rate limits are the same as the Avalanche Fuji pool, but the inbound and outbound settings are swapped.

Outbound Rate Limiter:
Enabled: true
Capacity: 20000000000000000000 wei
Rate: 100000000000000000 wei
Inbound Rate Limiter:
Enabled: true
Capacity: 10000000000000000000 wei
Rate: 100000000000000000 wei
Update rate limiter settings for the token pool on Avalanche Fuji: Replace <POOL_ADDRESS> with your token pool address.

copy to clipboard
npx hardhat updateRateLimiters \
  --pooladdress <POOL_ADDRESS> \
  --remotechain arbitrumSepolia \
  --ratelimiter both \
  --outboundratelimitenabled true \
  --outboundratelimitcapacity 10000000000000000000 \
  --outboundratelimitrate 100000000000000000 \
  --inboundratelimitenabled true \
  --inboundratelimitcapacity 20000000000000000000 \
  --inboundratelimitrate 100000000000000000 \
  --network avalancheFuji
Expected output:

copy to clipboard
$ npx hardhat updateRateLimiters \
  --pooladdress 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 \
  --remotechain arbitrumSepolia \
  --ratelimiter both \
  --outboundratelimitenabled true \
  --outboundratelimitcapacity 10000000000000000000 \
  --outboundratelimitrate 100000000000000000 \
  --inboundratelimitenabled true \
  --inboundratelimitcapacity 20000000000000000000 \
  --inboundratelimitrate 100000000000000000 \
  --network avalancheFuji

2025-05-15T09:16:58.330Z info: Current Rate Limiters for token pool: 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047
2025-05-15T09:16:58.331Z info:   Outbound Rate Limiter:
2025-05-15T09:16:58.332Z info:     Enabled: false
2025-05-15T09:16:58.332Z info:     Capacity: 0
2025-05-15T09:16:58.332Z info:     Rate: 0
2025-05-15T09:16:58.332Z info:   Inbound Rate Limiter:
2025-05-15T09:16:58.333Z info:     Enabled: false
2025-05-15T09:16:58.333Z info:     Capacity: 0
2025-05-15T09:16:58.333Z info:     Rate: 0
2025-05-15T09:16:58.333Z info:
2025-05-15T09:16:58.333Z info: ========== Updating Rate Limiters ==========
2025-05-15T09:16:58.333Z info: New Outbound Rate Limiter:
2025-05-15T09:16:58.333Z info:   Enabled: true
2025-05-15T09:16:58.334Z info:   Capacity: 10000000000000000000
2025-05-15T09:16:58.334Z info:   Rate: 100000000000000000
2025-05-15T09:16:58.334Z info: New Inbound Rate Limiter:
2025-05-15T09:16:58.334Z info:   Enabled: true
2025-05-15T09:16:58.334Z info:   Capacity: 20000000000000000000
2025-05-15T09:16:58.334Z info:   Rate: 100000000000000000
2025-05-15T09:16:58.334Z info: Updating both rate limiters...
2025-05-15T09:17:07.851Z info: Transaction hash: 0x8c387a84daf095bb5ecc5faea8324b582ae580e053d082fc43c7c2d9fc539402
2025-05-15T09:17:07.851Z info: Rate limiters updated successfully
Update rate limiter settings for the token pool on Arbitrum Sepolia: Replace <POOL_ADDRESS> with your token pool address.

copy to clipboard
npx hardhat updateRateLimiters \
  --pooladdress <POOL_ADDRESS> \
  --remotechain avalancheFuji \
  --ratelimiter both \
  --outboundratelimitenabled true \
  --outboundratelimitcapacity 20000000000000000000 \
  --outboundratelimitrate 100000000000000000 \
  --inboundratelimitenabled true \
  --inboundratelimitcapacity 10000000000000000000 \
  --inboundratelimitrate 100000000000000000 \
  --network arbitrumSepolia
Expected output:

copy to clipboard
$ npx hardhat updateRateLimiters \
  --pooladdress 0x74F0842a9A55575e8e36692c356292a812640F67 \
  --remotechain avalancheFuji \
  --ratelimiter both \
  --outboundratelimitenabled true \
  --outboundratelimitcapacity 20000000000000000000 \
  --outboundratelimitrate 100000000000000000 \
  --inboundratelimitenabled true \
  --inboundratelimitcapacity 10000000000000000000 \
  --inboundratelimitrate 100000000000000000 \
  --network arbitrumSepolia

2025-05-15T09:18:30.217Z info: Current Rate Limiters for token pool: 0x74F0842a9A55575e8e36692c356292a812640F67
2025-05-15T09:18:30.218Z info:   Outbound Rate Limiter:
2025-05-15T09:18:30.218Z info:     Enabled: false
2025-05-15T09:18:30.218Z info:     Capacity: 0
2025-05-15T09:18:30.219Z info:     Rate: 0
2025-05-15T09:18:30.219Z info:   Inbound Rate Limiter:
2025-05-15T09:18:30.219Z info:     Enabled: false
2025-05-15T09:18:30.219Z info:     Capacity: 0
2025-05-15T09:18:30.219Z info:     Rate: 0
2025-05-15T09:18:30.220Z info:
2025-05-15T09:18:30.220Z info: ========== Updating Rate Limiters ==========
2025-05-15T09:18:30.220Z info: New Outbound Rate Limiter:
2025-05-15T09:18:30.220Z info:   Enabled: true
2025-05-15T09:18:30.220Z info:   Capacity: 20000000000000000000
2025-05-15T09:18:30.220Z info:   Rate: 100000000000000000
2025-05-15T09:18:30.221Z info: New Inbound Rate Limiter:
2025-05-15T09:18:30.221Z info:   Enabled: true
2025-05-15T09:18:30.221Z info:   Capacity: 10000000000000000000
2025-05-15T09:18:30.221Z info:   Rate: 100000000000000000
2025-05-15T09:18:30.221Z info: Updating both rate limiters...
2025-05-15T09:18:33.969Z info: Transaction hash: 0x31ccb66252ccc3247c0eb8bbe1198c2dda5c5222aceeafd4ae418b1abec84998
2025-05-15T09:18:33.969Z info: Rate limiters updated successfully
Verify the new rate limiter settings
After applying the new rate limiter settings, verify that they have been updated correctly.

Use the getCurrentRateLimits task to verify the updated settings:
Verify the updated rate limiter settings for the token pool on Avalanche Fuji:

copy to clipboard
npx hardhat getCurrentRateLimits \
  --pooladdress <POOL_ADDRESS> \
  --remotechain arbitrumSepolia \
  --network avalancheFuji
Example output:

copy to clipboard
$ npx hardhat getCurrentRateLimits \
  --pooladdress 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 \
  --remotechain arbitrumSepolia \
  --network avalancheFuji

2025-05-15T09:21:29.694Z info:
Rate Limiter States for Chain: arbitrumSepolia
2025-05-15T09:21:29.695Z info: Pool Address: 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047
2025-05-15T09:21:29.695Z info: Chain Selector: 3478487238524512106
2025-05-15T09:21:29.696Z info:
Outbound Rate Limiter:
2025-05-15T09:21:29.696Z info:   Enabled: true
2025-05-15T09:21:29.696Z info:   Capacity: 10000000000000000000
2025-05-15T09:21:29.696Z info:   Rate: 100000000000000000
2025-05-15T09:21:29.696Z info:   Tokens: 10000000000000000000
2025-05-15T09:21:29.696Z info:   Last Updated: 1747300882
2025-05-15T09:21:29.697Z info:
Inbound Rate Limiter:
2025-05-15T09:21:29.697Z info:   Enabled: true
2025-05-15T09:21:29.697Z info:   Capacity: 20000000000000000000
2025-05-15T09:21:29.697Z info:   Rate: 100000000000000000
2025-05-15T09:21:29.697Z info:   Tokens: 20000000000000000000
2025-05-15T09:21:29.697Z info:   Last Updated: 1747300882
Verify the updated rate limiter settings for the token pool on Arbitrum Sepolia:

copy to clipboard
npx hardhat getCurrentRateLimits \
  --pooladdress <POOL_ADDRESS> \
  --remotechain avalancheFuji \
  --network arbitrumSepolia
Example output:

copy to clipboard
$ npx hardhat getCurrentRateLimits \
  --pooladdress 0x74F0842a9A55575e8e36692c356292a812640F67 \
  --remotechain avalancheFuji \
  --network arbitrumSepolia

2025-05-15T09:22:34.408Z info:
Rate Limiter States for Chain: avalancheFuji
2025-05-15T09:22:34.410Z info: Pool Address: 0x74F0842a9A55575e8e36692c356292a812640F67
2025-05-15T09:22:34.410Z info: Chain Selector: 14767482510784806043
2025-05-15T09:22:34.410Z info:
Outbound Rate Limiter:
2025-05-15T09:22:34.410Z info:   Enabled: true
2025-05-15T09:22:34.410Z info:   Capacity: 20000000000000000000
2025-05-15T09:22:34.410Z info:   Rate: 100000000000000000
2025-05-15T09:22:34.410Z info:   Tokens: 20000000000000000000
2025-05-15T09:22:34.410Z info:   Last Updated: 1747300954
2025-05-15T09:22:34.411Z info:
Inbound Rate Limiter:
2025-05-15T09:22:34.411Z info:   Enabled: true
2025-05-15T09:22:34.411Z info:   Capacity: 10000000000000000000
2025-05-15T09:22:34.411Z info:   Rate: 100000000000000000
2025-05-15T09:22:34.411Z info:   Tokens: 10000000000000000000
2025-05-15T09:22:34.412Z info:   Last Updated: 1747300953
Test the rate limiter settings
To verify the rate limiter settings, initiate a cross-chain transfer between the token pools on Avalanche Fuji and Arbitrum Sepolia. The rate limiter configuration will control the flow of tokens between these pools.

Note: Ensure that your externally owned account (EOA) has a sufficient balance of ERC20 tokens on Avalanche Fuji to complete the transfer.

In the example below, we use a token pool at address 0xcC8bb3E03c59603522732B17487D2Cd5a5a3e047 on Avalanche Fuji, which has burn and mint privileges for the token at address 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef. We will transfer this token from Avalanche Fuji to Arbitrum Sepolia. For your own test, substitute these addresses with the token pool and token addresses that you have deployed.

Test Capacity: Because the outbound capacity set is 1000000000000000000000 , let's transfer 1000000000000000000001 tokens from Avalanche Fuji to Arbitrum Sepolia. This transfer should fail because the capacity is less than the number of tokens being transferred.

Command:

copy to clipboard
npx hardhat transferTokens --tokenaddress <TOKEN_ADDRESS> --amount 1000000000000000000001 --destinationchain arbitrumSepolia --receiveraddress <RECEIVER_ADDRESS> --network avalancheFuji
Expected output:

copy to clipboard
$ npx hardhat transferTokens --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --amount 1000000000000000000001 --destinationchain arbitrumSepolia --receiveraddress 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --network avalancheFuji

2025-05-15T09:34:18.464Z info: Estimated fees: 22167517387804854
2025-05-15T09:34:18.466Z info: Approving 1000000000000000000001 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T09:34:25.055Z info: Approving 22167517387804854 LINK to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T09:34:35.023Z info: Transferring 1000000000000000000001 of 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf on chain arbitrumSepolia with 22167517387804854 of LINK as fees
Simulation failed
Decoded error from factory RateLimiter__factory: TokenMaxCapacityExceeded Result(3) [
  10000000000000000000n,
  1000000000000000000001n,
  '0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef'
]
Notice in the logs that the transfer failed because the capacity was exceeded: TokenMaxCapacityExceeded.

Test Rate: Now, let's transfer 10000000000000000000 tokens from Avalanche Fuji to Arbitrum Sepolia, which will empty the bucket. After this transfer, we will attempt to transfer another 10000000000000000000 tokens. This transfer will fail because it takes 100 seconds to replenish the bucket.

First transfer (Successful):

Command:

copy to clipboard
npx hardhat transferTokens --tokenaddress <TOKEN_ADDRESS> --amount 10000000000000000000 --destinationchain arbitrumSepolia --receiveraddress <RECEIVER_ADDRESS> --network avalancheFuji
Expected output:

copy to clipboard
$ npx hardhat transferTokens --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --amount 10000000000000000000 --destinationchain arbitrumSepolia --receiveraddress 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --network avalancheFuji

2025-05-15T09:37:09.380Z info: Estimated fees: 22167517387804854
2025-05-15T09:37:09.383Z info: Approving 10000000000000000000 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T09:37:18.455Z info: Approving 22167517387804854 LINK to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T09:37:25.883Z info: Transferring 10000000000000000000 of 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf on chain arbitrumSepolia with 22167517387804854 of LINK as fees
2025-05-15T09:37:31.178Z info: Transaction hash: 0x8490f683383f02e6111ee6ac13072c724b2e3a67114fa765083620cce4c0e255
2025-05-15T09:37:31.188Z warn: Unable to parse the event logs corresponding to the transaction 0x8490f683383f02e6111ee6ac13072c724b2e3a67114fa765083620cce4c0e255
2025-05-15T09:37:31.188Z info: Check status of message on https://ccip.chain.link/tx/0x8490f683383f02e6111ee6ac13072c724b2e3a67114fa765083620cce4c0e255
Second transfer (Failed):

Command:

copy to clipboard
npx hardhat transferTokens --tokenaddress <TOKEN_ADDRESS> --amount 10000000000000000000 --destinationchain arbitrumSepolia --receiveraddress <RECEIVER_ADDRESS> --network avalancheFuji
Expected output:

copy to clipboard
$ npx hardhat transferTokens --tokenaddress 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef --amount 10000000000000000000 --destinationchain arbitrumSepolia --receiveraddress 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --network avalancheFuji

2025-05-15T09:37:55.351Z info: Estimated fees: 22167517387804854
2025-05-15T09:37:55.355Z info: Approving 10000000000000000000 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T09:38:02.306Z info: Approving 22167517387804854 LINK to 0xF694E193200268f9a4868e4Aa017A0118C9a8177
2025-05-15T09:38:10.812Z info: Transferring 10000000000000000000 of 0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef to 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf on chain arbitrumSepolia with 22167517387804854 of LINK as fees
Simulation failed
Decoded error from factory RateLimiter__factory: TokenRateLimitReached Result(3) [
  58n,
  4200000000000000000n,
  '0xE21b1AA00C6202b606C4F5B9E05B6f475823B8Ef'
]
Notice in the logs that the transfer failed because the rate limit was exceeded: TokenRateLimitReached.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



This tutorial will guide you through enabling your tokens in CCIP using Hardhat and Safe Multisig smart accounts. You will learn how to deploy tokens and set up Burn & Mint token pools using a 2-of-3 multi-signature Safe. After that, you will register the tokens in CCIP and configure them using multisig transactions without needing manual intervention. Finally, you will test the Burn & Mint token handling mechanism, where tokens are burned on the source blockchain, and an equivalent amount is minted on the destination blockchain.

Introduction to Smart Accounts and Safe Multisig
Introduction
A smart account (also known as a smart contract account) leverages the programmability of smart contracts to extend their functionality and improve their security compared to externally owned accounts (EOAs). Smart accounts are controlled by one or multiple EOAs or other smart accounts, and all transactions must be initiated by one of these controllers.

Some common features of smart accounts include:

Multi-signature schemes: Require multiple approvals for a transaction to be executed, enhancing security.
Transaction batching: Combine multiple actions into a single transaction, reducing costs and improving efficiency.
Account recovery: Allow for recovery mechanisms in case of lost access.
Gasless transactions: Enable transaction fees to be paid by a third party or relayer.
Safe is one of the most trusted implementations of a smart account, offering a robust multi-signature mechanism. In this tutorial, we will use a Safe Multisig account, specifically a 2-of-3 multi-signature setup, where two out of three owners must approve a transaction to execute it. This setup ensures enhanced security and decentralized control over the assets.

The Protocol Kit from Safe allows developers to interact with Safe, smart accounts through a TypeScript interface. This kit can be used to create new Safe accounts, update configurations, propose transactions, and execute them, making it an ideal choice for blockchain projects.

note
Safe Transaction Service API

In this tutorial, we will use BASE Sepolia and Ethereum Sepolia testnets. This is because Safe relies on the Safe Transaction Service API. The Safe Transaction Service offers a REST API to track transactions sent via the Safe Smart Account. It also provides endpoints to send transactions, collect signatures off-chain, and inform the owners about pending transactions to be broadcasted on-chain. The Safe SDK provides the API Kit, a TypeScript client for the Safe Transaction Service API, which is currently only supported on specific testnets such as BASE Sepolia and Ethereum Sepolia. For more information, see the Safe Transaction Service supported networks.

How Safe Multisig Works
Before we proceed, let's take a moment to understand how the multisig transaction process works with a Safe smart account.

In this tutorial, we'll use a 2-of-3 multi-signature setup as an example, where at least two out of the three Smart Account Owners must approve each transaction. Depending on your project's needs, this multisig process is valid for any scheme (e.g., 3-of-5, 4-of-7). In Safe smart accounts, the Smart Account Owners are responsible for approving actions. Transactions are signed off-chain by the required number of owners, which improves efficiency and reduces gas costs. Once the necessary threshold is met, the signed transactions are submitted to the blockchain for execution. The Safe smart account (a smart contract) verifies the signatures and enforces the required number of approvals before executing the transaction. This process enhances security, particularly for sensitive tasks such as registering a token administrator or configuring a token pool. Multi-signature ensures that no single owner can act alone.

The steps for enabling your tokens in CCIP follow the same flow as the previous tutorials that used externally owned accounts (EOA). The key difference here is that for sensitive actions like token administrator registration or token pool configuration, we assume your project uses a Safe multisig. Therefore, multiple signatures are required off-chain; in some cases, a batch of transactions will be submitted to save on gas costs.

The following sequence diagram illustrates the multisig transaction flow in a Safe smart account, from off-chain signature collection to on-chain execution:

How Safe Multisig works
In this diagram, the process is as follows:

Signer 1 initiates the batch of transactions (one or multiple transactions) and signs off-chain.
Signer 1 shares the batch with Signer 2, who signs it off-chain.
Once the required number of signatures is collected (in this case, two), the batch is submitted for execution.
The Smart Account verifies the signatures and checks that the signature threshold has been met.
The Smart Account then executes each transaction in the batch, interacting with the Target Smart Contract(s).
If any transaction fails, the entire batch is reverted. If all transactions succeed, they are confirmed on-chain.
By following this process, we maintain the security of multisig transactions while improving efficiency through the off-chain signature collection and gas savings from transaction batching.

Steps covered in this tutorial
We will cover the following key steps:

Creating a Safe Account: You will create a 2-of-3 multi-signature Safe that will serve as the owner of the token and token pool contracts. This Safe will also manage administrative tasks, such as configuring token pools and registering as the token admin in the token admin registry.

Deploying Tokens: You will deploy your BurnMintERC20 tokens on the Ethereum Sepolia and BASE Sepolia testnets and transfer ownership to the Safe account.

Deploying Token Pools: Once your tokens are deployed, you will deploy BurnMintTokenPool token pools on Ethereum Sepolia and BASE Sepolia. The Safe account will own each token pool.

Claiming and Accepting the Admin Role: This is a two-step process that will be managed using the Safe multi-signature account. It involves creating and signing multiple meta-transactions off-chain before executing them on-chain to register Safe as the token admin and accept the admin role for managing the tokens and token pools.

You will call the RegistryModuleOwnerCustom contract's registerAdminViaGetCCIPAdmin function to register the Safe as the token admin. This role is required to enable your token in CCIP.

Once claimed, you will call the TokenAdminRegistry contract's acceptAdminRole function to complete the registration process.

Meta-transactions are used here to batch these two actions, allowing both steps to be executed efficiently. The meta-transactions are created off-chain and signed by each of the two required Safe owners. This off-chain signing process reduces gas costs and enhances security, as the transactions are only broadcasted to the blockchain once all required signatures are collected.

Linking Tokens to Pools: You will use the Safe account to call the TokenAdminRegistry contract's setPool function to associate each token with its respective token pool.

Configuring Token Pools: You will configure each token pool by setting cross-chain transfer parameters, such as token pool rate limits and enabled destination chains, using multisig transactions through the Safe account.

Granting Mint and Burn Roles: You will grant the mint and burn roles to the token pools on each linked token using the Safe account. These roles are required for the token pools to mint and burn tokens during cross-chain transfers.

Minting Tokens: You will mint tokens on Ethereum Sepolia. These tokens will later be used to test cross-chain transfers to BASE Sepolia.

Transferring Tokens: Finally, you will transfer tokens from Ethereum Sepolia to BASE Sepolia using CCIP. You can pay CCIP fees using either LINK tokens or native gas tokens.

By the end of this tutorial, you will have successfully deployed, registered, configured, and enabled your tokens and token pools for use in CCIP. All are managed securely through a multi-signature Safe account.

Before You Begin
Make sure you have Node.js v18 or above installed. If not, install Node.js v18:
Download Node.js 18 if you don't have it installed. Optionally, you can use the nvm package to switch between Node.js versions:

copy to clipboard
nvm use 18
Verify that the correct version of Node.js is installed:

copy to clipboard
node -v
Example output:

copy to clipboard
$ node -v
v18.7.0
Clone the repository and navigate to the project directory:

copy to clipboard
git clone https://github.com/smartcontractkit/smart-contract-examples.git
cd smart-contract-examples/ccip/cct/hardhat
Install dependencies for the project:

copy to clipboard
npm install
Compile the project:

copy to clipboard
npm run compile
Encrypt your environment variables for higher security:
The project uses @chainlink/env-enc to encrypt your environment variables at rest. Follow the steps below to configure your environment securely:

Set an encryption password for your environment variables:

copy to clipboard
npx env-enc set-pw
Set up a .env.enc file with the necessary variables for Ethereum Sepolia and BASE Sepolia testnets. Use the following command to add the variables:

copy to clipboard
npx env-enc set
Variables to configure:

ETHEREUM_SEPOLIA_RPC_URL: A URL for the Ethereum Sepolia testnet. You can get a personal endpoint from services like Alchemy or Infura.
BASE_SEPOLIA_RPC_URL: A URL for the BASE Sepolia testnet. You can sign up for a personal endpoint from Alchemy or Infura.
PRIVATE_KEY: The private key for the first signer of the Safe multisig account. If you use MetaMask, you can follow this guide to export your private key. Note: This key is used to create and sign the transaction of the first signer.
PRIVATE_KEY_2: The private key for the second signer of the Safe multisig account. If you use MetaMask, you can follow this guide to export your private key. Note: This key is used to create and sign the transaction of the second signer.
ETHERSCAN_API_KEY: An API key from Etherscan to verify your contracts. You can obtain one from Etherscan.
BASESCAN_API_KEY: An API key from Basescan to verify your contracts on BASE. See this guide to get one from Basescan.
Fund the EOA linked to the first private key with LINK and native gas tokens:
Make sure your EOA has enough LINK and native gas tokens on Ethereum Sepolia and BASE Sepolia to cover transaction fees. You can use the Chainlink faucets to get testnet tokens. Important clarifications:

Off-chain signatures are collected for this tutorial. The first EOA is responsible for sending the transactions to the Safe smart account, meaning only the first EOA requires enough native gas tokens for these transactions.
When transferring the deployed tokens from Ethereum Sepolia to BASE Sepolia, the first EOA will be used to pay the CCIP fees in LINK. Therefore, it is crucial that the first EOA has sufficient LINK tokens to cover these fees. If a different EOA were to initiate the CCIP transfer, that EOA would need to hold enough LINK tokens.
Tutorial
note
Explore the Code

All Hardhat tasks used in this tutorial are located in the tasks/safe-multisig directory of the repository. Each task is thoroughly commented and directly linked to a key step in the tutorial, making the code self-explanatory. Read the code and comments to gain a deeper understanding of the process or explore the implementation details.

note
Funding and Signature Clarifications

In this tutorial, the first EOA is responsible for sending transactions involving the Safe smart account. Therefore, only the first EOA must have sufficient native gas tokens to cover transaction fees for all operations. It is also important to note that during multi-signature operations, signatures will be collected from the second EOA off-chain to fulfill the required number of signatures, but the first EOA will handle the on-chain transaction submissions.

Deploy Safe Smart Accounts
In this step, you will deploy a Safe smart account on both Ethereum Sepolia and BASE Sepolia using the deploySafe task. The Safe smart account will serve as the multi-signature account, requiring approvals from multiple owners to authorize transactions. You can customize the number of owners and the required threshold for signatures.

Below is an explanation of the parameters used during deployment:

Parameter	Description	Default	Required
owners	A comma-separated list of owner addresses. These are the Ethereum addresses that will control the Safe smart account and authorize transactions.	N/A	Yes
threshold	The number of required signatures to authorize a transaction. This must be at least 1 and cannot exceed the number of owners provided.	1	Yes
network	The blockchain on which the Safe smart account will be deployed. Examples include sepolia for Ethereum Sepolia and baseSepolia for BASE Sepolia.	N/A	Yes
Deploy a Safe on Ethereum Sepolia (Replace 0xOwnerAddress1, 0xOwnerAddress2, and 0xOwnerAddress3 with your Ethereum addresses):

copy to clipboard
npx hardhat deploySafe --owners "0xOwnerAddress1,0xOwnerAddress2,0xOwnerAddress3" --threshold 2 --network sepolia
Example output:

copy to clipboard
$ npx hardhat deploySafe --owners 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA,0xA028Cedc47485aB2F1230551E4f3a6871B764263,0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --threshold 2 --network sepolia

2025-05-15T15:32:48.235Z info: Initializing Safe Protocol Kit...
2025-05-15T15:32:50.056Z info: Deploying Safe with the following configuration:
2025-05-15T15:32:50.056Z info: Owners: 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA, 0xA028Cedc47485aB2F1230551E4f3a6871B764263, 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf
2025-05-15T15:32:50.056Z info: Threshold: 2
2025-05-15T15:32:50.056Z info: Salt nonce: 38379367611322498636143726637956939262525535210366890252487188019703321761416
2025-05-15T15:33:03.680Z info: Safe deployed successfully at address: 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
Deploy a Safe on BASE Sepolia (Replace 0xOwnerAddress1, 0xOwnerAddress2, and 0xOwnerAddress3 with your Ethereum addresses):

copy to clipboard
npx hardhat deploySafe --owners "0xOwnerAddress1,0xOwnerAddress2,0xOwnerAddress3" --threshold 2 --network baseSepolia
Example output:

copy to clipboard
$ npx hardhat deploySafe --owners 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA,0xA028Cedc47485aB2F1230551E4f3a6871B764263,0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf --threshold 2 --network baseSepolia

2025-05-15T15:38:47.857Z info: Initializing Safe Protocol Kit...
2025-05-15T15:38:49.395Z info: Deploying Safe with the following configuration:
2025-05-15T15:38:49.395Z info: Owners: 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA, 0xA028Cedc47485aB2F1230551E4f3a6871B764263, 0x27d7A69C878F9c8f51f4e53703abCE9bAcd2D9bf
2025-05-15T15:38:49.395Z info: Threshold: 2
2025-05-15T15:38:49.395Z info: Salt nonce: 96228125351478622478825173646808876872832528152252275965961638646626126249894
2025-05-15T15:38:58.503Z info: Safe deployed successfully at address: 0xcba922b26e7382955576014b7F1313ED6eb28c05
note
Record Safe contract addresses

Make sure to record the addresses of the deployed Safe smart accounts. You will need these addresses to interact with the Safe smart accounts in the following steps.

Deploy Tokens
In this step, you will deploy a token on both Ethereum Sepolia and BASE Sepolia using the deployTokenWithSafe task, then transfer ownership of the token to the Safe multisig account. This ensures that the Safe smart account controls the token, requiring multiple signatures to authorize any future administrative actions.

Below is an explanation of the parameters used during deployment:

Parameter	Description	Default	Required
safeaddress	The address of the Safe smart account that will own the deployed token.	N/A	Yes
name	The full name of the token.	N/A	Yes
symbol	The shorthand symbol representing the token.	N/A	Yes
decimals	The number of decimal places the token supports (e.g., 18 means 1 token is represented as 1e18 smallest units).	18	No
maxsupply	The maximum supply of tokens. Set to 0 for unlimited supply.	0	No
premint	The amount of tokens to be minted to the owner at the time of deployment. If set to 0, no tokens will be minted to the owner during deployment.	0	No
verifycontract	Whether to verify the contract on Etherscan or a similar blockchain explorer.	false	No
network	The blockchain on which the token will be deployed. Examples include sepolia for Ethereum Sepolia and baseSepolia for BASE Sepolia.	N/A	Yes
Deploy a token on Ethereum Sepolia (Replace 0xSafeAddress with the address of the Safe smart account. You can also adapt the token name and symbol as needed):

copy to clipboard
npx hardhat deployTokenWithSafe \
  --name "BnM aem" \
  --symbol BnMaem \
  --decimals 18 \
  --maxsupply 0 \
  --safeaddress 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 \
  --verifycontract true \
  --network sepolia
Example output:

copy to clipboard
2025-05-15T15:47:29.124Z info: Deploying BurnMintERC20 contract to sepolia
2025-05-15T15:47:29.125Z info: Waiting 2 blocks for transaction 0xbf6814a50f884b3397b0ff5355339e6c0822c07483d70208f692f3bee2cb9170 to be confirmed...
2025-05-15T15:47:55.976Z info: Token deployed to: 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21
2025-05-15T15:47:55.977Z info: Verifying contract on Etherscan...
The contract 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://sepolia.etherscan.io/address/0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21#code

2025-05-15T15:47:57.606Z info: Token contract deployed and verified
2025-05-15T15:47:57.607Z info: Transferring ownership of token to Safe at 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
2025-05-15T15:48:25.529Z info: Ownership of token transferred to Safe at 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
2025-05-15T15:48:25.529Z info: Setting Safe at 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 as the CCIP admin
2025-05-15T15:48:48.744Z info: Safe at 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 has been set as the CCIP admin
Deploy a token on BASE Sepolia (Replace 0xSafeAddress with the address of the Safe smart account. You can also adapt the token name and symbol as needed):

copy to clipboard
npx hardhat deployTokenWithSafe \
  --name "BnM aem" \
  --symbol BnMaem \
  --decimals 18 \
  --maxsupply 0 \
  --safeaddress 0xcba922b26e7382955576014b7F1313ED6eb28c05 \
  --verifycontract true \
  --network baseSepolia
Example output:

copy to clipboard
2025-05-15T16:02:17.414Z info: Deploying BurnMintERC20 contract to baseSepolia
2025-05-15T16:02:17.415Z info: Waiting 2 blocks for transaction 0xf1d1846148b3c0553f9c804d094ee2f815c4260563159bb6043c9e48c414decd to be confirmed...
2025-05-15T16:02:18.967Z info: Token deployed to: 0xa284Ec8049A6360B9A5990f12d472fd385680f50
2025-05-15T16:02:18.968Z info: Verifying contract on Etherscan...
Successfully submitted source code for contract
@chainlink/contracts/src/v0.8/shared/token/ERC20/BurnMintERC20.sol:BurnMintERC20 at 0xa284Ec8049A6360B9A5990f12d472fd385680f50
for verification on the block explorer. Waiting for verification result...

Successfully verified contract BurnMintERC20 on the block explorer.
https://sepolia.basescan.org/address/0xa284Ec8049A6360B9A5990f12d472fd385680f50#code

2025-05-15T16:02:26.553Z info: Token contract deployed and verified
2025-05-15T16:02:26.554Z info: Transferring ownership of token to Safe at 0xcba922b26e7382955576014b7F1313ED6eb28c05
2025-05-15T16:02:36.461Z info: Ownership of token transferred to Safe at 0xcba922b26e7382955576014b7F1313ED6eb28c05
2025-05-15T16:02:36.461Z info: Setting Safe at 0xcba922b26e7382955576014b7F1313ED6eb28c05 as the CCIP admin
2025-05-15T16:02:45.474Z info: Safe at 0xcba922b26e7382955576014b7F1313ED6eb28c05 has been set as the CCIP admin
note
Record Token contract addresses

Make sure to record the addresses of the deployed token contracts. You will need these addresses to interact with the tokens in the following steps.

Deploy Token Pools
caution
Understand Token Pool Requirements

Before deploying your token pools, make sure you understand the mandatory requirements for token pools and the gas limit restrictions. The releaseOrMint function and other operations (e.g., balance checks) must not exceed the 90,000 gas limit on the destination blockchain. Failure to meet these requirements can lead to manual execution. For more details, refer to the Common Requirements.

In this step, you will deploy a token pool on both Ethereum Sepolia and BASE Sepolia using the deployTokenPoolWithSafe task, then transfer ownership of the token pool to the Safe smart account. This ensures that the Safe smart account controls the token pool, providing a secure, multisig setup for managing the token pool operations.

Below is an explanation of the parameters used during deployment:

Parameter	Description	Default	Required
tokenaddress	The address of the token that the pool will manage.	N/A	Yes
safeaddress	The address of the Safe smart account that will own the token pool.	N/A	Yes
localtokendecimals	The number of decimals for the token on this chain.	18	No
verifycontract	Whether to verify the contract on Etherscan or a similar blockchain explorer.	false	No
network	The blockchain on which the token pool will be deployed. Examples include sepolia for Ethereum Sepolia and baseSepolia for BASE Sepolia.	N/A	Yes
Deploy a Burn and Mint token pool on Ethereum Sepolia (Replace 0xTokenAddress and 0xSafeAddress with the token address and Safe smart account address, respectively):

copy to clipboard
npx hardhat deployTokenPoolWithSafe \
  --tokenaddress 0xTokenAddress \
  --safeaddress 0xSafeAddress \
  --localtokendecimals 18 \
  --verifycontract true \
  --network sepolia
Example output:

copy to clipboard
$ npx hardhat deployTokenPoolWithSafe \
   --tokenaddress 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 \
   --safeaddress 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 \
   --localtokendecimals 18 \
   --verifycontract true \
   --network sepolia

2025-05-15T16:37:55.334Z info: Waiting 2 blocks for transaction 0xdac1450c299a28e4ef285a5d13a4f5e060f8f59d0954cc7aacfd8980f8273880 to be confirmed...
2025-05-15T16:38:12.821Z info: Token pool deployed to: 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084
2025-05-15T16:38:12.821Z info: Verifying contract on Etherscan...
2025-05-15T16:38:15.864Z error: Failed to send contract verification request.
2025-05-15T15:47:55.977Z info: Verifying contract on Etherscan...
The contract 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084 has already been verified on the block explorer. If you're trying to verify a partially verified contract, please use the --force flag.
https://sepolia.etherscan.io/address/0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084#code

2025-05-15T16:38:15.865Z info: Transferring ownership of Token Pool to Safe at 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
2025-05-15T16:38:40.846Z info: Ownership of Token Pool transferred to Safe at 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
Deploy a Burn and Mint token pool on BASE Sepolia (Replace 0xTokenAddress and 0xSafeAddress with the token address and Safe smart account address, respectively):

copy to clipboard
npx hardhat deployTokenPoolWithSafe \
  --tokenaddress 0xTokenAddress \
  --safeaddress 0xSafeAddress \
  --localtokendecimals 18 \
  --verifycontract true \
  --network baseSepolia
Example output:

copy to clipboard
$ npx hardhat deployTokenPoolWithSafe \
   --tokenaddress 0xa284Ec8049A6360B9A5990f12d472fd385680f50 \
   --safeaddress 0xcba922b26e7382955576014b7F1313ED6eb28c05 \
   --localtokendecimals 18 \
   --verifycontract true \
   --network baseSepolia

2025-05-15T16:44:20.542Z info: Waiting 2 blocks for transaction 0x5947e2b45c36ec7c963f047591d32d9c9465a09ff5d36f3337740a0af0e11b33 to be confirmed...
2025-05-15T16:44:21.290Z info: Token pool deployed to: 0xa5FAe80F8986d7000610E1ea857ce2981C44140a
2025-05-15T16:44:21.291Z info: Verifying contract on Etherscan...
Successfully submitted source code for contract
@chainlink/contracts-ccip/contracts/pools/BurnMintTokenPool.sol:BurnMintTokenPool at 0xa5FAe80F8986d7000610E1ea857ce2981C44140a
for verification on the block explorer. Waiting for verification result...

Successfully verified contract BurnMintTokenPool on the block explorer.
https://sepolia.basescan.org/address/0xa5FAe80F8986d7000610E1ea857ce2981C44140a#code

2025-05-15T16:44:38.767Z info: Token pool contract deployed and verified
2025-05-15T16:44:38.768Z info: Transferring ownership of Token Pool to Safe at 0xcba922b26e7382955576014b7F1313ED6eb28c05
2025-05-15T16:44:48.457Z info: Ownership of Token Pool transferred to Safe at 0xcba922b26e7382955576014b7F1313ED6eb28c05
note
Record Token Pool contract addresses

Make sure to record the addresses of the deployed token pool contracts. You will need these addresses to interact with the token pools in the following steps.

Accept Ownership of Token Pools
After deploying the token pools and transferring ownership to the Safe smart account, the Safe smart account must formally accept ownership of the token pools. This ensures that all administrative actions for the token pools will require multisig approval, ensuring a secure and decentralized management process.

The process will use the Safe smart account to sign the transaction off-chain, collect the required signatures from multiple owners, and then execute it on-chain.

Below is an explanation of the parameters used during this task:

Parameter	Description	Required
contractaddress	The address of the contract whose ownership the Safe smart account is accepting.	Yes
safeaddress	The address of the Safe smart account that will accept ownership of the contract.	Yes
network	The blockchain network where the transaction will be executed. Examples include sepolia for Ethereum Sepolia and baseSepolia for BASE Sepolia.	Yes
Accept ownership of the token pool on Ethereum Sepolia (Replace 0xContractAddress and 0xSafeAddress with the token pool contract address and Safe smart account address, respectively):

copy to clipboard
npx hardhat acceptOwnershipFromSafe --contractaddress 0xContractAddress --safeaddress 0xSafeAddress --network sepolia
Example output:

copy to clipboard
$ npx hardhat acceptOwnershipFromSafe \
    --contractaddress 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084 \
    --safeaddress 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 \
    --network sepolia

2025-05-15T17:00:39.803Z info: Encoding acceptOwnership call for contract at 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084...
2025-05-15T17:00:39.981Z info: Setting up Safe transaction...
2025-05-15T17:00:44.376Z info: Safe transaction created
2025-05-15T17:00:45.665Z info: Safe transaction signed by owner 1
2025-05-15T17:00:47.630Z info: Safe transaction signed by owner 2
2025-05-15T17:00:47.632Z info: Executing Safe transaction to accept ownership...
2025-05-15T17:00:50.534Z info: Executed Safe transaction
2025-05-15T17:00:50.535Z info: Waiting for 2 blocks for transaction 0x15dde64c9147342c9065304b8a21645727e4d25dc11f8ec7c3e4fc6cd880503f to be confirmed...
2025-05-15T17:01:16.426Z info: Transaction confirmed after 2 blocks.
Accept ownership of the token pool on BASE Sepolia (Replace 0xContractAddress and 0xSafeAddress with the token pool contract address and Safe smart account address, respectively):

copy to clipboard
npx hardhat acceptOwnershipFromSafe \
  --contractaddress 0xa5FAe80F8986d7000610E1ea857ce2981C44140a \
  --safeaddress 0xcba922b26e7382955576014b7F1313ED6eb28c05 \
  --network baseSepolia
Example output:

copy to clipboard
2025-05-15T17:02:53.631Z info: Encoding acceptOwnership call for contract at 0xa5FAe80F8986d7000610E1ea857ce2981C44140a...
2025-05-15T17:02:53.790Z info: Setting up Safe transaction...
2025-05-15T17:02:59.263Z info: Safe transaction created
2025-05-15T17:03:01.147Z info: Safe transaction signed by owner 1
2025-05-15T17:03:02.416Z info: Safe transaction signed by owner 2
2025-05-15T17:03:02.417Z info: Executing Safe transaction to accept ownership...
2025-05-15T17:03:06.223Z info: Executed Safe transaction
2025-05-15T17:03:06.223Z info: Waiting for 2 blocks for transaction 0xe600bdd13d77dc266b6adf34f7c6d1baf491e20ceae9e93140700c22e481abaa to be confirmed...
2025-05-15T17:03:11.594Z info: Transaction confirmed after 2 blocks.
Claim and Accept Token Admin Role using Safe
In this step, you will use the claimAndAcceptAdminRoleFromSafe task to claim and accept the admin role for the deployed tokens in a single Ethereum transaction. By leveraging Safe's batching feature, we can efficiently combine the two operationsclaiming the admin role and accepting the admin roleinto one on-chain interaction. This reduces gas costs and improves efficiency.

The process will use the Safe smart account to sign the transaction off-chain, collect the required signatures from multiple owners, and then execute it on-chain.

Below is an explanation of the parameters used during this task:

Parameter	Description	Default	Required
tokenaddress	The address of the token for which the admin role will be claimed and accepted.	N/A	Yes
safeaddress	The address of the Safe smart account that will execute the transactions and become the token admin.	N/A	Yes
network	The blockchain on which the transaction will be executed. Examples include sepolia for Ethereum Sepolia and baseSepolia for BASE Sepolia.	N/A	Yes
Claim and accept the admin role for the token on Ethereum Sepolia (Replace 0xTokenAddress and 0xSafeAddress with the token address and Safe smart account address, respectively):

copy to clipboard
npx hardhat claimAndAcceptAdminRoleFromSafe --tokenaddress 0xTokenAddress --safeaddress 0xSafeAddress --network sepolia
Example output:

copy to clipboard
$ npx hardhat claimAndAcceptAdminRoleFromSafe --tokenaddress 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 --safeaddress 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 --network sepolia

2025-05-15T17:58:57.327Z info: Current token CCIP admin: 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
2025-05-15T17:58:57.330Z info: Claiming admin of 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 via getCCIPAdmin() for Safe at 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
2025-05-15T17:58:57.335Z info: Adding second MetaTransaction to accept admin role for token 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21
2025-05-15T17:59:01.740Z info: Safe transaction with two meta transactions created
2025-05-15T17:59:02.996Z info: Safe transaction signed by owner 1
2025-05-15T17:59:04.586Z info: Safe transaction signed by owner 2
2025-05-15T17:59:04.586Z info: Executing Safe transaction to claim and accept admin role...
2025-05-15T17:59:07.040Z info: Executed Safe transaction
2025-05-15T17:59:07.040Z info: Waiting for 2 blocks for transaction 0x28f3138030f65acf35948a597ded0393441bf802e07bccd9b5e8c74cba4f0486 to be confirmed...
2025-05-15T17:59:25.649Z info: Transaction confirmed after 2 blocks.
2025-05-15T17:59:25.650Z info: Claiming admin of token 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 via Safe and accepted admin role successfully.
Claim and accept the admin role for the token on BASE Sepolia (Replace 0xTokenAddress and 0xSafeAddress with the token address and Safe smart account address, respectively):

copy to clipboard
npx hardhat claimAndAcceptAdminRoleFromSafe --tokenaddress 0xTokenAddress --safeaddress 0xSafeAddress --network baseSepolia
Example output:

copy to clipboard
$ npx hardhat claimAndAcceptAdminRoleFromSafe --tokenaddress 0xa284Ec8049A6360B9A5990f12d472fd385680f50 --safeaddress 0xcba922b26e7382955576014b7F1313ED6eb28c05 --network baseSepolia

2025-05-15T18:00:42.653Z info: Current token CCIP admin: 0xcba922b26e7382955576014b7F1313ED6eb28c05
2025-05-15T18:00:42.656Z info: Claiming admin of 0xa284Ec8049A6360B9A5990f12d472fd385680f50 via getCCIPAdmin() for Safe at 0xcba922b26e7382955576014b7F1313ED6eb28c05
2025-05-15T18:00:42.659Z info: Adding second MetaTransaction to accept admin role for token 0xa284Ec8049A6360B9A5990f12d472fd385680f50
2025-05-15T18:00:46.780Z info: Safe transaction with two meta transactions created
2025-05-15T18:00:48.415Z info: Safe transaction signed by owner 1
2025-05-15T18:00:49.675Z info: Safe transaction signed by owner 2
2025-05-15T18:00:49.675Z info: Executing Safe transaction to claim and accept admin role...
2025-05-15T18:00:52.315Z info: Executed Safe transaction
2025-05-15T18:00:52.315Z info: Waiting for 2 blocks for transaction 0x2fa1994a0bf73cd2a642933562bbee8b24bbf94dc7b5c648ad375e767f41b532 to be confirmed...
2025-05-15T18:00:57.717Z info: Transaction confirmed after 2 blocks.
2025-05-15T18:00:57.717Z info: Claiming admin of token 0xa284Ec8049A6360B9A5990f12d472fd385680f50 via Safe and accepted admin role successfully.
Grant Mint and Burn Roles using Safe
In this step, you will use the grantMintBurnRoleFromSafe task to grant mint and burn roles to both the token pool and the Safe smart account on Ethereum Sepolia and BASE Sepolia. The Safe smart account will handle the transaction to securely assign these roles, ensuring that multiple owners sign off on the operation. Granting mint and burn roles is essential to allow the token pool and the Safe account to manage token issuance and burning, and to prepare for future cross-chain transfers.

This process will grant:

Mint and burn roles to the token pool for handling cross-chain operations.
Mint and burn roles to the Safe smart account for minting tokens to EOAs for testing purposes.
Below is an explanation of the parameters used during this task:

Parameter	Description	Required
tokenaddress	The address of the deployed token contract for which mint and burn roles will be granted.	Yes
burnerminters	A comma-separated list of addresses (token pools and Safe smart account) to which mint and burn roles will be granted.	Yes
safeaddress	The address of the Safe smart account that will execute the transaction to grant mint and burn roles.	Yes
network	The blockchain on which the mint and burn roles will be granted. Examples include sepolia for Ethereum Sepolia and baseSepolia for BASE Sepolia.	Yes
Grant mint and burn roles on Ethereum Sepolia (Replace 0xTokenAddress, 0xPoolAddress, and 0xSafeAddress with the token address, token pool address, and Safe smart account address, respectively):

copy to clipboard
npx hardhat grantMintBurnRoleFromSafe \
  --tokenaddress 0xTokenAddress \
  --burnerminters 0xPoolAddress,0xSafeAddress \
  --safeaddress 0xSafeAddress \
  --network sepolia
Example output:

copy to clipboard
$ npx hardhat grantMintBurnRoleFromSafe --tokenaddress 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 --burnerminters 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084,0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 --safeaddress 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 --network sepolia

2025-05-15T18:09:40.787Z info: Connecting to token contract at 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21...
2025-05-15T18:09:44.862Z info: Setting up Safe transactions to grant mint and burn roles to: 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084, 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
2025-05-15T18:09:45.423Z info: Safe transaction created
2025-05-15T18:09:46.690Z info: Safe transaction signed by owner 1
2025-05-15T18:09:48.556Z info: Safe transaction signed by owner 2
2025-05-15T18:09:48.557Z info: Executing Safe transaction to grant mint and burn roles...
2025-05-15T18:09:51.051Z info: Executed Safe transaction
2025-05-15T18:09:51.051Z info: Waiting for 2 blocks for transaction 0xddac86c3a9d7a954a21bad60e1687363d553471615ff04d05736de05bcababca to be confirmed...
2025-05-15T18:10:18.680Z info: Transaction confirmed after 2 blocks.
2025-05-15T18:10:18.681Z info: Mint and burn roles granted to 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084, 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
Grant mint and burn roles on BASE Sepolia (Replace 0xTokenAddress, 0xPoolAddress, and 0xSafeAddress with the token address, token pool address, and Safe smart account address, respectively):

copy to clipboard
npx hardhat grantMintBurnRoleFromSafe \
  --tokenaddress 0xTokenAddress \
  --burnerminters 0xPoolAddress,0xSafeAddress \
  --safeaddress 0xSafeAddress \
  --network baseSepolia
Example output:

copy to clipboard
$ npx hardhat grantMintBurnRoleFromSafe --tokenaddress 0xa284Ec8049A6360B9A5990f12d472fd385680f50 --burnerminters 0xa5FAe80F8986d7000610E1ea857ce2981C44140a,0xcba922b26e7382955576014b7F1313ED6eb28c05 --safeaddress 0xcba922b26e7382955576014b7F1313ED6eb28c05 --network baseSepolia

2025-05-15T18:11:36.277Z info: Connecting to token contract at 0xa284Ec8049A6360B9A5990f12d472fd385680f50...
2025-05-15T18:11:40.533Z info: Setting up Safe transactions to grant mint and burn roles to: 0xa5FAe80F8986d7000610E1ea857ce2981C44140a, 0xcba922b26e7382955576014b7F1313ED6eb28c05
2025-05-15T18:11:41.099Z info: Safe transaction created
2025-05-15T18:11:42.751Z info: Safe transaction signed by owner 1
2025-05-15T18:11:44.363Z info: Safe transaction signed by owner 2
2025-05-15T18:11:44.364Z info: Executing Safe transaction to grant mint and burn roles...
2025-05-15T18:11:48.063Z info: Executed Safe transaction
2025-05-15T18:11:48.063Z info: Waiting for 2 blocks for transaction 0xbfe5e20537e790f23de7b7520f92cee781057fa300b718615cd0f9ee74f4db9d to be confirmed...
2025-05-15T18:11:53.175Z info: Transaction confirmed after 2 blocks.
2025-05-15T18:11:53.176Z info: Mint and burn roles granted to 0xa5FAe80F8986d7000610E1ea857ce2981C44140a, 0xcba922b26e7382955576014b7F1313ED6eb28c05
Set Pool using Safe
In this step, you will use the setPoolFromSafe task to link a token to a token pool on both Ethereum Sepolia and BASE Sepolia. The Safe smart account will be used to execute the transaction, ensuring that the pool is set securely with multisig approval. Multiple owners will sign the transaction off-chain before it is executed on-chain.

Below is an explanation of the parameters used during this task:

Parameter	Description	Required
tokenaddress	The address of the token for which the pool will be set.	Yes
pooladdress	The address of the token pool to be linked to the token.	Yes
safeaddress	The address of the Safe smart account that will execute the transaction.	Yes
network	The blockchain on which the transaction will be executed. Examples include sepolia for Ethereum Sepolia and baseSepolia for BASE Sepolia.	Yes
Set the token pool on Ethereum Sepolia (Replace 0xTokenAddress, 0xPoolAddress, and 0xSafeAddress with the token address, token pool address, and Safe smart account address, respectively):

copy to clipboard
npx hardhat setPoolFromSafe --tokenaddress 0xTokenAddress --pooladdress 0xPoolAddress --safeaddress 0xSafeAddress --network sepolia
Example output:

copy to clipboard
$ npx hardhat setPoolFromSafe --tokenaddress 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 --pooladdress 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084 --safeaddress 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 --network sepolia

2025-05-15T18:16:06.087Z info: Connecting to TokenAdminRegistry contract at 0x95F29FEE11c5C55d26cCcf1DB6772DE953B37B82...
2025-05-15T18:16:07.338Z info: Setting pool for token 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 to 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084 by 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2
2025-05-15T18:16:11.919Z info: Safe transaction created for setting the pool
2025-05-15T18:16:13.816Z info: Safe transaction signed by owner 1
2025-05-15T18:16:15.095Z info: Safe transaction signed by owner 2
2025-05-15T18:16:15.096Z info: Executing Safe transaction to set pool for token 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21...
2025-05-15T18:16:17.825Z info: Executed Safe transaction
2025-05-15T18:16:17.825Z info: Waiting for 2 blocks for transaction 0x35ce15719711eeda8dcd76a3d3c95576052789d94e0e2897b5caf828b468f79c to be confirmed...
2025-05-15T18:16:50.361Z info: Transaction confirmed after 2 blocks.
2025-05-15T18:16:50.362Z info: Pool set for token 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 to 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084 successfully.
Set the token pool on BASE Sepolia (Replace 0xTokenAddress, 0xPoolAddress, and 0xSafeAddress with the token address, token pool address, and Safe smart account address, respectively):

copy to clipboard
npx hardhat setPoolFromSafe --tokenaddress 0xTokenAddress --pooladdress 0xPoolAddress --safeaddress 0xSafeAddress --network baseSepolia
Example output:

copy to clipboard
$ npx hardhat setPoolFromSafe --tokenaddress 0xa284Ec8049A6360B9A5990f12d472fd385680f50 --pooladdress 0xa5FAe80F8986d7000610E1ea857ce2981C44140a --safeaddress 0xcba922b26e7382955576014b7F1313ED6eb28c05 --network baseSepolia

2025-05-15T18:17:42.868Z info: Connecting to TokenAdminRegistry contract at 0x736D0bBb318c1B27Ff686cd19804094E66250e17...
2025-05-15T18:17:44.056Z info: Setting pool for token 0xa284Ec8049A6360B9A5990f12d472fd385680f50 to 0xa5FAe80F8986d7000610E1ea857ce2981C44140a by 0xcba922b26e7382955576014b7F1313ED6eb28c05
2025-05-15T18:17:48.127Z info: Safe transaction created for setting the pool
2025-05-15T18:17:49.778Z info: Safe transaction signed by owner 1
2025-05-15T18:17:51.342Z info: Safe transaction signed by owner 2
2025-05-15T18:17:51.343Z info: Executing Safe transaction to set pool for token 0xa284Ec8049A6360B9A5990f12d472fd385680f50...
2025-05-15T18:17:53.847Z info: Executed Safe transaction
2025-05-15T18:17:53.847Z info: Waiting for 2 blocks for transaction 0x6731ae6ebbd61680552a2bfd54394b48072efbfb1453cc43a935954fe18b5884 to be confirmed...
2025-05-15T18:17:59.199Z info: Transaction confirmed after 2 blocks.
2025-05-15T18:17:59.199Z info: Pool set for token 0xa284Ec8049A6360B9A5990f12d472fd385680f50 to 0xa5FAe80F8986d7000610E1ea857ce2981C44140a successfully.
Configure Token Pools using Safe
In this step, you will use the applyChainUpdatesFromSafe task to configure a token pool for cross-chain interactions. By leveraging the Safe smart account, you can securely update the configuration of the token pool to support remote chains, including setting rate limits and linking it to remote pools and tokens.

The task handles complex cross-chain setups, allowing you to define rate limits for both inbound and outbound token transfers. The transaction is signed by the Safe owners off-chain and then executed on-chain, ensuring secure multi-signature control over the pool configuration.

Below is an explanation of the parameters used during this task:

Parameter	Description	Default	Required
pooladdress	The address of the token pool to be configured.	N/A	Yes
remotechain	The identifier of the remote blockchain (e.g., sepolia for Ethereum Sepolia or baseSepolia for BASE Sepolia).	N/A	Yes
remotepooladdresses	Comma-separated list of remote pool addresses.	N/A	Yes
remotetokenaddress	The address of the token on the remote chain.	N/A	Yes
outboundratelimitenabled	Whether the outbound rate limit for the token pool is enabled.	false	No
outboundratelimitcapacity	The maximum number of tokens that can be transferred outbound in a single burst (bucket capacity for the outbound rate limiter).	0	No
outboundratelimitrate	The rate at which tokens are refilled in the outbound bucket (tokens per second).	0	No
inboundratelimitenabled	Whether the inbound rate limit for the token pool is enabled.	false	No
inboundratelimitcapacity	The maximum number of tokens that can be transferred inbound in a single burst (bucket capacity for the inbound rate limiter).	0	No
inboundratelimitrate	The rate at which tokens are refilled in the inbound bucket (tokens per second).	0	No
safeaddress	The address of the Safe smart account that will execute the transaction to configure the pool.	N/A	Yes
network	The blockchain on which the pool is being configured. Examples include sepolia for Ethereum Sepolia and baseSepolia for BASE Sepolia.	N/A	Yes
Configure the token pool on Ethereum Sepolia (Replace 0xPoolAddress, 0xRemotePoolAddress, 0xRemoteTokenAddress, and 0xSafeAddress with the token pool address, remote token pool address, remote token address, and Safe smart account address, respectively):

copy to clipboard
npx hardhat applyChainUpdatesFromSafe --pooladdress 0xPoolAddress --remotechain baseSepolia  --remotepooladdresses 0xRemotePoolAddress --remotetokenaddress 0xRemoteTokenAddress --safeaddress 0xSafeAddress --network sepolia
Example output:

copy to clipboard
$ npx hardhat applyChainUpdatesFromSafe --pooladdress 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084 --remotechain baseSepolia --remotepooladdresses 0xa5FAe80F8986d7000610E1ea857ce2981C44140a --remotetokenaddress 0xa284Ec8049A6360B9A5990f12d472fd385680f50 --safeaddress 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 --network sepolia

2025-05-15T18:26:24.859Z info: Configuring pool at address: 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084 for remote chain baseSepolia
2025-05-15T18:26:24.860Z info: Remote chain selector: 10344971235874465080
2025-05-15T18:26:24.860Z info: Remote pool addresses: 0xa5FAe80F8986d7000610E1ea857ce2981C44140a
2025-05-15T18:26:24.860Z info: Remote token address: 0xa284Ec8049A6360B9A5990f12d472fd385680f50
2025-05-15T18:26:28.628Z info: Safe transaction created for configuring the pool
2025-05-15T18:26:29.890Z info: Safe transaction signed by owner 1
2025-05-15T18:26:31.439Z info: Safe transaction signed by owner 2
2025-05-15T18:26:31.440Z info: Executing Safe transaction to configure pool 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084...
2025-05-15T18:26:34.351Z info: Executed Safe transaction
2025-05-15T18:26:34.352Z info: Waiting for 2 blocks for transaction 0xc0236bd7b1332731acc0c380918cb47b052e787f3cdf168f8b910ace8baa2ccc to be confirmed...
2025-05-15T18:26:52.574Z info: Transaction confirmed after 2 blocks.
2025-05-15T18:26:52.574Z info: Pool configured successfully for remote chain baseSepolia
Configure the token pool on BASE Sepolia (Replace 0xPoolAddress, 0xRemotePoolAddress, 0xRemoteTokenAddress, and 0xSafeAddress with the token pool address, remote token pool address, remote token address, and Safe smart account address, respectively):

copy to clipboard
npx hardhat applyChainUpdatesFromSafe --pooladdress 0xPoolAddress --remotechain sepolia  --remotepooladdresses 0xRemotePoolAddress --remotetokenaddress 0xRemoteTokenAddress --safeaddress 0xSafeAddress --network baseSepolia
Example output:

copy to clipboard
$ npx hardhat applyChainUpdatesFromSafe --pooladdress 0xa5FAe80F8986d7000610E1ea857ce2981C44140a --remotechain sepolia --remotepooladdresses 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084 --remotetokenaddress 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 --safeaddress 0xcba922b26e7382955576014b7F1313ED6eb28c05 --network baseSepolia

2025-05-15T18:27:55.354Z info: Configuring pool at address: 0xa5FAe80F8986d7000610E1ea857ce2981C44140a for remote chain sepolia
2025-05-15T18:27:55.355Z info: Remote chain selector: 16015286601757825753
2025-05-15T18:27:55.355Z info: Remote pool addresses: 0xfc21fe4Afef7fe0041BddaA1d0A794bfc7409084
2025-05-15T18:27:55.355Z info: Remote token address: 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21
2025-05-15T18:27:59.636Z info: Safe transaction created for configuring the pool
2025-05-15T18:28:01.411Z info: Safe transaction signed by owner 1
2025-05-15T18:28:03.668Z info: Safe transaction signed by owner 2
2025-05-15T18:28:03.668Z info: Executing Safe transaction to configure pool 0xa5FAe80F8986d7000610E1ea857ce2981C44140a...
2025-05-15T18:28:07.675Z info: Executed Safe transaction
2025-05-15T18:28:07.675Z info: Waiting for 2 blocks for transaction 0x0934a608774c5a34f89f286992fb5536b533b6541787196d05701db987200876 to be confirmed...
2025-05-15T18:28:12.741Z info: Transaction confirmed after 2 blocks.
2025-05-15T18:28:12.741Z info: Pool configured successfully for remote chain sepolia
Mint Tokens to an EOA using Safe
In this step, you will use the mintTokensFromSafe task to mint tokens to an EOA on Ethereum Sepolia. This process uses a Safe smart account to securely manage the minting process, ensuring that the transaction is signed by multiple owners off-chain before being executed on-chain. These tokens will be used for transfers through CCIP from Ethereum Sepolia to BASE Sepolia.

Below is an explanation of the parameters used during this task:

Parameter	Description	Required
tokenaddress	The address of the token contract from which the tokens will be minted.	Yes
amount	The amount of tokens to mint for each recipient address.	Yes
receiveraddresses	A comma-separated list of recipient addresses (EOAs) that will receive the minted tokens.	Yes
safeaddress	The address of the Safe smart account that will execute the transaction to mint tokens.	Yes
network	The blockchain on which the minting transaction will be executed. For example, sepolia for Ethereum Sepolia.	Yes
Mint tokens to an EOA on Ethereum Sepolia (Replace 0xTokenAddress, 0xSafeAddress, and 0xReceiverAddress with the token address, Safe smart account address, and recipient address, respectively):

copy to clipboard
npx hardhat mintTokensFromSafe \
  --tokenaddress 0xTokenAddress \
  --receiveraddresses 0xReceiverAddress \
  --amount 100000000000000000000 \
  --safeaddress 0xSafeAddress \
  --network sepolia
Example output:

copy to clipboard
$ npx hardhat mintTokensFromSafe --tokenaddress 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 --receiveraddresses 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA --amount 100000000000000000000 --safeaddress 0xcF30Ec01eA1d0240c92Dd5F81f2432D62BA6d4c2 --network sepolia

2025-05-15T18:34:28.118Z info: Connecting to token contract at 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21...
2025-05-15T18:34:28.477Z info: Minting 100000000000000000000 of BnMaem tokens to multiple addresses: 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T18:34:32.658Z info: Safe transaction created
2025-05-15T18:34:33.914Z info: Safe transaction signed by owner 1
2025-05-15T18:34:35.471Z info: Safe transaction signed by owner 2
2025-05-15T18:34:35.472Z info: Executing Safe transaction to mint tokens to multiple addresses...
2025-05-15T18:34:38.059Z info: Executed Safe transaction
2025-05-15T18:34:38.059Z info: Waiting for 2 blocks for transaction 0x7574289482a21a61db609aed7976e62b7c8f4ae315248444795b47bf004fb1db to be confirmed...
2025-05-15T18:35:02.406Z info: Transaction confirmed after 2 blocks.
2025-05-15T18:35:02.915Z info: Minted 100000000000000000000 of BnMaem tokens to 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA
2025-05-15T18:35:03.588Z info: Current balance of 0x8C244f0B2164E6A3BED74ab429B0ebd661Bb14CA is 200000000000000000000 BnMaem
Transfer Tokens
In this step, you will use the transferTokens task to transfer tokens from Ethereum Sepolia to BASE Sepolia using CCIP. You have two options for paying CCIP fees: using LINK tokens or native gas tokens.

You will interact with the IRouterClient contract, specifically calling the ccipSend() function to initiate the token transfer.

Below is an explanation of the parameters used during the token transfer process:

Parameter	Description	Default	Required
tokenaddress	The address of the token being transferred.	N/A	Yes
amount	The amount of tokens to transfer.	N/A	Yes
destinationchain	The blockchain to which the tokens will be transferred. Examples include baseSepolia, and sepolia.	N/A	Yes
receiveraddress	The address of the receiver on the destination blockchain.	N/A	Yes
fee	The type of fee used for the transfer, either LINK or native.	LINK	No
network	The blockchain on which the token transfer will be initiated. Examples include baseSepolia, and sepolia.	N/A	Yes
Pay fees in LINK
Call the CCIP Router to transfer tokens from Ethereum Sepolia to BASE Sepolia, paying the CCIP fees in LINK tokens. Replace the token address, amount, receiver address, and blockchain with the appropriate values:

copy to clipboard
npx hardhat transferTokens --tokenaddress 0xTokenAddress --amount 2000000000000000000 --destinationchain baseSepolia --receiveraddress 0xReceiverAddress --fee LINK --network sepolia
Example output:

copy to clipboard
$ npx hardhat transferTokens --tokenaddress 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 --amount 2000000000000000000 --destinationchain baseSepolia --receiveraddress 0xA028Cedc47485aB2F1230551E4f3a6871B764263 --fee LINK --network sepolia

2025-05-15T18:39:49.001Z info: Estimated fees: 42779379610026734
2025-05-15T18:39:49.004Z info: Approving 2000000000000000000 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 to 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
2025-05-15T18:40:19.643Z info: Approving 42779379610026734 LINK to 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
2025-05-15T18:40:36.645Z info: Transferring 2000000000000000000 of 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 to 0xA028Cedc47485aB2F1230551E4f3a6871B764263 on chain baseSepolia with 42779379610026734 of LINK as fees
2025-05-15T18:41:07.957Z info: Transaction hash: 0xa3dfe6cdd6793793ff8b954907eeba0e74c3083f0531f53172d4923ce90f1206
2025-05-15T18:41:07.976Z warn: Unable to parse the event logs corresponding to the transaction 0xa3dfe6cdd6793793ff8b954907eeba0e74c3083f0531f53172d4923ce90f1206
2025-05-15T18:41:07.977Z info: Check status of message on https://ccip.chain.link/tx/0xa3dfe6cdd6793793ff8b954907eeba0e74c3083f0531f53172d4923ce90f1206
You can check the status of the message on the Chainlink CCIP Explorer by visiting the provided URL. In this example, the message ID is 0x706c9057d25c69c9e1191a5a86b07a2156ef78bc7eaff6334c02dad5e905a9fb.

Pay fees in native gas tokens
Call the CCIP Router to transfer tokens from Ethereum Sepolia to BASE Sepolia, paying the CCIP fees in native gas tokens. Replace the token address, amount, receiver address, and blockchain with the appropriate values:

copy to clipboard
npx hardhat transferTokens --tokenaddress 0xTokenAddress --amount 2000000000000000000 --destinationchain baseSepolia --receiveraddress 0xReceiverAddress --fee native --network sepolia
Example output:

copy to clipboard
$ npx hardhat transferTokens --tokenaddress 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 --amount 2000000000000000000 --destinationchain baseSepolia --receiveraddress 0xA028Cedc47485aB2F1230551E4f3a6871B764263 --fee native --network sepolia

2025-05-15T18:43:46.493Z info: Estimated fees: 289689740371171
2025-05-15T18:43:46.495Z info: Approving 2000000000000000000 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 to 0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
2025-05-15T18:44:17.706Z info: Transferring 2000000000000000000 of 0x6BfD1AD6b17Fd27Fb1c7eAcc0cB4Aa023411fF21 to 0xA028Cedc47485aB2F1230551E4f3a6871B764263 on chain baseSepolia with 289689740371171 of native token as fees
2025-05-15T18:44:37.382Z info: Transaction hash: 0xbca99a8f7e052bb1486e6323be17cca7081bd16dc8dbcf168a2aa6c32a48f6a5
2025-05-15T18:44:37.396Z warn: Unable to parse the event logs corresponding to the transaction 0xbca99a8f7e052bb1486e6323be17cca7081bd16dc8dbcf168a2aa6c32a48f6a5
2025-05-15T18:44:37.397Z info: Check status of message on https://ccip.chain.link/tx/0xbca99a8f7e052bb1486e6323be17cca7081bd16dc8dbcf168a2aa6c32a48f6a5
You can check the status of the message on the Chainlink CCIP Explorer by visiting the provided URL. In this example, the message ID is 0xac612ebbbdd36bbfb7f577ddb0258d4642fa7e0ad1063b40143875fc59555396.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



Chainlink Local provides a comprehensive set of tools and libraries to test your smart contracts with CCIP locally. By using Chainlink Local, you can quickly set up a local testing environment, simulate Chainlink services, and debug your contracts before deploying them to actual testnets.

Why Use Chainlink Local?
Testing your smart contracts locally can save you a significant amount of time and effort. With Chainlink Local, you can:

Quickly identify and fix issues: Debug your contracts in a controlled environment before deploying them to testnets.
Save time and resources: Reduce the need for repeated deployments to testnets, speeding up the development process.
Guides for Different Environments
Foundry
For Foundry users, the following guides will help you set up and test your CCIP smart contracts locally:

Foundry Guides for Chainlink Local

Hardhat
For Hardhat users, the following guides provide step-by-step instructions to integrate and test CCIP smart contracts locally:

Hardhat Guides for Chainlink Local

RemixIDE
For users who prefer RemixIDE, these guides will assist you in setting up and testing your CCIP smart contracts locally within the Remix environment:

RemixIDE Guides for Chainlink Local



USDC is a digital dollar backed 100% and is always redeemable 1:1 for US dollars. The stablecoin is issued by Circle on multiple blockchain platforms.

This guide will first explain how Chainlink CCIP enables native USDC transfers when both the source and destination blockchains support Circle's Cross-Chain Transfer Protocol (CCTP).

Additionally, it will outline how CCIP also supports transferring Bridged USDC on blockchains that are not CCTP-enabled, allowing projects to later migrate to CCTP-enabled transfers if approved by Circle.

The hands-on tutorial at the end demonstrates how to use Chainlink CCIP to transfer USDC and arbitrary data from a smart contract on Avalanche Fuji to a smart contract on Ethereum Sepolia.

Note: In addition to programmable token transfers, you can also use CCIP to transfer USDC tokens without data. Check the Mainnets and Testnets configuration pages to learn on which blockchains CCIP supports USDC transfers.

Architecture
Native USDC vs. Bridged USDC
New blockchains frequently encounter the cold start problema scarcity of initial liquidity and limited user adoption that hampers the development and functionality of decentralized applications (dApps). Without sufficient stablecoin liquidity, essential use cases such as borrowing, lending, and trading remain constrained.

To overcome this challenge, Circle introduced the Bridged USDC Standard. This standard facilitates the seamless issuance of Bridged USDC on any EVM-compatible blockchain, enabling third-party teams to deploy USDC without awaiting native support from Circle. By standardizing bridged token issuance, Circle aims to:

Reduce Liquidity Fragmentation: Ensure a unified and efficient USDC supply across multiple blockchains.
Enhance User Experience: Minimize complexities and inconsistencies in managing multiple bridged USDC versions.
Facilitate Seamless Upgrades: Enable projects to transition smoothly to Native USDC once their blockchain is approved for native issuance via the Cross-Chain Transfer Protocol (CCTP).
Projects using Bridged USDC can easily migrate to Native USDC once their blockchain is approved for CCTP by Circle. This migration ensures that user balances, contract addresses, and integrations remain intact, eliminating the need for complex token swaps or liquidity migrations. For more detailed information, refer to Circle's Bridged USDC Standard.

How CCIP Works with USDC
Chainlink CCIP maintains a consistent API regardless of whether the transfer involves Native USDC or Bridged USDC. Here's how it operates in both scenarios:

The sender has to interact with the CCIP router to initiate a cross-chain transaction, similar to the process for any other token transfers. See the Transfer Tokens guide to learn more.
The process uses the same onchain components including the Router, OnRamp, Commit Store, OffRamp, and Token Pool.
The process uses the same offchain components including the Committing DON, Executing DON, and the Risk Management Network.
USDC transfers also benefit from CCIP additional security provided by the Risk Management Network.
Native USDC (CCTP-enabled)
The diagram below shows that the USDC token pools and Executing DON handle the integration with Circle's contracts and offchain CCTP Attestation API. As with any other supported ERC-20 token, USDC has a linked token pool on each supported blockchain to facilitate OnRamp and OffRamp operations. To learn more about these components, read the architecture page.

Chainlink CCIP Detailed Architecture for usdc
The following describes the operational process:

On the source blockchain:
When the sender initiates a transfer of USDC, the USDC token pool interacts with CCTP's contract to burn USDC tokens and specifies the USDC token pool address on the destination blockchain as the authorized caller to mint them.
CCTP burns the specified USDC tokens and emits an associated CCTP event.
Offchain:
The Circle attestation service listens to CCTP events on the source blockchain.
The CCIP Executing DON listens to relevant CCTP events on the source blockchain. When it captures such an event, it calls the Circle Attestation service API to request an attestation. An attestation is a signed authorization to mint the specified amount of USDC on the destination blockchain.
On the destination blockchain:
The Executing DON provides the attestation to the OffRamp contract.
The OffRamp contract calls the USDC token pool with the USDC amount to be minted, the Receiver address, and the Circle attestation.
The USDC token pool calls the CCTP contract. The CCTP contract verifies the attestation signature before minting the specified USDC amount into the Receiver.
If there is data in the CCIP message and the Receiver is not an EOA, then the OffRamp contract transmits the CCIP message via the Router contract to the Receiver.
Bridged USDC (non-CCTP-enabled)
note
note

Are you a blockchain team interested in having CCIP support Bridged USDC on your network? If your implementation follows the Circle Bridged USDC Standard, use this form to discuss integration options.

To facilitate USDC transfers between a blockchain that issues native USDC and another that only supports Bridged USDC, Chainlink CCIP employs the Lock and Mint mechanism. This approach ensures that each Bridged USDC token on the destination blockchain is fully backed by an equivalent amount of native USDC locked on the source blockchain. Accounting for Non-CCTP-Enabled USDC is isolated on a per-blockchain basis for security and risk mitigation.

Lock native USDC on Source: The Lock and Release token pool locks the specified USDC tokens.
Mint Bridged USDC on Destination: This Bridged USDC serves as a proxy for the original USDC, enabling liquidity and user adoption without direct integration with CCTP. A Burn and Mint token pool is recommended for the Destination Chain; it will mint Bridged USDC for incoming transfers and burn Bridged USDC for outgoing transfers. Other token pools are also supported, depending on the preferences and constraints of the Destination Chain.
Example
In this tutorial, you will learn how to send USDC tokens from a smart contract on Avalanche Fuji to a smart contract on Ethereum Sepolia using Chainlink CCIP and pay CCIP fees in LINK tokens. The process uses the following steps:

Transfer USDC and Data: Initiate a transfer of USDC tokens and associated data from the Sender contract on Avalanche Fuji. The data includes the required arguments and the signature of the stake function from the Staker contract.
Receive and Stake: The Receiver contract on Ethereum Sepolia receives the tokens and data. Then, it uses this data to make a low-level call to the Staker contract, executing the stake function to stake USDC on behalf of a beneficiary.
Redeem Staked Tokens: The beneficiary can redeem the staked tokens for USDC later.
The purpose of including the function signature and arguments in the data is to demonstrate how arbitrary data can support a variety of scenarios and use cases. By sending specific instructions within the data, you can define various interactions between smart contracts across different blockchain networks and make your decentralized application more flexible and powerful.

Chainlink CCIP usdc tutorial
note
note

After you followed the tutorial:

You can read the Explanation section to understand the smart contracts' logic and how they interact with CCIP.
Explore the CCIP USDC masterclass to find other examples of cross-chain transfers with USDC.
Before you begin
You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
Your account must have some AVAX and LINK tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia. You can use the Chainlink faucet to acquire testnet tokens.
Check the CCIP Directory to confirm that USDC are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.
Use the Circle faucet to acquire USDC tokens on Avalanche Fuji.
Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide for funding your contract with any ERC-20 tokens as long as they appear in the list of tokens in MetaMask.
Tutorial
Deploy your contracts
Deploy the Sender contract on Avalanche Fuji:

Open the Sender contract in Remix.

Compile your contract.

Deploy, fund your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.

Fill in your blockchain's router, LINK, and USDC contract addresses. The router and USDC addresses can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji, the addresses are:

Router address: 
0xf694e193200268f9a4868e4aa017a0118c9a8177
Copy to clipboard
LINK contract address: 
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Copy to clipboard
USDC contract address: 
0x5425890298aed601595a70AB815c96711a31Bc65
Copy to clipboard
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.

Open MetaMask and fund your contract with USDC tokens. You can transfer 
1
Copy to clipboard
 USDC to your contract.

Fund your contract with LINK tokens. You can transfer 
70
Copy to clipboard
 LINK to your contract. In this example, LINK is used to pay the CCIP fees.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this tutorial, you can get additional testnet LINK from faucets.chain.link or use a supported testnet other than Sepolia.

Deploy the Staker and Receiver contracts on Ethereum Sepolia. Configure the Receiver contract to receive CCIP messages from the Sender contract:

Deploy the Staker contract:

Open MetaMask and select the network Ethereum Sepolia.

Open the Staker contract in Remix.

Compile your contract.

In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.

Fill in the usdc contract address. The usdc contract address can be found on the CCIP Directory. For Ethereum Sepolia, the usdc contract address is:

0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238
Copy to clipboard
.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list.

Note your contract address.

Deploy the Receiver contract:

Open the Receiver contract in Remix.

Compile your contract.

In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask and that you are still connected to Ethereum Sepolia.

Fill in your blockchain's router, LINK, and Staker contract addresses. The router and usdc addresses can be found on the CCIP Directory and the Staker contract address from the previous step. For Ethereum Sepolia, the addresses are:

Router address: 
0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
Copy to clipboard
USDC contract address: 
0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238
Copy to clipboard
Staker address: Copied from the previous step
Configure the Receiver contract to receive CCIP messages from the Sender contract:

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your Receiver contract deployed on Ethereum Sepolia.

Fill in the arguments of the setSenderForSourceChain function:


Argument	Value and Description
_sourceChainSelector	
14767482510784806043
Copy to clipboard

The chain selector of Avalanche Fuji. You can find it on the CCIP Directory.
_sender	Your sender contract address at Avalanche Fuji.
The sender contract address.
Click on transact and confirm the transaction on MetaMask.

Configure the Sender contract on Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your Sender contract deployed on Avalanche Fuji.

Fill in the arguments of the setReceiverForDestinationChain function:


Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

The chain selector of Ethereum Sepolia. You can find it on the CCIP Directory.
_receiver	Your receiver contract address at Ethereum Sepolia.
The receiver contract address.
Fill in the arguments of the setGasLimitForDestinationChain: function:


Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

The chain selector of Ethereum Sepolia. You can find it on the CCIP Directory.
_gasLimit	
200000
Copy to clipboard

The gas limit for the execution of the CCIP message on the destination chain.
At this point:

You have one sender contract on Avalanche Fuji, one staker contract and one receiver contract on Ethereum Sepolia.
You enabled the sender contract to send messages to the receiver contract on Ethereum Sepolia.
You set the gas limit for the execution of the CCIP message on Ethereum Sepolia.
You enabled the receiver contract to receive messages from the sender contract on Avalanche Fuji.
You funded the sender contract with USDC and LINK tokens on Avalanche Fuji.
Transfer and Receive tokens and data and pay in LINK
You will transfer 1 USDC and arbitrary data, which contains the encoded stake function name and parameters for calling Staker's stake function on the destination chain. The parameters contain the amount of staked tokens and the beneficiary address. The CCIP fees for using CCIP will be paid in LINK.

Transfer tokens and data from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:

Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory.
_beneficiary	The beneficiary of the Staker tokens on Ethereum Sepolia. You can set your own EOA (Externally Owned Account) so you can redeem the Staker tokens in exchange for USDC tokens.
_amount	
1000000
Copy to clipboard

The token amount (1 USDC).
Click on transact and confirm the transaction on MetaMask.

After the transaction is successful, record the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash.


Chainlink CCIP Explorer transaction details
The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0xcb0fad9eec6664ad959f145cc4eb023924faded08baefc29952205ee37da7f13.


Chainlink CCIP Explorer transaction details success
Check the balance of the beneficiary on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your Staker contract deployed on Ethereum Sepolia.

Call the balanceOf function with the beneficiary address.


Chainlink CCIP Staker tokens balance
Notice that the balance of the beneficiary is 1,000,000 Staker tokens. The Staker contract has the same number of decimals as the USDC token, which is 6. This means the beneficiary has 1 USDC staked and can redeem it by providing the same amount of Staker tokens.

Redeem the staked tokens:

Open MetaMask and make sure the network is Ethereum Sepolia.

Make sure you are connected with the beneficiary account.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your Staker contract deployed on Ethereum Sepolia.

Call the redeem function with the amount of Staker tokens to redeem. In this example, the beneficiary will redeem 1,000,000 Staker tokens. When confirming, MetaMask will confirm that you will transfer the Staker tokens in exchange for USDC tokens.


Chainlink CCIP Avalanche message details
Confirm the transaction on MetaMask. After the transaction is successful, the beneficiary will receive 1 USDC tokens.


Chainlink CCIP Avalanche message details
Explanation
note
Integrate Chainlink CCIP v1.6.0 into your project

npmyarnfoundry
If you use NPM, install the @chainlink/contracts-ccip NPM package:

copy to clipboard
npm install @chainlink/contracts-ccip@1.6.0
The smart contracts featured in this tutorial are designed to interact with CCIP to send and receive USDC tokens and data across different blockchains. The contract code contains supporting comments clarifying the functions, events, and underlying logic. We will explain the Sender, Staker, and Receiver contracts further.

Sender Contract
copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

interface IStaker {
    function stake(address beneficiary, uint256 amount) external;

    function redeem() external;
}

/// @title - A simple messenger contract for transferring tokens to a receiver  that calls a staker contract.
contract Sender is OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error InvalidRouter(); // Used when the router address is 0
    error InvalidLinkToken(); // Used when the link token address is 0
    error InvalidUsdcToken(); // Used when the usdc token address is 0
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance to cover the fees.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error InvalidDestinationChain(); // Used when the destination chain selector is 0.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.
    error NoReceiverOnDestinationChain(uint64 destinationChainSelector); // Used when the receiver address is 0 for a given destination chain.
    error AmountIsZero(); // Used if the amount to transfer is 0.
    error InvalidGasLimit(); // Used if the gas limit is 0.
    error NoGasLimitOnDestinationChain(uint64 destinationChainSelector); // Used when the gas limit is 0.

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address indexed receiver, // The address of the receiver contract on the destination chain.
        address beneficiary, // The beneficiary of the staked tokens on the destination chain.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    IRouterClient private immutable i_router;
    IERC20 private immutable i_linkToken;
    IERC20 private immutable i_usdcToken;

    // Mapping to keep track of the receiver contract per destination chain.
    mapping(uint64 => address) public s_receivers;
    // Mapping to store the gas limit per destination chain.
    mapping(uint64 => uint256) public s_gasLimits;

    modifier validateDestinationChain(uint64 _destinationChainSelector) {
        if (_destinationChainSelector == 0) revert InvalidDestinationChain();
        _;
    }

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    /// @param _usdcToken The address of the usdc contract.
    constructor(address _router, address _link, address _usdcToken) {
        if (_router == address(0)) revert InvalidRouter();
        if (_link == address(0)) revert InvalidLinkToken();
        if (_usdcToken == address(0)) revert InvalidUsdcToken();
        i_router = IRouterClient(_router);
        i_linkToken = IERC20(_link);
        i_usdcToken = IERC20(_usdcToken);
    }

    /// @dev Set the receiver contract for a given destination chain.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain.
    /// @param _receiver The receiver contract on the destination chain .
    function setReceiverForDestinationChain(
        uint64 _destinationChainSelector,
        address _receiver
    ) external onlyOwner validateDestinationChain(_destinationChainSelector) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        s_receivers[_destinationChainSelector] = _receiver;
    }

    /// @dev Set the gas limit for a given destination chain.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain.
    /// @param _gasLimit The gas limit on the destination chain .
    function setGasLimitForDestinationChain(
        uint64 _destinationChainSelector,
        uint256 _gasLimit
    ) external onlyOwner validateDestinationChain(_destinationChainSelector) {
        if (_gasLimit == 0) revert InvalidGasLimit();
        s_gasLimits[_destinationChainSelector] = _gasLimit;
    }

    /// @dev Delete the receiver contract for a given destination chain.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain.
    function deleteReceiverForDestinationChain(
        uint64 _destinationChainSelector
    ) external onlyOwner validateDestinationChain(_destinationChainSelector) {
        if (s_receivers[_destinationChainSelector] == address(0))
            revert NoReceiverOnDestinationChain(_destinationChainSelector);
        delete s_receivers[_destinationChainSelector];
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK to pay for CCIP fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _beneficiary The address of the beneficiary of the staked tokens on the destination blockchain.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _beneficiary,
        uint256 _amount
    )
        external
        onlyOwner
        validateDestinationChain(_destinationChainSelector)
        returns (bytes32 messageId)
    {
        address receiver = s_receivers[_destinationChainSelector];
        if (receiver == address(0))
            revert NoReceiverOnDestinationChain(_destinationChainSelector);
        if (_amount == 0) revert AmountIsZero();
        uint256 gasLimit = s_gasLimits[_destinationChainSelector];
        if (gasLimit == 0)
            revert NoGasLimitOnDestinationChain(_destinationChainSelector);
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(linkToken) means fees are paid in LINK
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: address(i_usdcToken),
            amount: _amount
        });
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({
            receiver: abi.encode(receiver), // ABI-encoded receiver address
            data: abi.encodeWithSelector(
                IStaker.stake.selector,
                _beneficiary,
                _amount
            ), // Encode the function selector and the arguments of the stake function
            tokenAmounts: tokenAmounts, // The amount and type of token being transferred
            extraArgs: Client._argsToBytes(
                // Additional arguments, setting gas limit and allowing out-of-order execution.
                // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                Client.GenericExtraArgsV2({
                    gasLimit: gasLimit, // Gas limit for the callback on the destination chain
                    allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                })
            ),
            // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
            feeToken: address(i_linkToken)
        });

        // Get the fee required to send the CCIP message
        uint256 fees = i_router.getFee(
            _destinationChainSelector,
            evm2AnyMessage
        );

        if (fees > i_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(i_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        i_linkToken.approve(address(i_router), fees);

        // approve the Router to spend usdc tokens on contract's behalf. It will spend the amount of the given token
        i_usdcToken.approve(address(i_router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = i_router.ccipSend(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            receiver,
            _beneficiary,
            address(i_usdcToken),
            _amount,
            address(i_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /// @notice Allows the owner of the contract to withdraw all LINK tokens in the contract and transfer them to a beneficiary.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    function withdrawLinkToken(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = i_linkToken.balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        i_linkToken.safeTransfer(_beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all usdc tokens in the contract and transfer them to a beneficiary.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    function withdrawUsdcToken(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = i_usdcToken.balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        i_usdcToken.safeTransfer(_beneficiary, amount);
    }
}
Open in Remix
What is Remix?
The Sender contract is responsible for initiating the transfer of USDC tokens and data. Here's how it works:

Initializing the contract:

When deploying the contract, you define the router address, LINK contract address, and USDC contract address.
These addresses are essential for interacting with the CCIP router and handling token transfers.
sendMessagePayLINK function:

This function sends USDC tokens, the encoded function signature of the stake function, and arguments (beneficiary address and amount) to the Receiver contract on the destination chain.
Constructs a CCIP message using the EVM2AnyMessage struct.
Computes the necessary fees using the router's getFee function.
Ensures the contract has enough LINK to cover the fees and approves the router transfer of LINK on its behalf.
Dispatches the CCIP message to the destination chain by executing the router's ccipSend function.
Emits a MessageSent event.
caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

Staker Contract
copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {ERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/ERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

interface IStaker {
    function stake(address beneficiary, uint256 amount) external;

    function redeem() external;
}

/// @title - A simple Staker contract for staking usc tokens and redeeming the staker contracts
contract Staker is IStaker, ERC20 {
    using SafeERC20 for ERC20;

    error InvalidUsdcToken(); // Used when the usdc token address is 0
    error InvalidNumberOfDecimals(); // Used when the number of decimals is 0
    error InvalidBeneficiary(); // Used when the beneficiary address is 0
    error InvalidAmount(); // Used when the amount is 0
    error NothingToRedeem(); // Used when the balance of Staker tokens is 0

    event UsdcStaked(address indexed beneficiary, uint256 amount);
    event UsdcRedeemed(address indexed beneficiary, uint256 amount);

    ERC20 private immutable i_usdcToken;
    uint8 private immutable i_decimals;

    /// @notice Constructor initializes the contract with the usdc token address.
    /// @param _usdcToken The address of the usdc contract.
    constructor(address _usdcToken) ERC20("Simple Staker", "STK") {
        if (_usdcToken == address(0)) revert InvalidUsdcToken();
        i_usdcToken = ERC20(_usdcToken);
        i_decimals = i_usdcToken.decimals();
        if (i_decimals == 0) revert InvalidNumberOfDecimals();
    }

    function stake(address _beneficiary, uint256 _amount) external {
        if (_beneficiary == address(0)) revert InvalidBeneficiary();
        if (_amount == 0) revert InvalidAmount();

        i_usdcToken.safeTransferFrom(msg.sender, address(this), _amount);
        _mint(_beneficiary, _amount);
        emit UsdcStaked(_beneficiary, _amount);
    }

    function redeem() external {
        uint256 balance = balanceOf(msg.sender);
        if (balance == 0) revert NothingToRedeem();
        _burn(msg.sender, balance);
        i_usdcToken.safeTransfer(msg.sender, balance);
        emit UsdcRedeemed(msg.sender, balance);
    }

    function decimals() public view override returns (uint8) {
        return i_decimals;
    }
}
Open in Remix
What is Remix?
The Staker contract manages the staking and redemption of USDC tokens. Here's how it works:

Initializing the contract:

When deploying the contract, you define the USDC token address.
This address is essential for interacting with the USDC token contract.
stake function:

Allows staking of USDC tokens on behalf of a beneficiary.
Transfers USDC from the caller (msg.sender) to the contract, then mints an equivalent amount of staking tokens to the beneficiary.
redeem function:

Allows beneficiaries to redeem their staked tokens for USDC.
Burns the staked tokens and transfers the equivalent USDC to the beneficiary.
Receiver Contract
copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";
import {EnumerableMap} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableMap.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple receiver contract for receiving usdc tokens then calling a staking contract.
contract Receiver is CCIPReceiver, OwnerIsCreator {
    using SafeERC20 for IERC20;
    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;

    error InvalidUsdcToken(); // Used when the usdc token address is 0
    error InvalidStaker(); // Used when the staker address is 0
    error InvalidSourceChain(); // Used when the source chain is 0
    error InvalidSenderAddress(); // Used when the sender address is 0
    error NoSenderOnSourceChain(uint64 sourceChainSelector); // Used when there is no sender for a given source chain
    error WrongSenderForSourceChain(uint64 sourceChainSelector); // Used when the sender contract is not the correct one
    error OnlySelf(); // Used when a function is called outside of the contract itself
    error WrongReceivedToken(address usdcToken, address receivedToken); // Used if the received token is different than usdc token
    error CallToStakerFailed(); // Used when the call to the stake function of the staker contract is not successful
    error NoReturnDataExpected(); // Used if the call to the stake function of the staker contract returns data. This is not expected
    error MessageNotFailed(bytes32 messageId); // Used if you try to retry a message that has no failed

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address indexed sender, // The address of the sender from the source chain.
        bytes data, // The data that was received.
        address token, // The token address that was transferred.
        uint256 tokenAmount // The token amount that was transferred.
    );

    event MessageFailed(bytes32 indexed messageId, bytes reason);
    event MessageRecovered(bytes32 indexed messageId);

    // Example error code, could have many different error codes.
    enum ErrorCode {
        // RESOLVED is first so that the default value is resolved.
        RESOLVED,
        // Could have any number of error codes here.
        FAILED
    }

    struct FailedMessage {
        bytes32 messageId;
        ErrorCode errorCode;
    }

    IERC20 private immutable i_usdcToken;
    address private immutable i_staker;

    // Mapping to keep track of the sender contract per source chain.
    mapping(uint64 => address) public s_senders;

    // The message contents of failed messages are stored here.
    mapping(bytes32 => Client.Any2EVMMessage) public s_messageContents;

    // Contains failed messages and their state.
    EnumerableMap.Bytes32ToUintMap internal s_failedMessages;

    modifier validateSourceChain(uint64 _sourceChainSelector) {
        if (_sourceChainSelector == 0) revert InvalidSourceChain();
        _;
    }

    /// @dev Modifier to allow only the contract itself to execute a function.
    /// Throws an exception if called by any account other than the contract itself.
    modifier onlySelf() {
        if (msg.sender != address(this)) revert OnlySelf();
        _;
    }

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _usdcToken The address of the usdc contract.
    /// @param _staker The address of the staker contract.
    constructor(
        address _router,
        address _usdcToken,
        address _staker
    ) CCIPReceiver(_router) {
        if (_usdcToken == address(0)) revert InvalidUsdcToken();
        if (_staker == address(0)) revert InvalidStaker();
        i_usdcToken = IERC20(_usdcToken);
        i_staker = _staker;
        i_usdcToken.safeApprove(_staker, type(uint256).max);
    }

    /// @dev Set the sender contract for a given source chain.
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain.
    /// @param _sender The sender contract on the source chain .
    function setSenderForSourceChain(
        uint64 _sourceChainSelector,
        address _sender
    ) external onlyOwner validateSourceChain(_sourceChainSelector) {
        if (_sender == address(0)) revert InvalidSenderAddress();
        s_senders[_sourceChainSelector] = _sender;
    }

    /// @dev Delete the sender contract for a given source chain.
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain.
    function deleteSenderForSourceChain(
        uint64 _sourceChainSelector
    ) external onlyOwner validateSourceChain(_sourceChainSelector) {
        if (s_senders[_sourceChainSelector] == address(0))
            revert NoSenderOnSourceChain(_sourceChainSelector);
        delete s_senders[_sourceChainSelector];
    }

    /// @notice The entrypoint for the CCIP router to call. This function should
    /// never revert, all errors should be handled internally in this contract.
    /// @param any2EvmMessage The message to process.
    /// @dev Extremely important to ensure only router calls this.
    function ccipReceive(
        Client.Any2EVMMessage calldata any2EvmMessage
    ) external override onlyRouter {
        // validate the sender contract
        if (
            abi.decode(any2EvmMessage.sender, (address)) !=
            s_senders[any2EvmMessage.sourceChainSelector]
        ) revert WrongSenderForSourceChain(any2EvmMessage.sourceChainSelector);
        /* solhint-disable no-empty-blocks */
        try this.processMessage(any2EvmMessage) {
            // Intentionally empty in this example; no action needed if processMessage succeeds
        } catch (bytes memory err) {
            // Could set different error codes based on the caught error. Each could be
            // handled differently.
            s_failedMessages.set(
                any2EvmMessage.messageId,
                uint256(ErrorCode.FAILED)
            );
            s_messageContents[any2EvmMessage.messageId] = any2EvmMessage;
            // Don't revert so CCIP doesn't revert. Emit event instead.
            // The message can be retried later without having to do manual execution of CCIP.
            emit MessageFailed(any2EvmMessage.messageId, err);
            return;
        }
    }

    /// @notice Serves as the entry point for this contract to process incoming messages.
    /// @param any2EvmMessage Received CCIP message.
    /// @dev Transfers specified token amounts to the owner of this contract. This function
    /// must be external because of the  try/catch for error handling.
    /// It uses the `onlySelf`: can only be called from the contract.
    function processMessage(
        Client.Any2EVMMessage calldata any2EvmMessage
    ) external onlySelf {
        _ccipReceive(any2EvmMessage); // process the message - may revert
    }

    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    ) internal override {
        if (any2EvmMessage.destTokenAmounts[0].token != address(i_usdcToken))
            revert WrongReceivedToken(
                address(i_usdcToken),
                any2EvmMessage.destTokenAmounts[0].token
            );

        (bool success, bytes memory returnData) = i_staker.call(
            any2EvmMessage.data
        ); // low level call to the staker contract using the encoded function selector and arguments
        if (!success) revert CallToStakerFailed();
        if (returnData.length > 0) revert NoReturnDataExpected();
        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            any2EvmMessage.data, // received data
            any2EvmMessage.destTokenAmounts[0].token,
            any2EvmMessage.destTokenAmounts[0].amount
        );
    }

    /// @notice Allows the owner to retry a failed message in order to unblock the associated tokens.
    /// @param messageId The unique identifier of the failed message.
    /// @param beneficiary The address to which the tokens will be sent.
    /// @dev This function is only callable by the contract owner. It changes the status of the message
    /// from 'failed' to 'resolved' to prevent reentry and multiple retries of the same message.
    function retryFailedMessage(
        bytes32 messageId,
        address beneficiary
    ) external onlyOwner {
        // Check if the message has failed; if not, revert the transaction.
        if (s_failedMessages.get(messageId) != uint256(ErrorCode.FAILED))
            revert MessageNotFailed(messageId);

        // Set the error code to RESOLVED to disallow reentry and multiple retries of the same failed message.
        s_failedMessages.set(messageId, uint256(ErrorCode.RESOLVED));

        // Retrieve the content of the failed message.
        Client.Any2EVMMessage memory message = s_messageContents[messageId];

        // This example expects one token to have been sent.
        // Transfer the associated tokens to the specified receiver as an escape hatch.
        IERC20(message.destTokenAmounts[0].token).safeTransfer(
            beneficiary,
            message.destTokenAmounts[0].amount
        );

        // Emit an event indicating that the message has been recovered.
        emit MessageRecovered(messageId);
    }

    /// @notice Retrieves a paginated list of failed messages.
    /// @dev This function returns a subset of failed messages defined by `offset` and `limit` parameters. It ensures that the pagination parameters are within the bounds of the available data set.
    /// @param offset The index of the first failed message to return, enabling pagination by skipping a specified number of messages from the start of the dataset.
    /// @param limit The maximum number of failed messages to return, restricting the size of the returned array.
    /// @return failedMessages An array of `FailedMessage` struct, each containing a `messageId` and an `errorCode` (RESOLVED or FAILED), representing the requested subset of failed messages. The length of the returned array is determined by the `limit` and the total number of failed messages.
    function getFailedMessages(
        uint256 offset,
        uint256 limit
    ) external view returns (FailedMessage[] memory) {
        uint256 length = s_failedMessages.length();

        // Calculate the actual number of items to return (can't exceed total length or requested limit)
        uint256 returnLength = (offset + limit > length)
            ? length - offset
            : limit;
        FailedMessage[] memory failedMessages = new FailedMessage[](
            returnLength
        );

        // Adjust loop to respect pagination (start at offset, end at offset + limit or total length)
        for (uint256 i = 0; i < returnLength; i++) {
            (bytes32 messageId, uint256 errorCode) = s_failedMessages.at(
                offset + i
            );
            failedMessages[i] = FailedMessage(messageId, ErrorCode(errorCode));
        }
        return failedMessages;
    }
}
Open in Remix
What is Remix?
The Receiver contract handles incoming cross-chain messages, processes them, and interacts with the Staker contract to stake USDC on behalf of the beneficiary. Here's how it works:

Initializing the Contract:

When deploying the contract, you define the router address, USDC token address, and staker contract address.
These addresses are essential for interacting with the CCIP router, USDC token, and Staker contracts.
ccipReceive function:

The entry point for the CCIP router to deliver messages to the contract.
Validates the sender and processes the message, ensuring it comes from the correct sender contract on the source chain.
Processing Message:

Calls the processMessage function, which is external to leverage Solidity's try/catch error handling mechanism.
Inside processMessage, it calls the _ccipReceive function for further message processing.
_ccipReceive function:

Checks if the received token is USDC. If not, it reverts.
Makes a low-level call to the stake function of the Staker contract using the encoded function signature and arguments from the received data.
Emits a MessageReceived event upon successful processing.
Error Handling:

If an error occurs during processing, the catch block within ccipReceive is executed.
The messageId of the failed message is added to s_failedMessages, and the message content is stored in s_messageContents.
A MessageFailed event is emitted, allowing for later identification and reprocessing of failed messages.
retryFailedMessage function:

Allows the contract owner to retry a failed message and recover the associated tokens.
Updates the error code for the message to RESOLVED to prevent multiple retries.
Transfers the locked tokens associated with the failed message to the specified beneficiary as an escape hatch.
getFailedMessages function:

Retrieves a paginated list of failed messages for inspection.
caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



In this tutorial, you will use Chainlink CCIP to send data between smart contracts on different blockchains. First, you will pay for the CCIP fees on the source blockchain using LINK. Then, you will use the same contract to pay CCIP fees in native gas tokens. For example, you would use ETH on Ethereum or AVAX on Avalanche.

note
Node Operator Rewards

CCIP rewards the oracle node and Risk Management node operators in LINK.

Before you begin
You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
Your account must have some AVAX tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia.
Learn how to Acquire testnet LINK and Fund your contract with LINK.
Tutorial
note
Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local simulator, an installable package designed to simulate Chainlink CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite, enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your development process and validate your CCIP implementations effectively.

In this tutorial, you will send a string text between smart contracts on Avalanche Fuji and Ethereum Sepolia using CCIP. First, you will pay CCIP fees in LINK, then you will pay CCIP fees in native gas.

copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple messenger contract for sending/receiving string data across chains.
contract Messenger is CCIPReceiver, OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.
    error DestinationChainNotAllowlisted(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error SourceChainNotAllowlisted(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowlisted(address sender); // Used when the sender has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        string text, // The text being sent.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the CCIP message.
    );

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address sender, // The address of the sender from the source chain.
        string text // The text that was received.
    );

    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.
    string private s_lastReceivedText; // Store the last received text.

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowlisted(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowlisted(_sender);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain for transactions.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends data to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The text to be sent.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            address(s_linkToken)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > s_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        s_linkToken.approve(address(router), fees);

        // Send the CCIP message through the router and store the returned CCIP message ID
        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            address(s_linkToken),
            fees
        );

        // Return the CCIP message ID
        return messageId;
    }

    /// @notice Sends data to receiver on the destination chain.
    /// @notice Pay for fees in native gas.
    /// @dev Assumes your contract has sufficient native gas tokens.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The text to be sent.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayNative(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            address(0)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > address(this).balance)
            revert NotEnoughBalance(address(this).balance, fees);

        // Send the CCIP message through the router and store the returned CCIP message ID
        messageId = router.ccipSend{value: fees}(
            _destinationChainSelector,
            evm2AnyMessage
        );

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            address(0),
            fees
        );

        // Return the CCIP message ID
        return messageId;
    }

    /// handle a received message
    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    )
        internal
        override
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure source chain and sender are allowlisted
    {
        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId
        s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text

        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            abi.decode(any2EvmMessage.data, (string))
        );
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for sending a text.
    /// @param _receiver The address of the receiver.
    /// @param _text The string data to be sent.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        string calldata _text,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        return
            Client.EVM2AnyMessage({
                receiver: abi.encode(_receiver), // ABI-encoded receiver address
                data: abi.encode(_text), // ABI-encoded string
                tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array as no tokens are transferred
                extraArgs: Client._argsToBytes(
                    // Additional arguments, setting gas limit and allowing out-of-order execution.
                    // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                    // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                    // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                    Client.GenericExtraArgsV2({
                        gasLimit: 200_000, // Gas limit for the callback on the destination chain
                        allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                    })
                ),
                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
                feeToken: _feeTokenAddress
            });
    }

    /// @notice Fetches the details of the last received message.
    /// @return messageId The ID of the last received message.
    /// @return text The last received text.
    function getLastReceivedMessageDetails()
        external
        view
        returns (bytes32 messageId, string memory text)
    {
        return (s_lastReceivedMessageId, s_lastReceivedText);
    }

    /// @notice Fallback function to allow the contract to receive Ether.
    /// @dev This function has no function body, making it a default function for receiving Ether.
    /// It is automatically called when Ether is sent to the contract without any data.
    receive() external payable {}

    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.
    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.
    /// It should only be callable by the owner of the contract.
    /// @param _beneficiary The address to which the Ether should be sent.
    function withdraw(address _beneficiary) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = address(this).balance;

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        // Attempt to send the funds, capturing the success status and discarding any return data
        (bool sent, ) = _beneficiary.call{value: amount}("");

        // Revert if the send failed, with information about the attempted transfer
        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
Open in Remix
What is Remix?
Deploy your contracts
To use this contract:

Open the contract in Remix.

Compile your contract.

Deploy your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.
In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.
Fill in the router address and the link address for your network. You can find the router address on the CCIP Directory and the LINK token address on the LINK Token contracts page. For Avalanche Fuji:
The router address is 
0xF694E193200268f9a4868e4Aa017A0118C9a8177
Copy to clipboard
,
The LINK contract address is 
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Copy to clipboard
.
Click on transact. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.
Enable your contract to send CCIP messages to Ethereum Sepolia:
In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain with 
16015286601757825753
Copy to clipboard
 as the destination chain selector, and 
true
Copy to clipboard
 as allowed. Each chain selector is found on the CCIP Directory.
Deploy your receiver contract on Ethereum Sepolia and enable receiving messages from your sender contract:

Open MetaMask and select the network Ethereum Sepolia.
In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.
Fill in the router address and the LINK address for your network. You can find the router address on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Ethereum Sepolia:
The router address is 
0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
Copy to clipboard
,
The LINK contract address is 
0x779877A7B0D9E8603169DdbD7836e478b4624789
Copy to clipboard
.
Click on transact. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.
Enable your contract to receive CCIP messages from Avalanche Fuji:
In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSourceChain with 
14767482510784806043
Copy to clipboard
 as the source chain selector, and 
true
Copy to clipboard
 as allowed. Each chain selector is found on the CCIP Directory.
Enable your contract to receive CCIP messages from the contract that you deployed on Avalanche Fuji:
In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSender with the contract address of the contract that you deployed on Avalanche Fuji, and 
true
Copy to clipboard
 as allowed.
At this point, you have one sender contract on Avalanche Fuji and one receiver contract on Ethereum Sepolia. As security measures, you enabled the sender contract to send CCIP messages to Ethereum Sepolia and the receiver contract to receive CCIP messages from the sender and Avalanche Fuji. Note: Another security measure enforces that only the router can call the _ccipReceive function. Read the explanation section for more details.

Send data and pay in LINK
You will use CCIP to send a text. The CCIP fees for using CCIP will be paid in LINK. Read this explanation for a detailed description of the code example.

Open MetaMask and connect to Avalanche Fuji. Fund your contract with LINK tokens. You can transfer 
70
Copy to clipboard
 LINK to your contract. In this example, LINK is used to pay the CCIP fees.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK from faucets.chain.link or use a supported testnet other than Sepolia.

Send "Hello World!" from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:


Argument	Description	Value (Ethereum Sepolia)
_destinationChainSelector	CCIP Chain identifier of the target blockchain. You can find each network's chain selector on the CCIP Directory	
16015286601757825753
Copy to clipboard
_receiver	The destination smart contract address	Your deployed receiver contract address
_text	any string	
Hello World!
Copy to clipboard
Click on transact and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash.

The CCIP transaction is completed once the status is marked as "Success". Note: In this example, the CCIP message ID is 0x28a804fa891bde8fb4f6617931187e1033a128c014aa76465911613588bc306f.


Chainlink CCIP Explorer transaction success
Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails.


Chainlink CCIP Sepolia message details
Notice the received text is the one you sent, "Hello World!" and the message ID is the one you expect 0x28a804fa891bde8fb4f6617931187e1033a128c014aa76465911613588bc306f.

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to send data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

Send data and pay in native
You will use CCIP to send a text. The CCIP fees for using CCIP will be paid in native gas. Read this explanation for a detailed description of the code example.

Open MetaMask and connect to Avalanche Fuji. Fund your contract with AVAX. You can transfer 
1
Copy to clipboard
 AVAX to your contract. In this example, AVAX is used to pay the CCIP fees.

Send "Hello World!" from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayNative function:


Argument	Description	Value (Ethereum Sepolia)
_destinationChainSelector	CCIP Chain identifier of the target blockchain. You can find each network's chain selector on the CCIP Directory	
16015286601757825753
Copy to clipboard
_receiver	The destination smart contract address	Your deployed receiver contract address
_text	any string	
Hello World!
Copy to clipboard
Click on transact and confirm the transaction on MetaMask.

Once the transaction is successful, note the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash.


Chainlink CCIP Explorer transaction details
The CCIP transaction is completed once the status is marked as "Success". In this example, the CCIP message ID is 0xb8cb414128f440e115dcd5d6ead50e14d250f9a47577c38af4f70deb14191457. Note that CCIP fees are denominated in LINK. Even if CCIP fees are paid using native gas tokens, node operators will be paid in LINK.


Chainlink CCIP Explorer transaction success
Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails.


Chainlink CCIP Sepolia message details
Notice the received text is the one you sent, "Hello World!" and the message ID is the one you expect 0xb8cb414128f440e115dcd5d6ead50e14d250f9a47577c38af4f70deb14191457.

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to send data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

Explanation
note
Integrate Chainlink CCIP v1.6.0 into your project

npmyarnfoundry
If you use NPM, install the @chainlink/contracts-ccip NPM package:

copy to clipboard
npm install @chainlink/contracts-ccip@1.6.0
The smart contract featured in this tutorial is designed to interact with CCIP to send and receive messages. The contract code contains supporting comments clarifying the functions, events, and underlying logic. Here we will further explain initializing the contract and sending and receiving data.

Initializing of the contract
When deploying the contract, we define the router address and LINK contract address of the blockchain we deploy the contract on. Defining the router address is useful for the following:

Sender part:

Calls the router's getFee function to estimate the CCIP fees.
Calls the router's ccipSend function to send CCIP messages.
Receiver part:

The contract inherits from CCIPReceiver, which serves as a base contract for receiver contracts. This contract requires that child contracts implement the _ccipReceive function. _ccipReceive is called by the ccipReceive function, which ensures that only the router can deliver CCIP messages to the receiver contract.
Sending data and pay in LINK
The sendMessagePayLINK function undertakes five primary operations:

Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is encoded from a string to bytes using abi.encode.

The tokenAmounts is an empty EVMTokenAmount struct array as no tokens are transferred.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to 200000.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(linkToken) signifies payment in LINK.

caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

Computes the fees by invoking the router's getFee function.

Ensures your contract balance in LINK is enough to cover the fees.

Grants the router contract permission to deduct the fees from the contract's LINK balance.

Dispatches the CCIP message to the destination chain by executing the router's ccipSend function.

Note: As a security measure, the sendMessagePayLINK function is protected by the onlyAllowlistedDestinationChain, ensuring the contract owner has allowlisted a destination chain.

Sending data and pay in native
The sendMessagePayNative function undertakes four primary operations:

Call the _buildCCIPMessage private function to construct a CCIP-compatible message using the EVM2AnyMessage struct:

The _receiver address is encoded in bytes to accommodate non-EVM destination blockchains with distinct address formats. The encoding is achieved through abi.encode.

The data is encoded from a string to bytes using abi.encode.

The tokenAmounts is an empty EVMTokenAmount struct array as no tokens are transferred.

The extraArgs specifies the gasLimit for relaying the message to the recipient contract on the destination blockchain. In this example, the gasLimit is set to 200000.

The _feeTokenAddress designates the token address used for CCIP fees. Here, address(0) signifies payment in native gas tokens (ETH).

caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

Computes the fees by invoking the router's getFee function.

Ensures your contract balance in native gas is enough to cover the fees.

Dispatches the CCIP message to the destination chain by executing the router's ccipSend function. Note: msg.value is set because you pay in native gas.

Note: As a security measure, the sendMessagePayNative function is protected by the onlyAllowlistedDestinationChain, ensuring the contract owner has allowlisted a destination chain.

Receiving data
On the destination blockchain, the router invokes the ccipReceive function which expects an Any2EVMMessage struct that contains:

The CCIP messageId.
The sourceChainSelector.
The sender address in bytes format. Given that the sender is known to be a contract deployed on an EVM-compatible blockchain, the address is decoded from bytes to an Ethereum address using the ABI specifications.
The data, which is also in bytes format. Given a string is expected, the data is decoded from bytes to a string using the ABI specifications.
This example applies three important security measures:

_ccipReceive is called by the ccipReceive function, which ensures that only the router can deliver CCIP messages to the receiver contract. See the onlyRouter modifier for more information.
The modifier onlyAllowlisted ensures that only a call from an allowlisted source chain and sender is accepted.
caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.



This tutorial will teach you how to use Chainlink CCIP to send arbitrary data between smart contracts on different blockchains and how to track the status of each sent message in the sender contract on the source chain. Tracking the status of sent messages allows your smart contracts to execute actions after the receiver acknowledges it received the message. In this example, the sender contract emits an event after it receives acknowledgment from the receiver.

Note: For simplicity, this tutorial demonstrates this pattern for sending arbitrary data. However, you are not limited to this application. You can apply the same pattern to programmable token transfers.

Before you begin
This tutorial assumes you have completed the Send Arbitrary Data tutorial.
Your account must have some AVAX tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia.
Learn how to Acquire testnet LINK and Fund your contract with LINK.
Tutorial
note
Optimize your development with the CCIP local simulator

Enhance your development workflow using the Chainlink CCIP local simulator, an installable package designed to simulate Chainlink CCIP locally within your Hardhat and Foundry projects. It provides a robust smart contracts and scripts suite, enabling you to build, deploy, and execute CCIP token transfers and arbitrary messages on a local Hardhat or Anvil development node. With Chainlink Local, you can also work on forked nodes, ensuring a seamless transition of your contracts to test networks without modifications. Start integrating Chainlink Local today to streamline your development process and validate your CCIP implementations effectively.

In this tutorial, you will deploy a message tracker contract on the source blockchain (Avalanche Fuji) and an acknowledger on the destination blockchain (Ethereum Sepolia). Throughout the tutorial, you will pay for CCIP fees using LINK tokens. Here is a step-by-step breakdown:

Sending and building a CCIP message: Initiate and send a message from the message tracker contract on Avalanche Fuji to the acknowledger contract on Ethereum Sepolia. The message tracker contract constructs a CCIP message that encapsulates a text string and establishes a tracking status for this message before sending it off.
Receiving and acknowledging the message: After the acknowledger contract receives the text on Ethereum Sepolia, it sends back a CCIP message to the message tracker contract as an acknowledgment of receipt.
Updating tracking status: After the message tracker receives the acknowledgment, the contract updates the tracking status of the initial CCIP message and emits an event to signal completion.
Deploy the message tracker (sender) contract
Deploy the MessageTracker.sol contract on Avalanche Fuji and enable it to send and receive CCIP messages to and from Ethereum Sepolia. You must also enable your contract to receive CCIP messages from the acknowledger contract.

Open the MessageTracker.sol contract in Remix.

Open in Remix
What is Remix?
Note: The contract code is also available in the Examine the code section.

Compile the contract.

Deploy the contract on Avalanche Fuji:

Open MetaMask and select the Avalanche Fuji network.

On the Deploy & Run Transactions tab in Remix, select Injected Provider - MetaMask in the Environment list. Remix will use the MetaMask wallet to communicate with Avalanche Fuji.

Under the Deploy section, fill in the router address and the LINK token contract address for your specific blockchain. You can find both of these addresses on the CCIP Directory. The LINK token contract address is also listed on the LINK Token Contracts page. For Avalanche Fuji:

The router address is 
0xF694E193200268f9a4868e4Aa017A0118C9a8177
Copy to clipboard
The LINK token address is 
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Copy to clipboard
Click transact to deploy the contract. MetaMask prompts you to confirm the transaction. Check the transaction details to make sure you are deploying the contract on Avalanche Fuji.

After you confirm the transaction, the contract address appears in the Deployed Contracts list. Copy your contract address.

Open MetaMask and send 
70
Copy to clipboard
 LINK to the contract address you copied. Your contract will pay CCIP fees in LINK.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK from faucets.chain.link or use a supported testnet other than Sepolia.

Allow the Ethereum Sepolia chain selector for both destination and source chains.

On the Deploy & Run Transactions tab in Remix, expand the message tracker contract in the Deployed Contracts section.
Call the allowlistDestinationChain function with 
16015286601757825753
Copy to clipboard
 as the destination chain selector for Ethereum Sepolia and 
true
Copy to clipboard
 as allowed.
Call the allowlistSourceChain function with 
16015286601757825753
Copy to clipboard
 as the source chain selector for Ethereum Sepolia and 
true
Copy to clipboard
 as allowed. You can find each network's chain selector on the CCIP Directory.
Deploy the acknowledger (receiver) contract
Deploy the Acknowledger.sol contract on Ethereum Sepolia and enable it to send and receive CCIP messages to and from Avalanche Fuji. You must also enable your contract to receive CCIP messages from the message tracker contract.

Open the Acknowledger.sol contract in Remix.

Open in Remix
What is Remix?
Note: The contract code is also available in the Examine the code section.

Compile the contract.

Deploy the contract on Ethereum Sepolia:

Open MetaMask and select the Ethereum Sepolia network.

On the Deploy & Run Transactions tab in Remix, make sure the Environment is still set to Injected Provider - MetaMask.

Under the Deploy section, fill in the router address and the LINK token contract address for your specific blockchain. You can find both of these addresses on the CCIP Directory. The LINK token contract address is also listed on the LINK Token Contracts page. For Ethereum Sepolia:

The Router address is 
0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
Copy to clipboard
.
The LINK token address is 
0x779877A7B0D9E8603169DdbD7836e478b4624789
Copy to clipboard
.
Click transact to deploy the contract. MetaMask prompts you to confirm the transaction. Check the transaction details to make sure you are deploying the contract to Ethereum Sepolia.

After you confirm the transaction, the contract address appears in the Deployed Contracts list. Copy this contract address.

Open MetaMask and send 
70
Copy to clipboard
 LINK to the contract address that you copied. Your contract will pay CCIP fees in LINK.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK from faucets.chain.link or use a supported testnet other than Sepolia.

Allow the Avalanche Fuji chain selector for both destination and source chains. You must also enable your acknowledger contract to receive CCIP messages from the message tracker you deployed on Avalanche Fuji.

On the Deploy & Run Transactions tab in Remix, expand the acknowledger contract in the Deployed Contracts section. Expand the allowlistDestinationChain, allowlistSender, and allowlistSourceChain functions and fill in the following arguments:

Function	Description	Value (Avalanche Fuji)
allowlistDestinationChain	CCIP Chain identifier of the target blockchain. You can find each network's chain selector on the CCIP Directory	
14767482510784806043
Copy to clipboard
, 
true
Copy to clipboard
allowlistSender	The address of the message tracker contract deployed on Avalanche Fuji	Your deployed contract address, 
true
Copy to clipboard
allowlistSourceChain	CCIP Chain identifier of the source blockchain. You can find each network's chain selector on the CCIP Directory	
14767482510784806043
Copy to clipboard
, 
true
Copy to clipboard
Open MetaMask and select the Ethereum Sepolia network.

For each function you expanded and filled in the arguments for, click the transact button to call the function. MetaMask prompts you to confirm the transaction. Wait for each transaction to succeed before calling the following function.

Finally, enable your message tracker contract to receive CCIP messages from the acknowledger contract you deployed on Ethereum Sepolia.

On the Deploy & Run Transactions tab in Remix, expand the message tracker contract in the Deployed Contracts section. Expand the allowlistSender function and fill in your acknowledger contract address and 
true
Copy to clipboard
 as allowed.

Open MetaMask and select the Avalanche Fuji network.

Click transact to call the function. MetaMask prompts you to confirm the transaction.

At this point, you have one message tracker (sender) contract on Avalanche Fuji and one acknowledger (receiver) contract on Ethereum Sepolia. You sent 70 LINK to the message tracker contract and 70 LINK to the acknowledger contract to pay the CCIP fees.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia.

Send data and track the message status
Initial message
Send a Hello World! string from your message tracker contract on Avalanche Fuji to your acknowledger contract deployed on Ethereum Sepolia. You will track the status of this message during this tutorial.

Open MetaMask and select the Avalanche Fuji network.

On the Deploy & Run Transactions tab in Remix, expand the message tracker contract in the Deployed Contracts section.

Expand the sendMessagePayLINK function and fill in the following arguments:

Argument	Description	Value (Ethereum Sepolia)
destinationChainSelector	CCIP Chain identifier of the target blockchain. You can find each network's chain selector on the CCIP Directory	
16015286601757825753
Copy to clipboard
receiver	The destination smart contract address	Your deployed acknowledger contract address
text	Any string	
Hello World!
Copy to clipboard
Click transact to call the function. MetaMask prompts you to confirm the transaction.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Upon transaction success, expand the last transaction in the Remix log and copy the transaction hash. In this example, it is 0x1f88abc33a4ab426a5466e01d9e5fe8a2b96d6a6e5cedb643a674489c74126b4.

Open the CCIP Explorer and use the transaction hash that you copied to search for your cross-chain transaction.

Chainlink CCIP Explorer - Fuji to Sepolia Transaction Details
After the transaction is finalized on the source chain, it will take a few minutes for CCIP to deliver the data to Ethereum Sepolia and call the ccipReceive function on your acknowledger contract.

Copy the message ID from the CCIP Explorer transaction details. You will use this message ID to track your message status on the message tracker contract. In this example, it is 0xdd8be2f5f5d5cf3b8640c62924025b311ae83c6144f0f2ed5c24637436d6aab8.

On the Deploy & Run Transactions tab in Remix, expand your message tracker contract in the Deployed Contracts section.

Paste the message ID you copied from the CCIP explorer as the argument in the messagesInfo getter function. Click messagesInfo to read the message status.

Chainlink CCIP - Message Tracker Get Message Status - 1
Note the returned status 1. This value indicates that the message tracker contract has updated your message status to the Sent status as defined by the MessageStatus enum in the message tracker contract.

copy to clipboard
// Enum is used to track the status of messages sent via CCIP.
// `NotSent` indicates a message has not yet been sent.
// `Sent` indicates that a message has been sent to the Acknowledger contract but not yet acknowledged.
// `ProcessedOnDestination` indicates that the Acknowledger contract has processed the message and that
// the Message Tracker contract has received the acknowledgment from the Acknowledger contract.
enum MessageStatus {
  NotSent, // 0
  Sent, // 1
  ProcessedOnDestination // 2
}
When the transaction is marked with a "Success" status on the CCIP Explorer, the CCIP transaction and the destination transaction are complete. The acknowledger contract has received the message from the message tracker contract.

Chainlink CCIP Explorer - Fuji to Sepolia Transaction Success
Acknowledgment message
The acknowledger contract processes the message, sends an acknowledgment message containing the initial message ID back to the message tracker contract, and emits an AcknowledgmentSent event. Read this explanation for further description.

copy to clipboard
// Emitted when an acknowledgment message is successfully sent back to the sender contract.
// This event signifies that the Acknowledger contract has recognized the receipt of an initial message
// and has informed the original sender contract by sending an acknowledgment message,
// including the original message ID.
event AcknowledgmentSent(
  bytes32 indexed messageId, // The unique ID of the CCIP message.
  uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
  address indexed receiver, // The address of the receiver on the destination chain.
  bytes32 data, // The data being sent back, usually containing the message ID of the original message to acknowledge its receipt.
  address feeToken, // The token address used to pay CCIP fees for sending the acknowledgment.
  uint256 fees // The fees paid for sending the acknowledgment message via CCIP.
);
Copy your acknowledger contract address from Remix. Open the Ethereum Sepolia explorer and search for your deployed acknowledger contract. Click the Events tab to see the events log.

Chainlink CCIP - Ethereum Sepolia Acknowledger Contract Events
The first indexed topic (topic1) in the AcknowledgmentSent event is the acknowledgment message ID sent to the message tracker contract on Avalanche Fuji. In this example, the message ID is 0xd4d4a5d0db05dc714f8150c1af654ed34eb8c9f7547401fa9bf072a815f56ac1.

Copy your own message ID from the indexed topic1 and search for it in the CCIP explorer.

Chainlink CCIP - CCIP Explorer Sepolia to Fuji Transaction Success
When the transaction is marked with a "Success" status on the CCIP explorer, the CCIP transaction and the destination transaction are complete. The message tracker contract has received the message from the acknowledger contract.

Final status check
When the message tracker receives the acknowledgment message, the ccipReceive function updates the initial message status to 2, which corresponds to the ProcessedOnDestination status as defined by the MessageStatus enum. The function emits a MessageProcessedOnDestination event.

Open MetaMask and select the Avalanche Fuji network.

On the Deploy & Run Transactions tab in Remix, expand your message tracker contract in the Deployed Contracts section.

Copy the initial message ID from the CCIP explorer (transaction from Avalanche Fuji to Ethereum Sepolia) and paste it as the argument in the messagesInfo getter function. Click messagesInfo to read the message status. It returns status 2 and the acknowledgment message ID that confirms this status.

Chainlink CCIP - Message Tracker Get Message Status - 2
Copy your message tracker contract address from Remix. Open the Avalanche Fuji explorer and search for your deployed message tracker contract. Then, click on the Events tab.

Chainlink CCIP - Message Tracker Message Confirmed Event
The MessageProcessedOnDestination event is emitted with the acknowledged message ID 0xdd8be2f5f5d5cf3b8640c62924025b311ae83c6144f0f2ed5c24637436d6aab8 as indexed topic2.

copy to clipboard
// Event emitted when the sender contract receives an acknowledgment
// that the receiver contract has successfully received and processed the message.
event MessageProcessedOnDestination(
  bytes32 indexed messageId, // The unique ID of the CCIP acknowledgment message.
  bytes32 indexed acknowledgedMsgId, // The unique ID of the message acknowledged by the receiver.
  uint64 indexed sourceChainSelector, // The chain selector of the source chain.
  address sender // The address of the sender from the source chain.
);
Explanation
note
Integrate Chainlink CCIP v1.6.0 into your project

npmyarnfoundry
If you use NPM, install the @chainlink/contracts-ccip NPM package:

copy to clipboard
npm install @chainlink/contracts-ccip@1.6.0
The smart contracts featured in this tutorial are designed to interact with CCIP to send and receive messages with an acknowledgment of receipt mechanism. The contract code across both contracts contains supporting comments clarifying the functions, events, and underlying logic.

Refer to the Send Arbitrary Data tutorial for more explanation about initializing the contracts, sending data, paying in LINK, and receiving data.

Here, we will further explain the acknowledgment of receipt mechanism.

caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

Message acknowledgment of receipt mechanism
This mechanism ensures that a message sent by the message tracker (sender) contract is received and acknowledged by the acknowledger (receiver) contract. The message status is tracked and stored in the message tracker contract.

copy to clipboard
// Enum is used to track the status of messages sent via CCIP.
// `NotSent` indicates a message has not yet been sent.
// `Sent` indicates that a message has been sent to the Acknowledger contract but not yet acknowledged.
// `ProcessedOnDestination` indicates that the Acknowledger contract has processed the message and that
// the Message Tracker contract has received the acknowledgment from the Acknowledger contract.
enum MessageStatus {
    NotSent, // 0
    Sent, // 1
    ProcessedOnDestination // 2
}

// Struct to store the status and acknowledger message ID of a message.
struct MessageInfo {
    MessageStatus status;
    bytes32 acknowledgerMessageId;
}

// Mapping to keep track of message IDs to their info (status & acknowledger message ID).
mapping(bytes32 => MessageInfo) public messagesInfo;
Message tracker contract
The message tracker contract acts as the sender, initiating cross-chain communication. It performs the following operations:

Message sending: Constructs and sends messages to the acknowledger contract on another blockchain, using sendMessagePayLINK function. On top of its five primary operations, the sendMessagePayLINK function also updates the message status upon sending.

Status tracking:

Upon sending a message, the message tracker updates its internal state to mark the message as Sent (status 1). This status is pivotal for tracking the message lifecycle and awaiting acknowledgment.

copy to clipboard
// Update the message status to `Sent`
messagesInfo[messageId].status = MessageStatus.Sent;
Upon receiving an acknowledgment message from the acknowledger contract, the message tracker contract updates the message status from Sent (status 1) to ProcessedOnDestination (status 2). This update indicates that the cross-chain communication cycle is complete, and the receiver successfully received and acknowledged the message.

copy to clipboard
// Update the message status to `ProcessedOnDestination`
messagesInfo[messageId].status = MessageStatus.ProcessedOnDestination;
Acknowledger contract
The acknowledger contract receives the message, sends back an acknowledgment message, and emits an event. It performs the following operations:

Message receipt: Upon receiving a message via CCIP, the ccipReceive function decodes it and calls the acknowledgePayLINK function nested within the ccipReceive function.

Acknowledgment sending: The acknowledgePayLINK function acts as a custom sendMessagePayLINK function nested within the ccipReceive function. It sends an acknowledgment (a CCIP message) to the message tracker contract upon the initial message receipt. The data transferred in this acknowledgment message is the initial message ID. It then emits an AcknowledgmentSent event.

Security and integrity
Both contracts use allowlists to process only messages from and to allowed sources.

Allowlisting chains and senders:

The sendMessagePayLINK function is protected by the onlyAllowlistedDestinationChain modifier, ensuring the contract owner has allowlisted a destination chain.
The ccipReceive function is protected by the onlyAllowlisted modifier, ensuring the contract owner has allowlisted a source chain and a sender.
Ensuring the initial message authenticity: The message tracker contract first checks that the message awaiting acknowledgment was sent from the contract itself and is currently marked as Sent. Once confirmed, the message status is updated to ProcessedOnDestination.

Examine the code
MessageTracker.sol
copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

using SafeERC20 for IERC20;

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple messenger contract for sending/receiving data across chains and tracking the status of sent messages.
contract MessageTracker is CCIPReceiver, OwnerIsCreator {
    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error DestinationChainNotAllowlisted(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error SourceChainNotAllowlisted(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowlisted(address sender); // Used when the sender has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.
    error MessageWasNotSentByMessageTracker(bytes32 msgId); // Triggered when attempting to confirm a message not recognized as sent by this tracker.
    error MessageHasAlreadyBeenProcessedOnDestination(bytes32 msgId); // Triggered when trying to mark a message as `ProcessedOnDestination` when it is already marked as such.

    // Enum is used to track the status of messages sent via CCIP.
    // `NotSent` indicates a message has not yet been sent.
    // `Sent` indicates that a message has been sent to the Acknowledger contract but not yet acknowledged.
    // `ProcessedOnDestination` indicates that the Acknowledger contract has processed the message and that
    // the Message Tracker contract has received the acknowledgment from the Acknowledger contract.
    enum MessageStatus {
        NotSent, // 0
        Sent, // 1
        ProcessedOnDestination // 2
    }

    // Struct to store the status and acknowledger message ID of a message.
    struct MessageInfo {
        MessageStatus status;
        bytes32 acknowledgerMessageId;
    }

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    // Mapping to keep track of message IDs to their info (status & acknowledger message ID).
    mapping(bytes32 => MessageInfo) public messagesInfo;

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        string text, // The text being sent.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the CCIP message.
    );

    // Event emitted when the sender contract receives an acknowledgment
    // that the receiver contract has successfully received and processed the message.
    event MessageProcessedOnDestination(
        bytes32 indexed messageId, // The unique ID of the CCIP acknowledgment message.
        bytes32 indexed acknowledgedMsgId, // The unique ID of the message acknowledged by the receiver.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address sender // The address of the sender from the source chain.
    );

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowlisted(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowlisted(_sender);
        _;
    }

    /// @dev Modifier that checks the receiver address is not 0.
    /// @param _receiver The receiver address.
    modifier validateReceiver(address _receiver) {
        if (_receiver == address(0)) revert InvalidReceiverAddress();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain for transactions.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends data to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @dev Assumes your contract has sufficient LINK.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The text to be sent.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        validateReceiver(_receiver)
        returns (bytes32 messageId)
    {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(
            _receiver,
            _text,
            address(s_linkToken)
        );

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > s_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        s_linkToken.approve(address(router), fees);

        // Send the CCIP message through the router and store the returned CCIP message ID
        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);

        // Update the message status to `Sent`
        messagesInfo[messageId].status = MessageStatus.Sent;

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            address(s_linkToken),
            fees
        );

        // Return the CCIP message ID
        return messageId;
    }

    /**
     * @dev Receives and processes messages sent via the Chainlink CCIP from allowed chains and senders.
     * Upon receiving a message, this function checks if the message's associated data indicates a previously
     * sent message awaiting acknowledgment. If the message is valid (i.e., its status is `Sent`), it updates
     * the message's status to `ProcessedOnDestination`, thereby acknowledging its receipt. It then emits a `MessageProcessedOnDestination`
     * event. If the message cannot be validated (e.g., it was not sent or has been tampered with), the function
     * reverts with a `MessageWasNotSentByMessageTracker` error. This mechanism ensures that only messages
     * genuinely sent and awaiting acknowledgment are marked as `ProcessedOnDestination`.
     * @param any2EvmMessage The CCIP message received, which includes the message ID, the data being acknowledged,
     * the source chain selector, and the sender's address.
     */
    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    )
        internal
        override
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Ensure the source chain and sender are allowlisted for added security
    {
        bytes32 initialMsgId = abi.decode(any2EvmMessage.data, (bytes32)); // Decode the data sent by the receiver
        bytes32 acknowledgerMsgId = any2EvmMessage.messageId;
        messagesInfo[initialMsgId].acknowledgerMessageId = acknowledgerMsgId; // Store the messageId of the received message

        if (messagesInfo[initialMsgId].status == MessageStatus.Sent) {
            // Updates the status of the message to 'ProcessedOnDestination' to reflect that an acknowledgment
            // of receipt has been received and emits an event to log this confirmation along with relevant details.
            messagesInfo[initialMsgId].status = MessageStatus
                .ProcessedOnDestination;
            emit MessageProcessedOnDestination(
                acknowledgerMsgId,
                initialMsgId,
                any2EvmMessage.sourceChainSelector,
                abi.decode(any2EvmMessage.sender, (address))
            );
        } else if (
            messagesInfo[initialMsgId].status ==
            MessageStatus.ProcessedOnDestination
        ) {
            // If the message is already marked as 'ProcessedOnDestination', this indicates an attempt to
            // re-confirm a message that has already been processed on the destination chain and marked as such.
            revert MessageHasAlreadyBeenProcessedOnDestination(initialMsgId);
        } else {
            // If the message status is neither 'Sent' nor 'ProcessedOnDestination', it implies that the
            // message ID provided for acknowledgment does not correspond to a valid, previously
            // sent message.
            revert MessageWasNotSentByMessageTracker(initialMsgId);
        }
    }

    /// @notice Construct a CCIP message.
    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for sending a text.
    /// @param _receiver The address of the receiver.
    /// @param _text The string data to be sent.
    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.
    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.
    function _buildCCIPMessage(
        address _receiver,
        string calldata _text,
        address _feeTokenAddress
    ) private pure returns (Client.EVM2AnyMessage memory) {
        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        return
            Client.EVM2AnyMessage({
                receiver: abi.encode(_receiver), // ABI-encoded receiver address
                data: abi.encode(_text), // ABI-encoded string
                tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array as no tokens are transferred
                extraArgs: Client._argsToBytes(
                    // Additional arguments, setting gas limit and allowing out-of-order execution.
                    // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                    // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                    // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                    Client.GenericExtraArgsV2({
                        gasLimit: 300_000,
                        allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                    })
                ),
                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
                feeToken: _feeTokenAddress
            });
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
Open in Remix
What is Remix?
Acknowledger.sol
copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

using SafeERC20 for IERC20;

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple acknowledger contract for receiving data and sending acknowledgement of receipt messages across chains.
contract Acknowledger is CCIPReceiver, OwnerIsCreator {
    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error DestinationChainNotAllowlisted(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error InvalidReceiverAddress(); // Used when the receiver address is 0.
    error SourceChainNotAllowlisted(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowlisted(address sender); // Used when the sender has not been allowlisted by the contract owner.

    string private s_lastReceivedText; // Store the last received text.

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    // Emitted when an acknowledgment message is successfully sent back to the sender contract.
    // This event signifies that the Acknowledger contract has recognized the receipt of an initial message
    // and has informed the original sender contract by sending an acknowledgment message,
    // including the original message ID.
    event AcknowledgmentSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address indexed receiver, // The address of the receiver on the destination chain.
        bytes32 data, // The data being sent back, containing the message ID of the initial message to acknowledge.
        address feeToken, // The token address used to pay CCIP fees for sending the acknowledgment.
        uint256 fees // The fees paid for sending the acknowledgment message via CCIP.
    );

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowlisted(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowlisted(_sender);
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain for transactions.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends an acknowledgment message back to the sender contract on the source chain
    /// and pays the fees using LINK tokens.
    /// @dev This function constructs and sends an acknowledgment message using CCIP,
    /// indicating the receipt and processing of an initial message. It emits the `AcknowledgmentSent` event
    /// upon successful sending. This function should be called after processing the received message
    /// to inform the sender contract about the successful message reception.
    /// @param _messageIdToAcknowledge The message ID of the initial message being acknowledged.
    /// @param _messageTrackerAddress The address of the message tracker contract on the source chain.
    /// @param _messageTrackerChainSelector The chain selector of the source chain.
    function _acknowledgePayLINK(
        bytes32 _messageIdToAcknowledge,
        address _messageTrackerAddress,
        uint64 _messageTrackerChainSelector
    ) private {
        if (_messageTrackerAddress == address(0))
            revert InvalidReceiverAddress();

        // Construct the CCIP message for acknowledgment, including the message ID of the initial message.
        Client.EVM2AnyMessage memory acknowledgment = Client.EVM2AnyMessage({
            receiver: abi.encode(_messageTrackerAddress), // ABI-encoded receiver address
            data: abi.encode(_messageIdToAcknowledge), // ABI-encoded message ID to acknowledge
            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array aas no tokens are transferred
            extraArgs: Client._argsToBytes(
                // Additional arguments, setting gas limit and allowing out-of-order execution.
                // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                Client.GenericExtraArgsV2({
                    gasLimit: 200_000,
                    allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender.
                })
            ),
            // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees
            feeToken: address(s_linkToken)
        });

        // Initialize a router client instance to interact with the cross-chain router.
        IRouterClient router = IRouterClient(this.getRouter());

        // Calculate the fee required to send the CCIP acknowledgment message.
        uint256 fees = router.getFee(
            _messageTrackerChainSelector, // The chain selector for routing the message.
            acknowledgment // The acknowledgment message data.
        );

        // Ensure the contract has sufficient balance to cover the message sending fees.
        if (fees > s_linkToken.balanceOf(address(this))) {
            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);
        }

        // Approve the router to transfer LINK tokens on behalf of this contract to cover the sending fees.
        s_linkToken.approve(address(router), fees);

        // Send the acknowledgment message via the CCIP router and capture the resulting message ID.
        bytes32 messageId = router.ccipSend(
            _messageTrackerChainSelector, // The destination chain selector.
            acknowledgment // The CCIP message payload for acknowledgment.
        );

        // Emit an event detailing the acknowledgment message sending, for external tracking and verification.
        emit AcknowledgmentSent(
            messageId, // The ID of the sent acknowledgment message.
            _messageTrackerChainSelector, // The destination chain selector.
            _messageTrackerAddress, // The receiver of the acknowledgment, typically the original sender.
            _messageIdToAcknowledge, // The original message ID that was acknowledged.
            address(s_linkToken), // The fee token used.
            fees // The fees paid for sending the message.
        );
    }

    /// @dev Handles a received CCIP message, processes it, and acknowledges its receipt.
    /// This internal function is called upon the receipt of a new message via CCIP from an allowlisted source chain and sender.
    /// It decodes the message and acknowledges its receipt by calling `_acknowledgePayLINK`.
    /// @param any2EvmMessage The CCIP message received
    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    )
        internal
        override
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure source chain and sender are allowlisted
    {
        bytes32 messageIdToAcknowledge = any2EvmMessage.messageId; // The message ID of the received message to acknowledge
        address messageTrackerAddress = abi.decode(
            any2EvmMessage.sender,
            (address)
        ); // ABI-decoding of the message tracker address
        uint64 messageTrackerChainSelector = any2EvmMessage.sourceChainSelector; // The chain selector of the received message
        s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text

        _acknowledgePayLINK(
            messageIdToAcknowledge,
            messageTrackerAddress,
            messageTrackerChainSelector
        );
    }

    /// @notice Fetches the details of the last received message.
    /// @return text The last received text.
    function getLastReceivedMessage()
        external
        view
        returns (string memory text)
    {
        return (s_lastReceivedText);
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
Open in Remix
What is Remix?
Final note
In this example, the message tracker contract emits an event when it receives the acknowledgment message confirming the initial message reception and processing on the counterpart chain. However, you could think of any other logic to execute when the message tracker receives the acknowledgment. This tutorial demonstrates the pattern for sending arbitrary data, but you can apply the same pattern to programmable token transfers.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.


This tutorial is similar to the programmable token transfers example. It demonstrates the use of Chainlink CCIP for transferring tokens and arbitrary data between smart contracts on different blockchains. A distinctive feature of this tutorial is that we intentionally set a very low gas limit when using CCIP to send our message. This low gas limit is designed to cause the execution on the destination chain to fail, providing an opportunity to demonstrate the manual execution feature. Here's how you will proceed:

Initiate a Transfer: You'll transfer tokens and arbitrary data from your source contract on Avalanche Fuji to a receiver contract on Ethereum Sepolia. You will notice that the CCIP message has a very low gas limit, causing the execution on the receiver contract to fail.
Failure of CCIP Message Delivery: Once the transaction is finalized on the source chain (Avalanche Fuji), CCIP will deliver your message to the receiver contract on the destination chain (Ethereum Sepolia). You can follow the progress of your transaction using the CCIP explorer. Here, you'll observe that the execution on the receiver contract failed due to the low gas limit.
Manual Execution via CCIP Explorer: Using the CCIP explorer, you will override the previously set gas limit and retry the execution. This process is referred to as manual execution.
Confirm Successful Execution: After manually executing the transaction with an adequate gas limit, you'll see that the status of your CCIP message is updated to successful. This indicates that the tokens and data were correctly transferred to the receiver contract.
Before you begin
You should understand how to write, compile, deploy, and fund a smart contract. If you need to brush up on the basics, read this tutorial, which will guide you through using the Solidity programming language, interacting with the MetaMask wallet and working within the Remix Development Environment.
Your account must have some AVAX and LINK tokens on Avalanche Fuji and ETH tokens on Ethereum Sepolia. Learn how to Acquire testnet LINK.
Check the CCIP Directory to confirm that the tokens you will transfer are supported for your lane. In this example, you will transfer tokens from Avalanche Fuji to Ethereum Sepolia so check the list of supported tokens here.
Learn how to acquire CCIP test tokens. Following this guide, you should have CCIP-BnM tokens, and CCIP-BnM should appear in the list of your tokens in MetaMask.
Learn how to fund your contract. This guide shows how to fund your contract in LINK, but you can use the same guide for funding your contract with any ERC20 tokens as long as they appear in the list of tokens in MetaMask.
Follow the previous tutorial: Transfer Tokens with Data to learn how to make programmable token transfers using CCIP.
Create a free account on Tenderly. You will use Tenderly to investigate the failed execution of the receiver contract.
Tutorial
In this tutorial, you'll send a text string and CCIP-BnM tokens between smart contracts on Avalanche Fuji and Ethereum Sepolia using CCIP and pay transaction fees in LINK. The tutorial demonstrates setting a deliberately low gas limit in the CCIP message, causing initial execution failure on the receiver contract. You will then:

Use the CCIP explorer to increase the gas limit.
Manually retry the execution.
Observe successful execution after the gas limit adjustment.
copy to clipboard
// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import {IRouterClient} from "@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol";
import {OwnerIsCreator} from "@chainlink/contracts/src/v0.8/shared/access/OwnerIsCreator.sol";
import {Client} from "@chainlink/contracts-ccip/contracts/libraries/Client.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol";
import {IERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

/// @title - A simple messenger contract for transferring/receiving tokens and data across chains.
contract ProgrammableTokenTransfersLowGasLimit is CCIPReceiver, OwnerIsCreator {
    using SafeERC20 for IERC20;

    // Custom errors to provide more descriptive revert messages.
    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance to cover the fees.
    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.
    error DestinationChainNotAllowed(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.
    error SourceChainNotAllowed(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowed(address sender); // Used when the sender has not been allowlisted by the contract owner.

    // Event emitted when a message is sent to another chain.
    event MessageSent(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.
        address receiver, // The address of the receiver on the destination chain.
        string text, // The text being sent.
        address token, // The token address that was transferred.
        uint256 tokenAmount, // The token amount that was transferred.
        address feeToken, // the token address used to pay CCIP fees.
        uint256 fees // The fees paid for sending the message.
    );

    // Event emitted when a message is received from another chain.
    event MessageReceived(
        bytes32 indexed messageId, // The unique ID of the CCIP message.
        uint64 indexed sourceChainSelector, // The chain selector of the source chain.
        address sender, // The address of the sender from the source chain.
        string text, // The text that was received.
        address token, // The token address that was transferred.
        uint256 tokenAmount // The token amount that was transferred.
    );

    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.
    address private s_lastReceivedTokenAddress; // Store the last received token address.
    uint256 private s_lastReceivedTokenAmount; // Store the last received amount.
    string private s_lastReceivedText; // Store the last received text.

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    IERC20 private s_linkToken;

    /// @notice Constructor initializes the contract with the router address.
    /// @param _router The address of the router contract.
    /// @param _link The address of the link contract.
    constructor(address _router, address _link) CCIPReceiver(_router) {
        s_linkToken = IERC20(_link);
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowed(_destinationChainSelector);
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowed(_sourceChainSelector);
        if (!allowlistedSenders[_sender]) revert SenderNotAllowed(_sender);
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _destinationChainSelector The selector of the destination chain to be updated.
    /// @param allowed The allowlist status to be set for the destination chain.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain
    /// @notice This function can only be called by the owner.
    /// @param _sourceChainSelector The selector of the source chain to be updated.
    /// @param allowed The allowlist status to be set for the source chain.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external onlyOwner {
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    /// @notice This function can only be called by the owner.
    /// @param _sender The address of the sender to be updated.
    /// @param allowed The allowlist status to be set for the sender.
    function allowlistSender(address _sender, bool allowed) external onlyOwner {
        allowlistedSenders[_sender] = allowed;
    }

    /// @notice Sends data and transfer tokens to receiver on the destination chain.
    /// @notice Pay for fees in LINK.
    /// @notice the gasLimit is set to 20_000 on purpose to force the execution to fail on the destination chain
    /// @dev Assumes your contract has sufficient LINK to pay for CCIP fees.
    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.
    /// @param _receiver The address of the recipient on the destination blockchain.
    /// @param _text The string data to be sent.
    /// @param _token token address.
    /// @param _amount token amount.
    /// @return messageId The ID of the CCIP message that was sent.
    function sendMessagePayLINK(
        uint64 _destinationChainSelector,
        address _receiver,
        string calldata _text,
        address _token,
        uint256 _amount
    )
        external
        onlyOwner
        onlyAllowlistedDestinationChain(_destinationChainSelector)
        returns (bytes32 messageId)
    {
        // Set the token amounts
        Client.EVMTokenAmount[]
            memory tokenAmounts = new Client.EVMTokenAmount[](1);
        tokenAmounts[0] = Client.EVMTokenAmount({
            token: _token,
            amount: _amount
        });

        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message
        // address(linkToken) means fees are paid in LINK

        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({
            receiver: abi.encode(_receiver), // ABI-encoded receiver address
            data: abi.encode(_text), // ABI-encoded string
            tokenAmounts: tokenAmounts, // The amount and type of token being transferred
            extraArgs: Client._argsToBytes(
                // Additional arguments, setting gas limit and allowing out-of-order execution.
                // Best Practice: For simplicity, the values are hardcoded. It is advisable to use a more dynamic approach
                // where you set the extra arguments off-chain. This allows adaptation depending on the lanes, messages,
                // and ensures compatibility with future CCIP upgrades. Read more about it here: https://docs.chain.link/ccip/concepts/best-practices/evm#using-extraargs
                Client.GenericExtraArgsV2({
                    gasLimit: 20_000, // Gas limit for the callback on the destination chain
                    allowOutOfOrderExecution: true // Allows the message to be executed out of order relative to other messages from the same sender
                })
            ),
            // Set the feeToken to a LINK token address
            feeToken: address(s_linkToken)
        });

        // Initialize a router client instance to interact with cross-chain router
        IRouterClient router = IRouterClient(this.getRouter());

        // Get the fee required to send the CCIP message
        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);

        if (fees > s_linkToken.balanceOf(address(this)))
            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);

        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK
        s_linkToken.approve(address(router), fees);

        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token
        IERC20(_token).approve(address(router), _amount);

        // Send the message through the router and store the returned message ID
        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);

        // Emit an event with message details
        emit MessageSent(
            messageId,
            _destinationChainSelector,
            _receiver,
            _text,
            _token,
            _amount,
            address(s_linkToken),
            fees
        );

        // Return the message ID
        return messageId;
    }

    /**
     * @notice Returns the details of the last CCIP received message.
     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.
     * @return messageId The ID of the last received CCIP message.
     * @return text The text of the last received CCIP message.
     * @return tokenAddress The address of the token in the last CCIP received message.
     * @return tokenAmount The amount of the token in the last CCIP received message.
     */
    function getLastReceivedMessageDetails()
        public
        view
        returns (
            bytes32 messageId,
            string memory text,
            address tokenAddress,
            uint256 tokenAmount
        )
    {
        return (
            s_lastReceivedMessageId,
            s_lastReceivedText,
            s_lastReceivedTokenAddress,
            s_lastReceivedTokenAmount
        );
    }

    /// handle a received message
    function _ccipReceive(
        Client.Any2EVMMessage memory any2EvmMessage
    )
        internal
        override
        onlyAllowlisted(
            any2EvmMessage.sourceChainSelector,
            abi.decode(any2EvmMessage.sender, (address))
        ) // Make sure source chain and sender are allowlisted
    {
        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId
        s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text
        // Expect one token to be transferred at once, but you can transfer several tokens.
        s_lastReceivedTokenAddress = any2EvmMessage.destTokenAmounts[0].token;
        s_lastReceivedTokenAmount = any2EvmMessage.destTokenAmounts[0].amount;

        emit MessageReceived(
            any2EvmMessage.messageId,
            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)
            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,
            abi.decode(any2EvmMessage.data, (string)),
            any2EvmMessage.destTokenAmounts[0].token,
            any2EvmMessage.destTokenAmounts[0].amount
        );
    }

    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.
    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.
    /// @param _beneficiary The address to which the tokens will be sent.
    /// @param _token The contract address of the ERC20 token to be withdrawn.
    function withdrawToken(
        address _beneficiary,
        address _token
    ) public onlyOwner {
        // Retrieve the balance of this contract
        uint256 amount = IERC20(_token).balanceOf(address(this));

        // Revert if there is nothing to withdraw
        if (amount == 0) revert NothingToWithdraw();

        IERC20(_token).safeTransfer(_beneficiary, amount);
    }
}
Open in Remix
What is Remix?
Deploy your contracts
To use this contract:

Open the contract in Remix.

Compile your contract.

Deploy, fund your sender contract on Avalanche Fuji and enable sending messages to Ethereum Sepolia:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, click on Deploy & Run Transactions and select Injected Provider - MetaMask from the environment list. Remix will then interact with your MetaMask wallet to communicate with Avalanche Fuji.

Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Avalanche Fuji:

The router address is 
0xF694E193200268f9a4868e4Aa017A0118C9a8177
Copy to clipboard
,
The LINK contract address is 
0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846
Copy to clipboard
.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.

Open MetaMask and fund your contract with CCIP-BnM tokens. You can transfer 
0.002
Copy to clipboard
 CCIP-BnM to your contract.

Open MetaMask and fund your contract with LINK tokens. You can transfer 
70
Copy to clipboard
 LINK to your contract. In this example, LINK is used to pay the CCIP fees.

Note: This transaction fee is significantly higher than normal due to gas spikes on Sepolia. To run this example, you can get additional testnet LINK from faucets.chain.link or use a supported testnet other than Sepolia.

Enable your contract to send CCIP messages to Ethereum Sepolia:

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.
Call the allowlistDestinationChain with 
16015286601757825753
Copy to clipboard
 as the destination chain selector, and 
true
Copy to clipboard
 as allowed. Each chain selector is found on the CCIP Directory.
Deploy your receiver contract on Ethereum Sepolia and enable receiving messages from your sender contract:

Open MetaMask and select the network Ethereum Sepolia.
In Remix IDE, under Deploy & Run Transactions, make sure the environment is still Injected Provider - MetaMask.
Fill in your blockchain's router and LINK contract addresses. The router address can be found on the CCIP Directory and the LINK contract address on the LINK token contracts page. For Ethereum Sepolia:
The router address is 
0x0BF3dE8c5D3e8A2B34D2BEeB17ABfCeBaf363A59
Copy to clipboard
,
The LINK contract address is 
0x779877A7B0D9E8603169DdbD7836e478b4624789
Copy to clipboard
.
Click the transact button. After you confirm the transaction, the contract address appears on the Deployed Contracts list. Note your contract address.
Enable your contract to receive CCIP messages from Avalanche Fuji:
In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSourceChain with 
14767482510784806043
Copy to clipboard
 as the source chain selector, and 
true
Copy to clipboard
 as allowed. Each chain selector is found on the CCIP Directory.
Enable your contract to receive CCIP messages from the contract that you deployed on Avalanche Fuji:
In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.
Call the allowlistSender with the contract address of the contract that you deployed on Avalanche Fuji, and 
true
Copy to clipboard
 as allowed.
At this point, you have one sender contract on Avalanche Fuji and one receiver contract on Ethereum Sepolia. As security measures, you enabled the sender contract to send CCIP messages to Ethereum Sepolia and the receiver contract to receive CCIP messages from the sender and Avalanche Fuji.

Transfer and Receive tokens and data and pay in LINK
You will transfer 0.001 CCIP-BnM and a text. The CCIP fees for using CCIP will be paid in LINK.

Send a string data with tokens from Avalanche Fuji:

Open MetaMask and select the network Avalanche Fuji.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Avalanche Fuji.

Fill in the arguments of the sendMessagePayLINK function:


Argument	Value and Description
_destinationChainSelector	
16015286601757825753
Copy to clipboard

CCIP Chain identifier of the destination blockchain (Ethereum Sepolia in this example). You can find each chain selector on the CCIP Directory.
_receiver	Your receiver contract address at Ethereum Sepolia.
The destination contract address.
_text	
Hello World!
Copy to clipboard

Any string
_token	
0xD21341536c5cF5EB1bcb58f6723cE26e8D8E90e4
Copy to clipboard

The CCIP-BnM contract address at the source chain (Avalanche Fuji in this example). You can find all the addresses for each supported blockchain on the CCIP Directory.
_amount	
1000000000000000
Copy to clipboard

The token amount (0.001 CCIP-BnM).
Click on transact and confirm the transaction on MetaMask.

After the transaction is successful, record the transaction hash. Here is an example of a transaction on Avalanche Fuji.

note
Gas price spikes

Under normal circumstances, transactions on the Ethereum Sepolia network require significantly fewer tokens to pay for gas. However, during exceptional periods of high gas price spikes, your transactions may fail if not sufficiently funded. In such cases, you may need to fund your contract with additional tokens. We recommend paying for your CCIP transactions in LINK tokens (rather than native tokens) as you can obtain extra LINK testnet tokens from faucets.chain.link. If you encounter a transaction failure due to these gas price spikes, please add additional LINK tokens to your contract and try again. Alternatively, you can use a supported testnet other than Sepolia.

Open the CCIP explorer and search your cross-chain transaction using the transaction hash. Note that the Gas Limit is 20000. In this example, the CCIP message ID is 0xf8dc098c832332ac59ccc73ee00b480975d8f122a2265c90a1ccc2cd52268770.


Chainlink CCIP Explorer transaction details
After a few minutes, the status will be updated to Ready for manual execution indicating that CCIP could not successfully deliver the message due to the initial low gas limit. At this stage, you have the option to override the gas limit.


Chainlink CCIP Explorer transaction details ready for manual execution
You can also confirm that the CCIP message was not delivered to the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails function.


Chainlink CCIP Sepolia message details empty
Observe that the returned data is empty: the received messageId is 0x0000000000000000000000000000000000000000000000000000000000000000, indicating no message was received. Additionally, the received text field is empty, the token address is the default 0x0000000000000000000000000000000000000000, and the token amount shows as 0.

Manual execution
Investigate the root cause of receiver contract execution failure
To determine if a low gas limit is causing the failure in the receiver contract's execution, consider the following methods:

Error analysis: Examine the error description in the CCIP explorer. An error labeled ReceiverError. This may be due to an out of gas error on the destination chain. Error code: 0x, often indicates a low gas issue.

Advanced Investigation Tool: For a comprehensive analysis, employ a sophisticated tool like Tenderly. Tenderly can provide detailed insights into the transaction processes, helping to pinpoint the exact cause of the failure.

To use Tenderly:

Copy the destination transaction hash from the CCIP explorer. In this example, the destination transaction hash is 0x9f5b50460a1ab551add15dc4b743c81df992e34bc8140bbbdc033de7043140f5.

Open Tenderly and search for your transaction. You should see an interface similar to the following:


Chainlink CCIP Sepolia open in Tenderly
Enable Full Trace then click on Reverts.

Chainlink CCIP Sepolia open in Tenderly
Notice the out of gas error in the receiver contract. In this example, the receiver contract is 0x47EAa31C9e2B1B1Ba19824BedcbE0014c15df15e.

Trigger manual execution
You will increase the gas limit and trigger manual execution:

In the CCIP explorer, connect your wallet, set the Gas limit override to 
200000
Copy to clipboard
, and click on Trigger Manual Execution.


Chainlink CCIP Sepolia - override gas limit
After you confirm the transaction on Metamask, the CCIP explorer shows you a confirmation screen.


Chainlink CCIP Sepolia - override gas limit - confirmation screen
Click on the Close button and observe the status marked as Success.


Chainlink CCIP Sepolia - override gas limit - success
Check the receiver contract on the destination chain:

Open MetaMask and select the network Ethereum Sepolia.

In Remix IDE, under Deploy & Run Transactions, open the list of transactions of your smart contract deployed on Ethereum Sepolia.

Call the getLastReceivedMessageDetails function.


Chainlink CCIP Sepolia message details - success
Notice the received messageId is 0xf8dc098c832332ac59ccc73ee00b480975d8f122a2265c90a1ccc2cd52268770, the received text is Hello World!, the token address is 0xFd57b4ddBf88a4e07fF4e34C487b99af2Fe82a05 (CCIP-BnM token address on Ethereum Sepolia) and the token amount is 1000000000000000 (0.001 CCIP-BnM).

Note: These example contracts are designed to work bi-directionally. As an exercise, you can use them to transfer tokens and data from Avalanche Fuji to Ethereum Sepolia and from Ethereum Sepolia back to Avalanche Fuji.

Explanation
note
Integrate Chainlink CCIP v1.6.0 into your project

npmyarnfoundry
If you use NPM, install the @chainlink/contracts-ccip NPM package:

copy to clipboard
npm install @chainlink/contracts-ccip@1.6.0
The smart contract used in this tutorial is configured to use CCIP for transferring and receiving tokens with data, similar to the contract in the Transfer Tokens with Data section of that tutorial.

A key distinction in this tutorial is the intentional setup of a low gas limit of 20,000 for building the CCIP message. This specific gas limit setting is expected to fail the message delivery on the receiver contract in the destination chain:

copy to clipboard
Client.EVMExtraArgsV2({
  gasLimit: 20_000
  allowOutOfOrderExecution: true
})
caution
Sender Contract Best Practices

This example is simplified for educational purposes. For production code, please adhere to the following best practices:

Do Not Hardcode extraArgs: In this example, extraArgs are hardcoded within the contract for simplicity. It is recommended to make extraArgs mutable. For instance, you can construct extraArgs off-chain and pass them into your function calls, or store them in a storage variable that can be updated as needed. This approach ensures that extraArgs remain backward compatible with future CCIP upgrades. Refer to the Best Practices guide for more information.

Validate the Destination Chain: Always ensure that the destination chain is valid and supported before sending messages.

Understand allowOutOfOrderExecution Usage: This example sets allowOutOfOrderExecution to true (see GenericExtraArgsV2). Read the Best Practices: Setting allowOutOfOrderExecution to learn more about this parameter.

Following these best practices ensures that your contract is robust, future-proof, and compliant with CCIP standards.

caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.


When constructing a CCIP message, it's crucial to set the gas limit accurately. The gas limit represents the maximum amount of gas consumed to execute the ccipReceive function on the CCIP Receiver, which influences the transaction fees for sending a CCIP message. Notably, unused gas is not reimbursed, making it essential to estimate the gas limit carefully:

Setting the gas limit too low will cause the transaction to revert when CCIP calls ccipReceive on the CCIP Receiver, which requires a manual re-execution with an increased gas limit. For more details about this scenario, read the Manual Execution guide.
Conversely, an excessively high gas limit leads to higher fees.
This tutorial shows you how to estimate the gas limit for the ccipReceive function using various methods. You will learn how to use a CCIP Receiver where the gas consumption of the ccipReceive function varies based on the input data. This example emphasizes the need for testing under diverse conditions. This tutorial includes tasks for the following environments:

Local Environment: Using Hardhat and Foundry on a local blockchain provides a swift initial gas estimate. However, different frameworks can yield different results and the local environment will not always be representative of your destination blockchain. Consider these figures to be preliminary estimates. Then, incorporate a buffer and conduct subsequent validations on a testnet.
Testnet: You can precisely determine the required gas limit by deploying your CCIP Sender and Receiver on a testnet and transmitting several CCIP messages with the previously estimated gas. Although this approach is more time-intensive, especially if testing across multiple blockchains, it offers enhanced accuracy.
Offchain Methods: Estimating gas with an offchain Web3 provider or tools like Tenderly offers the most accurate and swift way to determine the needed gas limit.
These approaches will give you insights into accurately estimating the gas limit for the ccipReceive function, ensuring cost-effective CCIP transactions.

Before you begin, open a terminal, clone the smart-contract-examples repository, and navigate to the smart-contract-examples/ccip/estimate-gas directory.

copy to clipboard
git clone https://github.com/smartcontractkit/smart-contract-examples.git && \
cd smart-contract-examples/ccip/estimate-gas
Examine the code
The source code for the CCIP Sender and Receiver is located in the contracts directory for Hardhat projects and in the src directory for Foundry projects. The code includes detailed comments for clarity and is designed to ensure self-explanatory functionality. This section focuses on the _ccipReceive function:

copy to clipboard
function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {
  uint256 iterations = abi.decode(any2EvmMessage.data, (uint256));

  uint256 result = iterations;
  uint256 maxIterations = iterations % 100;
  for (uint256 i = 0; i < maxIterations; i++) {
    result += i;
  }

  emit MessageReceived(
    any2EvmMessage.messageId,
    any2EvmMessage.sourceChainSelector,
    abi.decode(any2EvmMessage.sender, (address)),
    iterations,
    maxIterations,
    result
  );
}
The _ccipReceive function operates as follows:

Input Processing: The function accepts a Client.Any2EVMMessage. The first step involves decoding the number of iterations from the message's data using ABI decoding.
Logic Execution: It initializes the result variable with the number of iterations. The function calculates maxIterations by taking the modulo of iterations with 100, which sets an upper limit for iteration. This step is a safeguard to ensure that the function does not run out of gas.
Iteration: The function executes a loop from 0 to maxIterations, simulating variable computational work based on the input data. This variability directly influences gas consumption.
Event Emission: Finally, an event MessageReceived is emitted.
This code shows how gas consumption for the _ccipReceive function can fluctuate in response to the input data, highlighting the necessity for thorough testing under different scenarios to determine the correct gasLimit.

Gas estimation in a local environment
To facilitate testing within a local environment, you will use the MockCCIPRouter contract. This contract serves as a mock implementation of the CCIP Router contract, enabling the local testing of CCIP Sender and Receiver contracts. A notable feature of the MockCCIPRouter contract is its ability to emit a MsgExecuted event:

copy to clipboard
event MsgExecuted(bool success, bytes retData, uint256 gassed))
This event reports the amount of gas consumed by the ccipReceive function.

Foundry
Prerequisites
In your terminal, change to the foundry directory:

copy to clipboard
cd foundry
Ensure Foundry is installed.

Check the Foundry version:

copy to clipboard
forge --version
The output should be similar to the following:

copy to clipboard
forge 0.2.0 (545cd0b 2024-03-14T00:20:00.210934000Z)
You need version 0.2.0 or above. Run foundryup to update Foundry if necessary.

Build your project:

copy to clipboard
forge build
The output should be similar to:

copy to clipboard
[] Compiling...
[] Compiling 52 files with 0.8.19
[] Solc 0.8.19 finished in 2.55s
Compiler run successful!
Estimate gas
Located in the test directory, the SendReceive.t.sol test file assesses the gas consumption of the ccipReceive function. This file features a test case that sends a CCIP message to the MockCCIPRouter contract, which triggers the MsgExecuted event. This event provides insights into the gas requirements of the ccipReceive function by detailing the amount of gas consumed. The test case explores three scenarios to examine gas usage comprehensively across various operational conditions:

Baseline gas consumption: This scenario runs 0 iteration to determine the baseline gas consumption, representing the least amount of gas required.
Average gas consumption: This scenario runs 50 iterations to estimate the gas consumption under average operational conditions.
Peak gas consumption: This scenario runs 99 iterations to estimate the peak gas consumption, marking the upper limit of gas usage.
To run the test, execute the following command:

copy to clipboard
forge test -vv --isolate
Output example:

copy to clipboard
[] Compiling...
[] Compiling 52 files with 0.8.19
[] Solc 0.8.19 finished in 2.72s
Compiler run successful!

Ran 3 tests for test/SendReceive.t.sol:SenderReceiverTest
[PASS] test_SendReceiveAverage() (gas: 125166)
Logs:
  Number of iterations 50 - Gas used: 14740

[PASS] test_SendReceiveMax() (gas: 134501)
Logs:
  Number of iterations 99 - Gas used: 24099

[PASS] test_SendReceiveMin() (gas: 115581)
Logs:
  Number of iterations 0 - Gas used: 5190

Suite result: ok. 3 passed; 0 failed; 0 skipped; finished in 10.84ms (5.28ms CPU time)

Ran 1 test suite in 188.81ms (10.84ms CPU time): 3 tests passed, 0 failed, 0 skipped (3 total tests)
This table summarizes the gas usage for different iterations:

Scenario	Number of iterations	Gas used
Baseline gas consumption	0	5190
Average gas consumption	50	14740
Peak gas consumption	99	24099
The output demonstrates that gas consumption increases with the number of iterations, peaking when the iteration count reaches 99. In the next section, you will compare these results with those obtained from a local Hardhat environment.

Hardhat
Prerequisites
In your terminal, navigate to the hardhat directory:

copy to clipboard
cd ../hardhat
Install the dependencies:

copy to clipboard
npm install
Set the password to encrypt your environment variables using the following command:

copy to clipboard
npx env-enc set-pw
Set the following environment variables to deploy contracts on testnets:

PRIVATE_KEY: The private key for your testnet wallet. If you use MetaMask, follow the instructions to Export a Private Key. Note: Your private key is needed to sign any transactions you make such as making requests.
ETHEREUM_SEPOLIA_RPC_URL: The RPC URL for Ethereum Sepolia testnet. You can sign up for a personal endpoint from Alchemy, Infura, or another node provider service.
AVALANCHE_FUJI_RPC_URL: The RPC URL for Avalanche Fuji testnet. You can sign up for a personal endpoint from Infura or another node provider service.
ETHERSCAN_API_KEY: An Ethereum explorer API key, used to verify your contract. Follow this guide to get one from Etherscan.
Input these variables using the following command:

copy to clipboard
npx env-enc set
Compile the contracts:

copy to clipboard
npx hardhat compile
The output should be similar to:

copy to clipboard
Generating typings for: 31 artifacts in dir: typechain-types for target: ethers-v6
Successfully generated 114 typings!
Compiled 33 Solidity files successfully (evm target: paris).
Estimate gas
Located in the test directory, the Send-Receive.ts test file is designed to evaluate the gas usage of the ccipReceive function. This file employs the same logic as the Foundry test file, featuring three scenarios varying by the number of iterations. The test case transmits a CCIP message to the MockCCIPRouter contract, triggering the MsgExecuted event. This event provides insights into the gas requirements of the ccipReceive function by detailing the amount of gas used.

To run the test, execute the following command:

copy to clipboard
npx hardhat test
Example of the output:

copy to clipboard
  Sender and Receiver
Final Gas Usage Report:
Number of iterations 0 - Gas used: 5168
Number of iterations 50 - Gas used: 14718
Number of iterations 99 - Gas used: 24077
     should CCIP message from sender to receiver (1716ms)


  1 passing (2s)
This table summarizes the gas usage across different iterations:

Scenario	Number of iterations	Gas used
Baseline gas consumption	0	5168
Average gas consumption	50	14718
Peak gas consumption	99	24077
The output demonstrates that gas consumption increases with the number of iterations, peaking when the iteration count reaches 99.

Compare the results from Foundry and Hardhat
This table summarizes the gas usage for different iterations from both Foundry and Hardhat:

Scenario	Number of iterations	Gas used (Foundry)	Gas used (Hardhat)
Baseline gas consumption	0	5190	5168
Average gas consumption	50	14740	14718
Peak gas consumption	99	24099	24077
Gas usage trends across different iterations are consistent between Foundry and Hardhat and increase with the number of iterations, reaching a peak at 99. However, slight variations in gas usage between the two environments at each iteration level demonstrate the importance of extending gas usage estimation beyond local environment testing. To accurately determine the appropriate gas limit, it is recommended to conduct additional validations on the target blockchain. Setting the gas limit with a buffer is advisable to account for differences between local environment estimations and actual gas usage on the target blockchain.

Estimate gas usage on your local environment
Now that you've locally estimated the gas usage of the ccipReceive function using the provided projects, you can apply the same approach to your own Foundry or Hardhat project. This section will guide you through estimating gas usage in your Foundry or Hardhat project.

Estimate ccipReceive gas usage locally in your Foundry project
To estimate the gas usage of the ccipReceive function within your own Foundry project, follow these steps:

Create a testing file in the test directory of your project and import the MockCCIPRouter contract:

copy to clipboard
import {MockCCIPRouter} from "@chainlink/contracts-ccip/contracts/test/mocks/MockRouter.sol";
Note: The MockCCIPRouter receives the CCIP message from your CCIP Sender, calls the ccipReceive function on your CCIP Receiver, and emits the MsgExecuted event with the gas used.

Inside the setUp function, deploy the MockCCIPRouter contract, and use its address to deploy your CCIP Sender and CCIP Receiver contracts. For more details, check this example.

In your test cases:

Before transmitting any CCIP messages, use vm.recordLogs() to start capturing events. For more details, check this example.

After sending the CCIP message, use vm.getRecordedLogs() to collect the recorded logs. For more details, check this example.

Parse the logs to find the MsgExecuted(bool,bytes,uint256) event and extract the gas used. For more details, check this example.

Estimate ccipReceive gas usage locally in your Hardhat project
To estimate the gas usage of the ccipReceive function within your own Hardhat project, follow these steps:

Create a Solidity file in the contracts directory of your project and import the MockCCIPRouter contract:

copy to clipboard
import {MockCCIPRouter} from "@chainlink/contracts-ccip/contracts/test/mocks/MockRouter.sol";
Note: The MockCCIPRouter receives the CCIP message from your CCIP Sender, calls the ccipReceive function on your CCIP Receiver, and emits the MsgExecuted event with the gas used.

Create a testing file in your project's test directory.

Inside the deployFixture function, deploy the MockCCIPRouter contract and use its address to deploy your CCIP Sender and CCIP Receiver contracts. For more details, check this example.

In your test cases:

Send the CCIP message to the MockCCIPRouter contract. For more details, check this example.
Parse the logs to find the MsgExecuted(bool,bytes,uint256) event and extract the gas used. For more details, check this example.
Gas estimation on a testnet
To accurately validate your local environment's gas usage estimations, follow these steps:

Deploy and configure the CCIP Sender contract on the Avalanche Fuji testnet and the CCIP Receiver contract on the Ethereum Sepolia testnet.

Send several CCIP messages with the same number of iterations used in your local testing. For this purpose, use the sendCCIPMessage.ts script in the scripts/testing directory. This script includes a 10% buffer over the estimated gas usage to ensure a sufficient gas limit. Refer to the table below for the buffered gas limits for each iteration:

Scenario	Number of iterations	Estimated gas usage (Hardhat)	Buffered gas limit (+10%)
Baseline gas consumption	0	5168	5685
Average gas consumption	50	14718	16190
Peak gas consumption	99	24077	26485
Use Tenderly to monitor and confirm that the transactions execute successfully within the buffered gas limits. Subsequently, compare the actual gas usage of the ccipReceive function on the Ethereum Sepolia testnet against the buffered limits to fine-tune the final gas limit.

This approach ensures that your gas limit settings are validated against real-world conditions on testnets, providing a more accurate and reliable estimation for deploying on live blockchains.

Deploy and configure the contracts
To deploy and configure the CCIP Sender contract on the Avalanche Fuji testnet and the CCIP Receiver contract on the Ethereum Sepolia testnet, follow the steps below. Note: Your account must have some ETH tokens on Ethereum Sepolia and AVAX tokens on Avalanche Fuji.

Deploy the CCIP Sender on the Avalanche Fuji testnet:

copy to clipboard
npx hardhat run scripts/deployment/deploySender.ts --network avalancheFuji
Deploy the CCIP Receiver on the Ethereum Sepolia testnet:

copy to clipboard
npx hardhat run scripts/deployment/deployReceiver.ts --network ethereumSepolia
Authorize the Sender to send messages to Ethereum Sepolia:

copy to clipboard
npx hardhat run scripts/configuration/allowlistingForSender.ts --network avalancheFuji
Authorize the Receiver to receive messages from the Sender:

copy to clipboard
npx hardhat run scripts/configuration/allowlistingForReceiver.ts --network ethereumSepolia
Upon completion, you will find the CCIP Sender and Receiver contracts deployed and configured on their respective testnets. Contract addresses are available in the scripts/generatedData.json file.

Send CCIP Messages
Send three CCIP messages with different numbers of iterations:

copy to clipboard
npx hardhat run scripts/testing/sendCCIPMessages.ts --network avalancheFuji
Example output:

copy to clipboard
$ npx hardhat run scripts/testing/sendCCIPMessages.ts --network avalancheFuji
Approving 0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846 for 0x32A24e40851E19d1eD2a7E697d1a38228e9388a3. Allowance is 115792089237316195423570985008687907853269984665640564039457584007913129639935. Signer 0x9d087fC03ae39b088326b67fA3C788236645b717...
115792089237316195423570985008687907853269984665640564039457584007913129639935n

Number of iterations 0 - Gas limit: 5685 - Message Id: 0xf23b17366d69159ea7d502835c4178a1c1d1d6325edf3d91dca08f2c7a2900f7
Number of iterations 50 - Gas limit: 16190 - Message Id: 0x4b3a97f6ac959f67d769492ab3e0414e87fdd9c143228f9c538b22bb695ca728
Number of iterations 99 - Gas limit: 26485 - Message Id: 0x37d1867518c0f8c54ceb0c5507b46b8d44c6c53864218f448cba0234f8de867a
Open the CCIP explorer, search each message by its ID, and wait for each message to be successfully transmitted (Status in the explorer: Success).

For the example above, here are the destination transaction hashes:

Message id	Ethereum Sepolia transaction hash
0xf23b17366d69159ea7d502835c4178a1c1d1d6325edf3d91dca08f2c7a2900f7	0xf004eb6dab30b3cfb9d1d631c3f9832410b8d4b3179e65b85730563b67b1e689
0x4b3a97f6ac959f67d769492ab3e0414e87fdd9c143228f9c538b22bb695ca728	0xf004eb6dab30b3cfb9d1d631c3f9832410b8d4b3179e65b85730563b67b1e689
0x37d1867518c0f8c54ceb0c5507b46b8d44c6c53864218f448cba0234f8de867a	0xf004eb6dab30b3cfb9d1d631c3f9832410b8d4b3179e65b85730563b67b1e689
Note that the Ethereum Sepolia transaction hash is the same for all the messages. This is because CCIP batched the messages.

Check the actual gas usage
Open Tenderly and search for the destination transaction hash.

Search for _callWithExactGasSafeReturnData with a payload containing your messageId (without 0x). Example for 0xf23b17366d69159ea7d502835c4178a1c1d1d6325edf3d91dca08f2c7a2900f7.

Below the payload with your messageId, you will find the call trace from the Router to your Receiver contract. Call trace example.

Click on the Debugger tab and you'll get the gas details:

copy to clipboard
"gas":{
"gas_left":5685
"gas_used":5031
"total_gas_used":7994315
}
Note the gas_left is equal to the limit that is set in the sendCCIPMessages.ts script: 5685. The gas_used is the actual gas used by the Receiver contract to process the message.

Repeating the same steps for the other two messages, we can summarize the output:

Scenario	Number of iterations	Estimated gas usage (Hardhat)	Buffered gas limit (+10%)	Gas used on testnet
Baseline gas consumption	0	5168	5685	5031
Average gas consumption	50	14718	16190	14581
Peak gas consumption	99	24077	26485	23940
Testing on testnets has confirmed that a gas limit of 26,485 is adequate for the ccipReceive function to execute successfully under various conditions. However, it is important to note that gas usage may differ across testnets. Therefore, it is advisable to conduct similar validation efforts on the blockchain where you intend to deploy. Deploying and validating contracts across multiple testnets can be time-consuming. For efficiency, consider using offchain methods to estimate gas usage.

Offchain methods
This section guides you through estimating gas usage using two different offchain methods:

A Web3 provider using the ethers.js estimateGas function.
Tenderly simulation API. The Tenderly simulation API provides a more accurate result (Read this blog post to learn more) but you are limited to the blockchains supported by Tenderly.
These methods provide the most accurate and rapid means to determine the necessary gas limit for the ccipReceive function. You will use the same CCIP Receiver contract deployed on the Ethereum Sepolia testnet in the previous section.

Prerequisites
In your terminal, navigate to the offchain directory:

copy to clipboard
cd ../offchain
Modify the data.json file to insert the deployed addresses of your Sender and Receiver contracts.

Install the dependencies:

copy to clipboard
npm install
Set the password to encrypt your environment variables:

copy to clipboard
npx env-enc set-pw
Set up the following environment variables:

ETHEREUM_SEPOLIA_RPC_URL: The RPC URL for Ethereum Sepolia testnet. You can sign up for a personal endpoint from Alchemy, Infura, or another node provider service.
TENDERLY_ACCOUNT_SLUG: This is one part of your Tenderly API URL. You can find this value in your Tenderly account.
TENDERLY_PROJECT_SLUG: This is one part of your Tenderly API URL. You can find this value in your Tenderly account.
TENDERLY_ACCESS_KEY: If you don't already have one, you can generate a new access token.
Input these variables using the following command:

copy to clipboard
npx env-enc set
Generate Typechain typings for the Receiver contract:

copy to clipboard
npm run generate-types
Introduction of the scripts
The scripts are located in the src directory. Each script is self-explanatory and includes comprehensive comments to explain its functionality and usage. There are three scripts:

estimateGasProvider.ts: This script uses the eth_estimateGas Ethereum API to estimate the gas usage of the ccipReceive function. It simulates sending three CCIP messages to the Receiver contract with a varying number of iterations and estimates the gas usage using the ethers.js estimateGas function.

estimateGasTenderly.ts: This script leverages the Tenderly simulate API to estimate the gas usage of the ccipReceive function. Similar to the previous script, it simulates sending three CCIP messages to the Receiver contract with different numbers of iterations and estimates the gas usage using the Tenderly simulate API.

helper.ts: This script contains helper functions used by the other scripts. The two main functions are:

buildTransactionData: This function constructs a CCIP message for a specified number of iterations and then returns the transaction data.
estimateIntrinsicGas: Exclusively called by the estimateGasProvider.ts script, this function estimates the intrinsic gas of a transaction. The intrinsic gas represents the minimum amount of gas required before executing a transaction. It is determined by the transaction data and the type of transaction. Since this gas is paid by the initiator of the transaction, we use this function to estimate the intrinsic gas and then deduct it from the total gas used to isolate the gas consumed by the ccipReceive function.
Estimate gas using a Web3 provider
Ethereum nodes implement the eth_estimateGas Ethereum API to predict the gas required for a transaction's successful execution. To estimate the gas usage of the ccipReceive function, you can directly call the eth_estimateGas API via a Web3 provider or leverage a library like ethers.js, simplifying this interaction. This guide focuses on the ethers.js estimateGas function for gas estimation. To estimate the gas usage, execute the following command in your terminal:

copy to clipboard
npm run estimate-gas-provider
Example output:

copy to clipboard
$ npm run estimate-gas-provider

> offchain-simulator@1.0.0 estimate-gas-provider
> ts-node src/estimateGasProvider.ts

Final Gas Usage Report:
Number of iterations 0 - Gas used: 5377
Number of iterations 50 - Gas used: 14946
Number of iterations 99 - Gas used: 24324
The estimate may exceed the actual gas used by the transaction for various reasons, including differences in node performance and EVM mechanics. For a more precise estimation, consider using Tenderly (see the next section for details).

Estimate gas using Tenderly
To estimate the gas usage of the ccipReceive function using Tenderly, execute the following command:

copy to clipboard
npm run estimate-gas-tenderly
Example output:

copy to clipboard
$ npm run estimate-gas-tenderly

> offchain-simulator@1.0.0 estimate-gas-tenderly
> ts-node src/estimateGasTenderly.ts

Final Gas Usage Report:
Number of iterations 0 - Gas used: 5031
Number of iterations 50 - Gas used: 14581
Number of iterations 99 - Gas used: 23940
Comparison
The table below summarizes the gas estimations for different iterations using both Web3 provider and Tenderly:

Scenario	Number of iterations	Gas estimated (Web3 provider)	Gas estimated (Tenderly)
Baseline gas consumption	0	5377	5031
Average gas consumption	50	14946	14581
Peak gas consumption	99	24324	23940
The gas estimations from both Web3 provider and Tenderly are consistent across different iterations and align with actual testnet results. This demonstrates the accuracy and reliability of these offchain methods in estimating gas usage. However, you can notice that Tenderly provides more accurate results.

Conclusion
This tutorial has guided you through estimating the gas limit for the ccipReceive function using various methods. You have learned how to estimate gas usage in a local environment using Hardhat and Foundry, validate these estimations on testnets, and use offchain methods to estimate gas usage.

As we have explored various methods for estimating gas for the ccipReceive function, it is crucial to apply this knowledge effectively. Here are some targeted recommendations to enhance your approach to gas estimation:

Comprehensive Testing: Emphasize testing under diverse scenarios to ensure your gas estimations are robust. Different conditions can significantly affect gas usage, so covering as many cases as possible in your tests is crucial.
Preliminary Local Estimates: Local testing is a critical first step for estimating gas and ensuring your contracts function correctly under various scenarios. While Hardhat and Foundry facilitate development and testing, it's key to remember that these environments may not perfectly mirror your target blockchain's conditions. These initial estimates serve as valuable insights, guiding you toward more accurate gas limit settings when you proceed to testnet validations. Incorporating a buffer based on these preliminary results can help mitigate the risks of underestimating gas requirements due to environmental differences.
Efficiency with Offchain Methods: Since testing across different blockchains can be resource-intensive, leaning on offchain methods for gas estimation is invaluable. Tools such as Tenderly not only facilitate rapid and accurate gas usage insights on your target blockchains but also enable you to simulate the execution of the ccipReceive function on actual contracts deployed on mainnets. If Tenderly doesn't support a particular blockchain, a practical alternative is to use a Web3 provider that does support that chain, as illustrated in the Estimate gas using a Web3 provider section. This is particularly helpful when considering the diversity in gas metering rules across blockchains. This approach saves time and enhances the precision of your gas limit estimations, allowing for more cost-effective transactions from your dApp.
caution
Educational Example Disclaimer

This page includes an educational example to use a Chainlink system, product, or service and is provided to demonstrate how to interact with Chainlink's systems, products, and services to integrate them into your own. This template is provided "AS IS" and "AS AVAILABLE" without warranties of any kind, it has not been audited, and it may be missing key checks or error handling to make the usage of the system, product or service more clear. Do not use the code in this example in a production environment without completing your own audits and application of best practices. Neither Chainlink Labs, the Chainlink Foundation, nor Chainlink node operators are responsible for unintended outputs that are generated due to errors in code.