Chain Fusion
Chain Fusion technology enables canisters to interact with multiple blockchain networks in a decentralized manner. This allows developers to build application using information from as well as holding and transferring assets on various blockchains, eliminating the need for trusted intermediaries like bridges.

To make this possible, canisters must be able to

sign transactions

bi-directionally communicate with other chains

without a single point of trust.

To achieve the former, chain-key signatures let canisters control addresses on several blockchain networks and sign transactions to transfer their assets to other addresses.

For the latter, ICP nodes either exchange information with nodes from other blockchain networks natively (see Bitcoin integration for more details) or they use HTTPs outcalls to interact with JSON RPC providers for other networks (Ethereum Integration).

Among other applications, these integrations have been used to bring digital token twins to ICP. These twin tokens, called chain-key tokens, including ckBTC, ckETH, ckUSDC, and ckUSDT, are fully backed by their native tokens and controlled by a canister smart contract. This comes with high security guarantees and lets smart contracts on ICP to hold and transact these tokens at high speed and low cost.



Ethereum Integration
Canister smart contracts on ICP can directly interact with the Ethereum network and other networks that are using the Ethereum Virtual Machine (EVM), such as Polygon and Avalanche. This integration is possible thanks to ICP's HTTPS outcalls and chain-key signatures, which allow Ethereum state to be queried and Ethereum transactions to be signed and submitted by canisters.

HTTPS outcalls: To query information from Ethereum and other EVM networks, HTTPS outcalls are used. HTTPS outcalls can obtain information from external sources. In this integration, they're used to obtain data from JSON-RPC services by querying Ethereum's transactions, addresses, and block information. To facilitate JSON-RPC calls, the EVM RPC canister provides an API endpoint that canisters can use.

Chain-key signatures for ECDSA: A canister can have an Ethereum address and sign transactions for that address in a secure and decentralized way using chain-key cryptography. This allows canisters to hold Ethereum natively. Messages sent by the smart contract can be signed in this way, enabling calling any smart contract on Ethereum from the canister.
This functionality also forms the basis for EVM-based chain-key tokens, like ckETH, ckUSDC, and many more.

EVM RPC canister
Canisters deployed on ICP are able to communicate with the Ethereum blockchain and other EVM-compatible networks using the EVM RPC canister.  By sending messages to this canister, Ethereum smart contract states can be queried and Ethereum transactions can be submitted.

Beyond the Ethereum blockchain, this canister also has partial support for Polygon, Avalanche, and other popular EVM networks.


To interact with these external chains, the EVM RPC canister utilizes the ICP's HTTPS outcalls to make calls to JSON-RPC service providers. These services, such as Cloudflare and Alchemy, provide public APIs for interacting with blockchain networks. The EVM RPC canister acts as a gateway for a dapp's canisters to communicate with and query information from EVM-compatible chains. It provides endpoints that ICP developers can use to interact with Ethereum smart contracts and ensures that the responses received from the Ethereum network are secure and immediately useful within a canister.

When a canister makes a request to the EVM RPC canister for a specified RPC method, the EVM RPC canister makes a HTTPS outcall to one or more RPC endpoints on behalf of that canister. The HTTPs outcalls mechanism guarantees that at least 2/3 of the subnet's nodes agree on the response obtained from the server. Once the response is validated, it is sent to the canister that originated the request. 

By default for Candid-RPC methods such as eth_getTransactionReceipt, the EVM RPC canister sends the same request to at least three different RPC providers and compares the results. If there are discrepancies, the caller receives a set of inconsistent results to handle in a way that makes sense for the use case. Instead of relying on the default, the caller can specify the total number of providers to be queried or even list the concrete providers of choice. Moreover, the caller can also set a minimum number of providers that must return the same (non-error) result.

The EVM RPC is controlled by the Network Nervous System DAO, i.e., its functionality cannot be changed by a single entity. Together, these mechanisms ensure that no trust in additional parties (bridges or oracles) are necessary for the caller canister to send transactions and to condition executions on Ethereum state.


EVM RPC canister
Advanced
Ethereum
Tutorial
The EVM RPC canister is used for communicating with Ethereum and other EVM blockchains using an onchain API. Communication with EVM-compatible chains includes obtaining and sending information such as:

The logs of a specific block or transaction.

Information about a block.

Details about a transaction.

Historical data regarding the network's gas fee.

Transactions for a specific address.

Submitting a signed transaction.

Querying the state of a smart contract.

For creating and signing transactions, using ic-alloy provides a more seamless workflow. Requests made using ic-alloy are not replicated between more than one RPC provider, but that is acceptable when submitting signed transactions.

For querying token balances, verifying that transactions have the right number of confirmations, or other workflows that rely on replicated responses, using the EVM-RPC canister directly provides a better experience.

To use the EVM RPC canister, you can send requests to the instance deployed on the mainnet, or you can fork the source code and deploy your own instance of the canister.

The source code for this project is available on GitHub (internet-computer-protocol/evm-rpc-canister ⭐️) under the Apache 2.0 license.

Goal
The goal of the EVM RPC canister is to act as a gateway between canisters on ICP and EVM-compatible networks through RPC services such as Alchemy, Ankr, or Cloudflare. The EVM RPC canister provides the necessary methods for other ICP canisters to send requests to the Ethereum JSON-RPC API and receive responses.

Terminology
Below is a list of terms used to describe different aspects of using the EVM RPC canister:

RPC service: An IPv6 service such as Alchemy, Gateway.fm, or CloudFlare that offers access to the Ethereum JSON-RPC API over HTTPS. Note that other EVM blockchains are often covered by such a JSON-RPC API as well.

network: An EVM blockchain such as the Ethereum mainnet, Sepolia testnet, or layer-2 chain.

chain id: A well-known unique numeric identifier for an EVM network.

provider: A specific JSON-RPC service registered in the EVM RPC canister. Every chain ID for a particular service requires a different provider and typically also requires a different API key. Multiple providers can be registered for a service/chain ID combination.

Supported JSON-RPC providers
           	Ethereum Mainnet	Arbitrum One	Base Mainnet	Optimism Mainnet
Alchemy    	✅                	✅            	✅            	✅                
Ankr      	✅                	✅            	✅            	✅                
BlockPi    	✅                	✅            	✅            	✅                
Cloudflare	✅                	             	             	                 
LlamaNodes	✅                	✅            	✅            	✅                
PublicNode	✅                	✅            	✅            	✅                
Management of API keys
RPC providers often require API keys be used to authenticate RPC requests. Authenticated requests help mitigate potential DoS attacks that exhaust the request rate limits set by RPC providers. Using an API key can come with challenges for developers, such as:

API keys for RPC providers often require a paid subscription and/or compute credits beyond a certain number of requests per month.

For developers who want to build a quick prototype, it may not be worth procuring multiple API keys until later in development.

When a dapp developer controls an API key, the dapp is considered less decentralized.

Storing API keys securely is not supported at the platform level and requires developers to use their own strategies for protecting their keys, creating an additional complexity for developers who want to use reproducible builds. Personal keys are also visible to all nodes on the ICP subnet. Learn more about authentication.

To provide a solution for developers, the production EVM RPC canister is configured with the required API keys. If a developer wants to use their own providers with their own API keys, however, they can pass their own keys to the EVM RPC canister. Test variations of the EVM RPC canister do not use API keys.

Costs
Calls made to the EVM RPC canister cost cycles. The cost per request is generally similar to making the equivalent HTTPS outcalls in your own canister.

Learn more about the costs of EVM RPC requests.

Deployed canister
The EVM RPC canister runs on the 34-node fiduciary subnet with the following principal: 7hfb6-caaaa-aaaar-qadga-cai.

Refer to the GitHub repository for information on how to verify the hash of the deployed WebAssembly module.


How it works
Advanced
Ethereum
Tutorial
The Ethereum Virtual Machine (EVM) Remote Procedure Call (RPC) canister enables communication between ICP canisters and RPC services. These services, such as Cloudflare and Alchemy, provide public APIs for interacting with blockchain networks. The EVM RPC canister acts as a gateway for a dapp's canisters to communicate with and query information from EVM-compatible chains. It provides endpoints that ICP developers can use to interact with Ethereum smart contracts and ensures that the responses received from the Ethereum network are secure and immediately useful within a canister.

To make calls to these external chains, the EVM RPC canister utilizes the ICP HTTPS outcalls feature to make calls to JSON-RPC endpoints. HTTPS outcalls are used to make outgoing HTTP calls to traditional Web2 servers. The response returned from these servers can be used safely in the context of a canister without the risk of state divergence between the replicas on a subnet.

When a canister makes an HTTPS outcall, it calls the management canister API using the http_request method. The networking adapter on each replica executes the HTTP request by sending it to the external server. When the response is returned from the external server, the response goes through consensus on the subnet, where at least 2/3 of the subnet's nodes must agree on the response. Once the response is validated, it is sent to the management canister, which returns it to the canister that originated the request.

In the case of the EVM RPC canister, a canister makes a request to the EVM RPC canister for a specified RPC method, and the EVM RPC canister makes the HTTPS outcall to one or more RPC endpoints on behalf of that canister.

By default, for Candid-RPC methods such as eth_getTransactionReceipt, the EVM RPC canister sends the same request to at least three different RPC providers and compares the results. If there are discrepancies, the caller receives a set of Inconsistent results to handle in a way that makes sense for the use case. Otherwise, the method will return a Consistent result with a Candid value corresponding to the JSON-RPC response.

Authentication
Certain JSON-RPC endpoints require an API key to authenticate with the RPC provider. The EVM RPC canister is already configured with the required API keys, although a developer can still choose to use custom providers (with or without API keys) to make the call instead if desired. API keys typically have a subscription fee associated with them, but developers who use the EVM RPC canister's pre-configured keys do not need to subscribe to the RPC services themselves.

When not using API keys, developers should be mindful of:

The limit on the number of requests per hour, day, month, etc., depending on the provider.

Rate limits shared with other dapps on the same subnet.

When attaching personal keys to a call, developers should be mindful of:

All nodes on the ICP subnet will be able to view the API key.

If this is necessary, it is recommended to configure an IP address allowlist and monitor API key usage.

When using keys managed by the EVM RPC canister, developers should be mindful of:

Managed by DFINITY, so the API configuration should remain up to date.

More likely to be affected by a DoS attack.

API URLs may change unexpectedly.

May include additional cycles costs depending on the RPC provider.

Typed Candid-RPC requests
The EVM-RPC canister includes a fully-typed Candid interface to provide first-class support for certain RPC methods. The primary benefit of the "Candid-RPC" canister methods is the built-in agreement logic between multiple APIs. This requires transforming and canonicalizing the HTTPS outcall responses on a case-by-case basis, trading flexibility for increased confidence in the result.

Below is an overview of the types and method interfaces for the Candid-RPC endpoints:

type EthMainnetService = variant { Alchemy; Ankr; BlockPi; Cloudflare; PublicNode; ... };
type EthSepoliaService = variant { Alchemy; Ankr; BlockPi; PublicNode; ... };
type L2MainnetService = variant { Alchemy; Ankr; BlockPi; PublicNode; ... };

type RpcServices = variant {
  EthMainnet : opt vec EthMainnetService;
  EthSepolia : opt vec EthSepoliaService;
  ArbitrumOne : opt vec L2MainnetService;
  BaseMainnet : opt vec L2MainnetService;
  OptimismMainnet : opt vec L2MainnetService;
  Custom : record {
    chainId : nat64;
    services : vec record { url : text; headers : opt vec HttpHeader };
  };
};

type RpcConfig = record {
  responseSizeEstimate : opt nat64,
  ...
};

type MultiRpcResult<T> = variant {
  Consistent : Result<T, RpcError>;
  Inconsistent : vec (
    variant {  Ethereum : EthereumService;  Sepolia : SepoliaService; ... },
    Result<T, RpcError>
  );
};

eth_getLogs : (RpcServices, RpcConfig, EthGetLogsParam)
  -> (MultiRpcResult<vec LogEntry>);

eth_getBlockByNumber : (RpcServices, RpcConfig, BlockTag)
  -> (MultiRpcResult<Block>);

eth_getTransactionReceipt : (RpcServices, RpcConfig, Hash)
  -> (MultiRpcResult<opt TransactionReceipt>);

eth_getTransactionCount : (RpcServices, RpcConfig, GetTransactionCountArgs)
  -> (MultiRpcResult<TransactionCount>);

eth_feeHistory : (RpcServices, RpcConfig, FeeHistoryArgs)
  -> (MultiRpcResult<FeeHistory>);

eth_sendRawTransaction : (RpcServices, RpcConfig, text)
  -> (MultiRpcResult<SendRawTransactionResult>);



The shared Candid types are defined as follows:

EthMainnetService: An RPC service compatible with the Ethereum mainnet.

EthSepoliaService: An RPC service compatible with the Sepolia testnet.

L2MainnetService: An RPC service compatible with an Ethereum layer-2 network.

RpcServices: An input for Candid-RPC methods representing which chain and service(s) to use for the RPC call. By default, the canister uses at least 3 different RPC services.

RpcConfig: An optional input for Candid-RPC methods used to customize how the RPC request is performed by the canister.

General JSON-RPC requests
A general-purpose JSON-RPC endpoint is available for use cases requiring functionality beyond the supported Candid-RPC interface, making it possible to call a wider range of RPC services and EVM blockchains.

This endpoint also offers an improved developer experience when using the ethers-providers Rust crate or ethers npm package, which implement strongly-typed functions with convenient type conversions for each JSON-RPC method.

request

type RpcService = variant {
  EthMainnet : EthMainnetService;
  EthSepolia : EthSepoliaService;
  ArbitrumOne : L2MainnetService;
  BaseMainnet : L2MainnetService;
  OptimismMainnet : L2MainnetService;
  Provider : nat64;
  Custom : record { url : text; headers : opt vec HttpHeader };
};

request : (
  service : RpcService,
  jsonRequest : text,
  maxResponseBytes : nat64
) -> (
  Result<text, RpcError>
);


EthMainnet: Selects a built-in provider for the Ethereum mainnet.

EthSepolia: Selects a built-in provider for the Sepolia testnet.

ArbitrumOne: Selects a built-in provider for the Arbitrum layer-2 network.

BaseMainnet: Selects a built-in provider for the Base layer-2 network.

OptimismMainnet: Selects a built-in provider for the Optimism layer-2 network.

Chain: Selects a provider from the list of built-in providers with the given chain ID. An extensive list of chain IDs can be found on ChainList.org. Specifying Chain with no registered provider results in an error.

Provider: Selects the RPC provider with the given id.

Custom: Uses the provided JSON-RPC API information. This option can be used to pass a custom API key. header in Custom makes it possible to send HTTP headers with the request, usually for passing the API key.

The list of all built-in providers can be found by calling the getProvider canister method. If multiple providers are found for an RPC request, the canister prioritizes providers with primary set to true and chooses the option with the lowest id.

In many cases, these JSON-RPC methods work without canonicalization for HTTPS outcall consensus. We address individual edge cases as they arise using the same canonicalization logic as the corresponding Candid-RPC endpoint.


Using the EVM RPC canister
Advanced
Ethereum
Tutorial
For creating and signing transactions, using ic-alloy provides a more seamless workflow. Requests made using ic-alloy are not replicated between more than one RPC provider, but that is acceptable when submitting signed transactions.

For querying token balances, verifying that transactions have the right number of confirmations, or other workflows that rely on replicated responses, using the EVM-RPC canister directly provides a better experience.

Supported RPC methods
The following JSON-RPC methods are available as part of the canister's Candid interface:

eth_feeHistory: Queries the historical fee data to estimate gas prices for transactions.
eth_getLogs: Queries the logs of a specified block or transaction.
eth_getBlockByNumber: Queries information about a given block.
eth_getTransactionCount: Queries the number of transactions for a specified address.
eth_getTransactionReceipt: Queries details about a submitted transaction.
eth_sendRawTransaction: Submits a signed transaction to the Ethereum network.
eth_call: Query the state of a smart contract.
Other RPC methods, including those specific to non-Ethereum networks, may be accessed using the canister's request method.

Supported RPC providers
The EVM RPC canister has built-in support for the following Ethereum JSON-RPC providers:

Alchemy: Ethereum mainnet, Sepolia testnet, L2 chains.
Ankr: Ethereum mainnet, Sepolia testnet, L2 chains.
BlockPI: Ethereum mainnet, Sepolia testnet, L2 chains.
Cloudflare Web3: Ethereum mainnet.
Public Node: Ethereum mainnet, Sepolia testnet, L2 chains.
LlamaNodes: Ethereum mainnet, Sepolia testnet, L2 chains.
Many of the providers on ChainList.org can be called using the canister's request method.

Importing or deploying the EVM RPC canister
Using dfx deps
To use the EVM RPC canister, you can pull it into your project using dfx deps by configuring your project's dfx.json file:

{
  "canisters": {
    "evm_rpc": {
      "type": "pull",
      "id": "7hfb6-caaaa-aaaar-qadga-cai",
    }
  }
}

Then, run the commands:

# Start the local development environment
dfx start --background

# Locally deploy the `evm_rpc` canister
dfx deps pull
dfx deps init evm_rpc --argument '(record {})'
dfx deps deploy

Using Candid and Wasm files
Alternatively, you can include the EVM RPC canister by specifying the Candid and Wasm files in your dfx.json file:

{
  "canisters": {
    "evm_rpc": {
      "type": "custom",
      "candid": "https://github.com/internet-computer-protocol/evm-rpc-canister/releases/latest/download/evm_rpc.did",
      "wasm": "https://github.com/internet-computer-protocol/evm-rpc-canister/releases/latest/download/evm_rpc.wasm.gz",
      "remote": {
        "id": {
          "ic": "7hfb6-caaaa-aaaar-qadga-cai"
        }
      }
    }
  }
}


Then start the local development environment and deploy the canister locally with a specified number of nodes (31 for the fiduciary subnet):

dfx start --clean --background
dfx deploy evm_rpc --argument '(record {})'

Fork the EVM RPC canister
Another option is to create a fork of the EVM RPC canister:

git clone https://github.com/internet-computer-protocol/evm-rpc-canister


To deploy your own canister on the mainnet, run the dfx deploy command with the --network ic flag:

dfx deploy evm_rpc --network ic --argument '(record {})'

Note that when deploying your own canister, you may encounter API rate limits. Refer to the replacing API keys section to learn how to configure API credentials.

ic-alloy
The ic-alloy Rust crate can be used to interact with the EVM RPC canister from Rust code. It simplifies the code necessary to perform common EVM operations.

The ic-alloy-toolkit includes a collection of examples demonstrating how ic-alloy can be used.

View the ic-alloy documentation for more information.

Get event logs
Motoko
Rust
dfx
import EvmRpc "canister:evm_rpc";

import Cycles "mo:base/ExperimentalCycles";
import Debug "mo:base/Debug";

actor {
    public func getLogs() : async ?[EvmRpc.LogEntry] {

        // Configure RPC request
        let services = #EthMainnet(null);
        let config = null;

        // Add cycles to next call
        Cycles.add<system>(2000000000);

        // Call an RPC method
        let result = await EvmRpc.eth_getLogs(
            services,
            config,
            {
                addresses = ["0xB9B002e70AdF0F544Cd0F6b80BF12d4925B0695F"];
                fromBlock = ?#Number 19520540;
                toBlock = ?#Number 19520940;
                topics = ?[
                    ["0x4d69d0bd4287b7f66c548f90154dc81bc98f65a1b362775df5ae171a2ccd262b"],
                    [
                        "0x000000000000000000000000352413d00d2963dfc58bc2d6c57caca1e714d428",
                        "0x000000000000000000000000b6bc16189ec3d33041c893b44511c594b1736b8a",
                    ],
                ];
            },
        );

        // Process results
        switch result {
          // Consistent, successful results
          case (#Consistent(#Ok value)) {
            ?value
          };
          // Consistent error message
          case (#Consistent(#Err error)) {
            Debug.trap("Error: " # debug_show error);
            null
          };
          // Inconsistent results between RPC providers
          case (#Inconsistent(results)) {
            Debug.trap("Inconsistent results: " # debug_show results);
            null
          };
        };
    };
};


As described in the official Ethereum JSON-RPC documentation, the topics field is an order-dependent two-dimensional array that encodes the boolean logic for the relevant topics.

For example:

[[A], [B]] corresponds to A and B.

[[A, B]] corresponds to A or B.

[[A], [B, C]] corresponds to A and (B or C).

This example use case displays a caveat that comes with mapping the eth_getLogs spec to Candid, where a topic can either be a single value or an array of topics. A single-element array is equivalent to passing a string.

Get the latest Ethereum block info
Motoko
Rust
dfx
import EvmRpc "canister:evm_rpc";

import Cycles "mo:base/ExperimentalCycles";
import Debug "mo:base/Debug";

actor {
  public func getLatestBlock() : async ?EvmRpc.Block {

    // Configure RPC request
    let services = #EthMainnet(null);
    let config = null;

    // Add cycles to next call
    Cycles.add<system>(2000000000);

    // Call an RPC method
    let result = await EvmRpc.eth_getBlockByNumber(services, config, #Latest);

    // Process results
    switch result {
      // Consistent, successful results
      case (#Consistent(#Ok block)) {
        Debug.print("Success: " # debug_show block);
        ?block
      };
      // Consistent error message
      case (#Consistent(#Err error)) {
        Debug.trap("Error: " # debug_show error);
        null
      };
      // Inconsistent results between RPC providers
      case (#Inconsistent(_results)) {
        Debug.trap("Inconsistent results");
        null
      };
    };
  };
};


Get receipt for transaction
Motoko
Rust
dfx
import EvmRpc "canister:evm_rpc";

import Cycles "mo:base/ExperimentalCycles";
import Debug "mo:base/Debug";

actor {
  public func getTransactionReceipt() : async ?EvmRpc.TransactionReceipt {

    // Configure RPC request
    let services = #EthMainnet(null);
    let config = null;

    // Add cycles to next call
    Cycles.add<system>(2000000000);

    // Call an RPC method
    let result = await EvmRpc.eth_getTransactionReceipt(services, config, "0xdd5d4b18923d7aae953c7996d791118102e889bea37b48a651157a4890e4746f");

    // Process results
    switch result {
      // Consistent, successful results
      case (#Consistent(#Ok receipt)) {
        Debug.print("Success: " # debug_show receipt);
        receipt
      };
      // Consistent error message
      case (#Consistent(#Err error)) {
        Debug.trap("Error: " # debug_show error);
        null
      };
      // Inconsistent results between RPC providers
      case (#Inconsistent(_results)) {
        Debug.trap("Inconsistent results");
        null
      };
    };
  };
};


Call an Ethereum smart contract
Motoko
Rust
import EvmRpc "canister:evm_rpc";

import Cycles "mo:base/ExperimentalCycles";
import Debug "mo:base/Debug";

actor {
  public func call() : async ?Text {

    // Configure RPC request
    let services = #EthMainnet(null);
    let config = null;

    // Add cycles to next call
    Cycles.add<system>(2000000000);

    // Call an Ethereum smart contract. The smart contract's information in this example is hard-coded.
    let result = await EvmRpc.eth_call(services, config, {
      block = null;
      transaction = {
        to = ?"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
        input = ?"0x70a08231000000000000000000000000b25eA1D493B49a1DeD42aC5B1208cC618f9A9B80"; // ABI-encoded
        accessList = null;
        blobVersionedHashes = null;
        blobs = null;
        chainId = null;
        from = null;
        gas = null;
        gasPrice = null;
        maxFeePerBlobGas = null;
        maxFeePerGas = null;
        maxPriorityFeePerGas = null;
        nonce = null;
        type_ = null;
        value = null
      };
    });

    // Process results
    switch result {
      // Prints the response if each RPC provider returns a consistent, successful result
      case (#Consistent(#Ok response)) {
        Debug.print("Success: " # debug_show response);
        ?response // ABI-encoded
      };
      // Trap is an RPC provider that returns an error message consistent with the response of the other providers
      case (#Consistent(#Err error)) {
        Debug.trap("Error: " # debug_show error);
        null
      };
      // Trap if an RPC provider returns a response inconsistent with the other providers
      case (#Inconsistent(_results)) {
        Debug.trap("Inconsistent results");
        null
      };
    };
  };
};


Get number of transactions for a contract
Motoko
Rust
dfx
import EvmRpc "canister:evm_rpc";

import Cycles "mo:base/ExperimentalCycles";
import Debug "mo:base/Debug";

actor {
  public func getTransactionCount() : async ?Nat {

    // Configure RPC request
    let services = #EthMainnet(null);
    let config = null;

    // Add cycles to next call
    Cycles.add<system>(2000000000);

    // Call an RPC method
    let result = await EvmRpc.eth_getTransactionCount(
      services,
      config,
      {
        address = "0x1789F79e95324A47c5Fd6693071188e82E9a3558";
        block = #Latest;
      },
    );

    // Process results
    switch result {
      // Consistent, successful results
      case (#Consistent(#Ok count)) {
        Debug.print("Success: " # debug_show count);
        ?count
      };
      // Consistent error message
      case (#Consistent(#Err error)) {
        Debug.trap("Error: " # debug_show error);
        null
      };
      // Inconsistent results between RPC providers
      case (#Inconsistent(_results)) {
        Debug.trap("Inconsistent results");
        null
      };
    };
  };
};


Get the fee history
Motoko
Rust
dfx
import EvmRpc "canister:evm_rpc";

import Cycles "mo:base/ExperimentalCycles";
import Debug "mo:base/Debug";

actor {
  public func getFeeHistory() : async ?EvmRpc.FeeHistory {

    // Configure RPC request
    let services = #EthMainnet(null);
    let config = null;

    // Add cycles to next call
    Cycles.add<system>(2000000000);

    // Call an RPC method
    let result = await EvmRpc.eth_feeHistory(
      services,
      config,
      {
        blockCount = 3;
        newestBlock = #Latest;
        rewardPercentiles = null;
      },
    );

    // Process results

    switch result {
      // Consistent, successful results
      case (#Consistent(#Ok history)) {
        Debug.print("Success: " # debug_show history);
        history
      };
      // Consistent error message
      case (#Consistent(#Err error)) {
        Debug.trap("Error: " # debug_show error);
      };
      // Inconsistent results between RPC providers
      case (#Inconsistent(_results)) {
        Debug.trap("Inconsistent results");
      };
    };
  };
};


Send a raw transaction
The EVM RPC canister can also be used to send raw transactions to the Ethereum and other EVM-compatible chains. Examples for using the EVM RPC canister can be found below, or you can view the documentation for sending a raw ETH transaction.

Motoko
Rust
dfx
import EvmRpc "canister:evm_rpc";

import Cycles "mo:base/ExperimentalCycles";
import Debug "mo:base/Debug";

actor {
  public func sendRawTransaction() : async ?EvmRpc.SendRawTransactionStatus {

    // Configure RPC request
    let services = #EthMainnet(null);
    let config = null;

    // Add cycles to next call
    Cycles.add<system>(2000000000);

    // Call an RPC method
    let result = await EvmRpc.eth_sendRawTransaction(
      services,
      config,
      "0xf86c098504a817c800825208943535353535353535353535353535353535353535880de0b6b3a76400008025a028ef61340bd939bc2195fe537567866003e1a15d3c71ff63e1590620aa636276a067cbe9d8997f761aecb703304b3800ccf555c9f3dc64214b297fb1966a3b6d83",
    );

    switch result {
      // Consistent, successful results
      case (#Consistent(#Ok status)) {
        Debug.print("Status: " # debug_show status);
        ?status
      };
      // Consistent error message
      case (#Consistent(#Err error)) {
        Debug.trap("Error: " # debug_show error);
        null
      };
      // Inconsistent results between RPC providers
      case (#Inconsistent(_results)) {
        Debug.trap("Inconsistent results");
        null
      };
    };
  };
};


Some JSON-RPC APIs may only return a NonceTooLow status when successfully submitting a transaction. This is because during the HTTP outcall consensus, only the first request is successful, while the others reply with a duplicate transaction status. If you encounter this issue, one possible workaround is to use a deduplicating proxy server such as the community-built C-ATTS EVM RPC proxy (source code).

Error "already known"
Sending a transaction to the Ethereum network is a state changing operation. Since the EVM-RPC canister sends a transaction to some JSON-RPC providers via HTTPs outcalls, each contacted provider will receive the same transaction multiple times.

Therefore, it is possible that the contacted provider may return the following error:

"{ code: -32603, message: \"already known\" }"

Assuming the sent transaction is valid, one node of the contacted provider should accept the transaction, while the others should return some error such as the one displayed above. Note that the exact error returned is EVM-client specific, as the Ethereum JSON-RPC API itself doesn't specify errors, meaning that other errors could occur, such as an error indicating that consensus on the IC could not be reached.

Note that even if an error is returned, you should assume that your transaction is known to the Ethereum network. You can verify whether your transaction was included in a block by querying the transaction count (via eth_getTransactionCount) at the Latest block height.

Send a raw JSON-RPC request
Motoko
Rust
dfx
import EvmRpc "canister:evm_rpc";

import Cycles "mo:base/ExperimentalCycles";
import Debug "mo:base/Debug";

actor {
  public func rawJsonRpcRequest() : async ?Text {

    // Configure JSON-RPC request
    let service = #EthMainnet(#PublicNode);
    let json = "{\"jsonrpc\":\"2.0\",\"method\":\"eth_gasPrice\",\"params\":[],\"id\":1}";
    let maxResponseBytes : Nat64 = 1000;

    // Optionally retrieve the exact number of cycles for an RPC request
    let cyclesResult = await EvmRpc.requestCost(service, json, maxResponseBytes);
    let cycles = switch cyclesResult {
      case (#Ok cycles) { cycles };
      case (#Err err) {
        Debug.trap("Error while calling `requestCost`: " # debug_show err);
      };
    };

    // Submit the RPC request
    Cycles.add<system>(cycles);
    let result = await EvmRpc.request(service, json, maxResponseBytes);

    // Process response
    switch result {
      case (#Ok response) {
        Debug.print("Success:" # debug_show response);
        ?response
      };
      case (#Err err) {
        Debug.trap("Error while calling `request`: " # debug_show err);
        null
      };
    };
  };
};


Specifying an EVM chain
Motoko
Rust
dfx
let services = #EthMainnet;
let config = null;

Specifying RPC services
RpcServices is used to specify which HTTPS outcalls APIs to use in the request. There are several ways to use specific JSON-RPC services:

// Used for Candid-RPC canister methods (`eth_getLogs`, `eth_getBlockByNumber`, etc.)
type RpcServices = variant {
  EthMainnet : opt vec EthMainnetService;
  EthSepolia : opt vec EthSepoliaService;
  ArbitrumOne : opt vec L2MainnetService;
  BaseMainnet : opt vec L2MainnetService;
  OptimismMainnet : opt vec L2MainnetService;
  ...
  Custom : record {
    chainId : nat64;
    services : vec record { url : text; headers : opt vec (text, text) };
  }
};

// Used for the JSON-RPC `request` canister method
type RpcService = variant {
  EthMainnet : EthMainnetService;
  EthSepolia : EthSepoliaService;
  ArbitrumOne : L2MainnetService;
  BaseMainnet : L2MainnetService;
  OptimismMainnet : L2MainnetService;
  ...
  Provider : nat64;
  Custom : record { url : text; headers : opt vec (text, text) };
};


Replacing API keys
If you are a controller or a principal autorized to manage API keys (given upon canister initialization in the manageApiKeys field), you can replace the API keys used by the EVM RPC canister. The first step is to determine the relevant providerId that identifies a supported JSON RPC provider.

Run the following command to view all registered providers:

dfx canister call evm_rpc getProviders

You should see a list of values. Look for the providerId, which in this case is 0:

record {
  access = variant {
    Authenticated = record {
      publicUrl = opt "https://cloudflare-eth.com/v1/mainnet";
      auth = variant { BearerToken = record { url = "https://cloudflare-eth.com/v1/mainnet";} };
    }
  };
  alias = opt variant { EthMainnet = variant { Cloudflare } };
  chainId = 1 : nat64;
  providerId = 0 : nat64;
};


Update the configuration for an existing provider using the updateApiKeys method:

dfx canister call evm_rpc updateApiKeys '(vec { record { 0 : nat64;  opt "YOUR-API-KEY" } } )'


Error messages
Error "TooFewCycles"
"ProviderError(TooFewCycles { expected: 798336000, received: 307392000 })"


You may receive this error if multiple JSON-RPC providers were queried and one did not receive enough cycles for the request. You can safely attach more cycles to your query, since unused cycles will be refunded.

Filtering logs
The consoleFilter argument can be passed to the EVM RPC canister to filter what log messages are shown.

The default configuration is to show all logs:

dfx deploy evm_rpc --argument "(record { consoleFilter = opt variant { ShowAll } })"


Hide all logs:

dfx deploy evm_rpc --argument "(record { consoleFilter = opt variant { HideAll } })"


The ShowPattern and HidePattern arguments can be used to filter out regular expressions, such as filtering out logs tagged with INFO:

dfx deploy evm_rpc --argument "(record { consoleFilter = opt variant { ShowPattern = "^INFO" } })"


Or, hide logs tagged with TRACE_HTTP:

dfx deploy evm_rpc --argument "(record { consoleFilter = opt variant { HidePattern = "^TRACE_HTTP" } })"


ShowPattern and HidePattern are evaluated using the regex crate.

Important notes
RPC result consistency
When calling RPC methods directly through the Candid interface (rather than via the request method), the canister will compare results from several JSON-RPC APIs and return a Consistent or Inconsistent variant based on whether the APIs agree on the result.

By default, the canister uses three different RPC providers, which may change depending on availability. It's possible to specify which providers to use for this consistency check. For example:

dfx canister call evm_rpc eth_getTransactionCount '(variant {EthMainnet = opt vec {Cloudflare; PublicNode}}, record {address = "0xdAC17F958D2ee523a2206206994597C13D831ec7"; block = variant {Tag = variant {Latest}}})' --with-cycles 100000000000 --wallet=$(dfx identity get-wallet)


HTTPS outcalls consensus
Be sure to verify that RPC requests work as expected on the ICP mainnet. HTTPS outcalls performed in the request method only reach consensus if the JSON-RPC response is the same each call.

If you encounter an issue with consensus, please let us know and we will look into whether it's possible to add official support for your use case.

Response size estimates
In some cases, it's necessary to perform multiple HTTPS outcalls with increasing maximum response sizes to complete a request. This is relatively common for the eth_getLogs method and may increase the time and cost of performing an RPC call. One solution is to specify an initial response size estimate (in bytes):

dfx canister call evm_rpc eth_getLogs "(variant {EthMainnet}, record {responseSizeEstimate = 5000}, record {addresses = vec {\"0xdAC17F958D2ee523a2206206994597C13D831ec7\"}})" --with-cycles=1000000000 --wallet=$(dfx identity get-wallet)


If the response is larger than the estimate, the canister will double the max response size and retry until either receiving a response or running out of cycles given by the --with-cycles flag.


EVM RPC costs
Advanced
Ethereum
Tutorial
Each call made to the EVM RPC canister costs cycles.

JSON-RPC requests typically cost between 10^8 and 10^9 cycles, which is equivalent to approximately $0.0001 - $0.001 USD.

Because the Candid-RPC methods of the EVM RPC canister use built-in retries and multiple providers, the amount of cycles required for each RPC call isn't predictable beforehand. The idea for these methods is to send a maximum cycles budget to perform the request.

The EVM RPC canister will continue retrying the request until it runs out of cycles sent with the request. This is important for requests such as eth_getLogs, where one request might return 100x as much data as the same request a few days earlier if there is a spike in smart contract activity. As a result, the optimal cycles budget is different for each use case. It is suggested to send 10_000_000_000 cycles as a starting point and adjust from there.

The following formula shows how to calculate the cycles cost for an RPC request:

(
  5_912_000
  + 60_000 * nodes_in_subnet // Number of nodes in the subnet
  + 2400 * request_size // Size of the HTTP request in bytes
  + 800 * max_response_size // Maximum HTTP response size in bytes
) * nodes_in_subnet
  * rpc_services // Number of RPC services used to check consistency


The total cost for an RPC request (assuming a 1kB request, 1kB response, 34-node subnet, and 1 XDR = $1.336610 USD) is ~ $0.00051 USD.

Note that the cost is multiplied by the number of RPC services used for the consistency logic. If you specify three different services, it will cost three times as much as a call to a single RPC provider.

In addition, it's necessary to send 10_000_000 * nodes_in_subnet * rpc_services additional cycles, which will be refunded, as they serve as a buffer for any future increases in third-party JSON-RPC API costs.

The EVM RPC canister automatically refunds any cycles sent beyond the cost of the RPC request, so it's possible to send more cycles than necessary without consequence. Sending extra cycles will also provide a budget to retry the request with a larger maximum response size for Candid-RPC methods such as eth_getLogs and eth_getBlockByNumber.

Collateral cycles
In addition to the cost of the RPC request itself, callers must also pass at least 0.00028 TC of "collateral cycles" to account for possible future downstream API price increases. The canister currently refunds all of these cycles, but this may change in the future.

Attaching the correct amount of cycles
To determine how many cycles need to be sent with your RPC call, you can use the requestCost query method. This is used to predict costs for calls to the request method:

`requestCost`

requestCost : (
  source : JsonRpcSource,
  jsonRequest : text,
  maxResponseBytes :  nat64
) -> (
  Result<nat, RpcError>
) query;

This query method accepts the same arguments as the canister's request method and returns the number of cycles to send with an equivalent call.

Once you have determined how many cycles your call will need, you can send them in your call through a CDK or using dfx with the --with-cycles flag.

Motoko
Rust
dfx
import EvmRpc "canister:evm_rpc";
import Cycles "mo:base/ExperimentalCycles";

Cycles.add<system>(1000000000);
let result = await EvmRpc.eth_getBlockByNumber(services, null, #Latest);


In order to accurately measure the HTTPS outcalls cost and protect from an accidental large response, the caller must specify the maximum expected number of bytes. Due to the potentially high cost of performing outcalls with a suboptimal max response size, it’s generally in the caller’s best interest to choose a value for maxResponseBytes on a case-by-case basis for each situation. Developers can determine this value by measuring the size of expected JSON responses from an API playground such as Alchemy Sandbox.

The Candid RPC methods use a built-in default response bytes, which you can override with the RpcConfig value.

You may choose to repeatedly call the request method with an increasingly large value for maxResponseBytes to handle variable response sizes. We defer this choice of strategy to the caller for raw JSON-RPC calls. For Candid-RPC convenience methods, the canister doubles the max response size and retries until the response size is sufficient, starting with a reasonable default for each RPC method. In contrast, the JSON-RPC canister only ever makes one request, deferring the retry logic to the caller. It’s worth noting that the caller essentially pays for each outcall as though they are sending these requests from their own canister.

The EVM RPC canister retries the call if:

There are enough cycles left that have been sent by the caller.

The call fails due to maxResponseBytes being set too low. Each RPC method has a built-in default maxResponseBytes setting that can be overridden.

Additionally, the RpcConfig parameter supports an optional responseSizeEstimate that can be fine-tuned to reduce the cost of the RPC requests.


ICP <> Ethereum: How ICP’s EVM RPC Canister Connects the Networks
DFINITY
DFINITY

Follow
6 min read
·
May 23, 2024
50




Zoom image will be displayed

EVM RPC Canister
We, the DFINITY R&D team, are excited to announce that the EVM RPC canister is now live and available for use by the ICP developer community. The EVM RPC is an Internet Computer canister smart contract designed to communicate with Ethereum and other EVM blockchains using an on-chain API.

Why this is Important
Developers aim to write ICP smart contracts that communicate with the Ethereum network and other EVM chains. ICP already facilitates this through HTTPS outcalls, and the Ethereum protocol defines a specification for software applications to interact with any Ethereum node via an HTTP-based RPC (remote procedure call) interface.

With the rise of EVM-compatible layer-2 chains, developers can now leverage this interface to sign and send raw transactions, among other capabilities. The RPC interface can be used to interact directly with the Ethereum network and other networks such as Optimism or Arbitrum.

Despite the availability of protocol-level tools, bundling them together can be burdensome for developers. This is why the DFINITY R&D team announced a few months ago that they would create an EVM RPC canister for the community, integrating all best practices.

DFINITY’s engineering team has designed a solution that harnesses the capability of a canister smart contract to perform HTTPS outcalls and reach Byzantine consensus to provide a means of integrating directly with the Ethereum network or any EVM-compatible derivative network. This is achieved through an integration with other canister smart contracts deployed on the ICP mainnet. The EVM RPC Canister makes it possible to combine the limitless computational power of the Internet Computer with the billions in assets held on the Ethereum network to build new, novel, entertaining, and useful applications in the decentralized application ecosystem.

How to use it
The canister is live!

To get started, checkout the EVM RPC documentation or the sample code or the canister code on GitHub or you can look up the canister on the ICP dashboard!

How it works
Before the EVM RPC Canister
To send or receive data from Ethereum, such as querying the latest block, an application must perform several complex steps.

The first step is obtaining the address of an Ethereum node to send a request to. While several aggregators do exist, the availability of any individual RPC server is not guaranteed, making it difficult to build a reliable application that depends on data coming from an arbitrary RPC endpoint. Furthermore, several RPC servers lack a coherent privacy policy, and many introduce a high latency into the request chain.

For these reasons, it is typical to utilize a well-known RPC provider, such as Ankr or PublicNode, who provide API’s with high uptime, low latency, and a broad range of supported chains.

Zoom image will be displayed

An application that uses a sole RPC provider to query an Ethereum node.
For an application with stringent security requirements, it is important to also ensure the result from a provider is consistent with other nodes on the network. This is accomplished by sending multiple requests in parallel to differing providers, then comparing the response returned by each to determine if they agree. If there is a mismatch in any of the responses, there must be a well-defined mechanism for distinguishing fact from fiction.

Zoom image will be displayed

An application that utilizes several RPC providers to ensure a high degree of data integrity
Finally, the response returned by the Ethereum node must be decoded and deserialized into the underlying type system used by the application, such that it can be utilized in the context of the application’s implementation of the Ethereum data.

The Internet Computer’s role as a hub in linking disparate blockchains together is made possible through strong security properties and a unique ability to execute outbound HTTPS requests on-chain through canister smart contracts.

What this all means is that any application that seeks to integrate with the Ethereum network in some way must procure multiple API keys, store them securely and manage their rotation, while also vetting providers to ensure API quality, uptime, and data integrity. On top of that, the application must define interfaces and implement conversion logic to work with the incoming data. If that all seems like it’s a bit much to deal with efficiently for a standalone application, that’s because it is.

The design behind the EVM RPC Canister
The EVM RPC Canister seeks to reduce the complexity in querying and transacting with EVM-compatible networks. It is designed to be used by other ICP canisters and applications deployed outside of ICP that leverage agents.

The service exposes an interface that provides encapsulation of several key Ethereum JSON RPC APIs into a conveniently typed Candid interface, ensuring response consistency by canonicalizing and comparing results from multiple providers for a given call. This ensures a high-degree of confidence in the integrity of data returned from and sent to supported EVM-compatible networks, including the Ethereum mainnet.

The EVM RPC Canister also abstracts away the burden of procuring, managing, and rotating API keys for different RPC providers, exposing a single interface that scales opaquely with usage. This means that a canister only needs to attach cycles and can assume the EVM RPC Canister will just work, allowing the canister developer to focus solely on their business logic.

Behind the scenes, the EVM RPC canister is instrumented and monitored around the clock for irregularities, spikes in usage, outages, attacks, and more, backed by a highly skilled team ready to resolve any issues the moment they arise.

Zoom image will be displayed

Governance
The Network Nervous System is a DAO, or decentralized autonomous organization, that governs the Internet Computer, making it possible to build democratized, decentralized applications that are governed by a community. The EVM RPC Canister is an example of one such application — it is controlled by the NNS, meaning any changes that are made to the canister’s code must be done so through a proposal that is voted on and approved by Neurons in the system (i.e. ICP token holders).

Any changes to RPC providers, including their addition, removal, or modification, must be performed by a party authorized to perform a one-time action through an NNS proposal. This ultimately puts the power to shape the capabilities of the EVM RPC Canister directly in the hands of the community utilizing it.

The code that is used to build the Web Assembly (Wasm) module that gets installed to the EVM RPC Canister is publicly available on GitHub, and anyone can build the Wasm and verify its hash matches the one deployed to the ICP mainnet. Doing so ensures the integrity of the canister itself — the code that one is able to read and verify themselves is the exact same code running on the Internet Computer.

Secure and convenient
The EVM RPC Canister absorbs the complexity of procurement, management, and rotation of API keys used to facilitate communication with Ethereum and Ethereum-compatible networks. It offers several conveniences that make working with data originating from EVM-based RPC endpoints simple and easy. DFINITY’s development of the EVM RPC Canister as a decentralized service allows the community to govern its evolution over time.

Together, these innovations are making it possible for developers to build dApps and DeFi projects that natively use one of the largest cryptocurrencies in the world, leveraging immense value and bringing advanced capabilities to Ethereum smart contracts.

Conclusion
The EVM RPC Canister simplifies the integration of ICP smart contracts with Ethereum and other EVM-compatible networks. By abstracting away the complexity of managing API keys and ensuring data integrity, the EVM RPC Canister empowers developers to focus on building innovative, decentralized applications.

Get Started Today

Explore the EVM RPC documentation to understand how to integrate the EVM RPC Canister into your projects.
Check out the sample code to see practical implementations of the EVM RPC Canister.
Join the developer community at forum.dfinity.org to share your experiences, ask questions, and collaborate with other developers.
By using the EVM RPC Canister, you can build dApps and DeFi projects that harness the strengths of both ICP and Ethereum, driving forward the future of decentralized applications.

____

Start building at internetcomputer.org and join the developer community at forum.dfinity.org.



